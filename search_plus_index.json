{"./":{"url":"./","title":"说明","keywords":"","body":" 说明 1. 文章内容目录 2. 项目开发部署 2.1 本地开发 2.2 服务部署 说明 这是我的个人blog，里面包含了我一些平时整理的资料文档。 github地址：https://github.com/yulilong/my_blog github pages地址：https://yulilong.github.io/my_blog/ 由于有的时候github访问慢、打不开，本人又在码云上部署了同样内容： 码云地址：https://gitee.com/dragon-li/my-wiki 码云 pages地址：http://dragon-li.gitee.io/my-wiki/ 1. 文章内容目录 请参考SUMMARY.md文件。 2. 项目开发部署 本服务使用的是gitbook + github pages托管形式网站。 gitbook使用教程 本地电脑编辑器推荐使用(打不开尝试科学上网)：https://typora.io/ 2.1 本地开发 需要本地电脑里面有终端和nodejs，如果没有请自行查找安装，nodejs官网：http://nodejs.cn/ 1、代码克隆到本地电脑。 2、在终端使用npm install命令安装gitbook插件。 3、终端使用npm start命令启动本地开发服务。 4、在浏览器中输入http://localhost:4000/地址查看项目。 2.2 服务部署 终端使用bash deolog.sh命令运行自动部署脚本。 具体部署方法请参照./deploy.sh文件内容。 powered by Gitbook文件最后修改时间： 2019-10-25 01:23:46 "},"SUMMARY.html":{"url":"SUMMARY.html","title":"项目目录","keywords":"","body":" 说明 项目目录 git GIT介绍、安装、配置 git使用教程 git常见问题及解决 合并多个Commit git代码冲突处理软件P4Merge git内部原理揭秘 Mac Mac下常用的软件 Mac系统操作习惯设置 Mac快捷键和一些常用操作 Mac下终端常用设置、命令、快捷键 Mac下Iterm2使用及快捷键 Mac中常见错误以及处理方法 Mac下vscode编辑器设置 Mac下vscode快捷键 Mac-Office2016使用设置 Mac下Nginx的安装运行 Mac下sublime编辑器设置 Mac下移动硬盘分区用做TimeMachine的备份 Mac下angular开发环境安装 Mac-install-RVM,ruby,pqadmin3,rubymine2016 linux linux下常用的终端命令 linux下常用软件 Linux查找文件内容 find命令详解 linux下Nginx安装配置 centos7下习惯设置 centos7搭建samba方法 centos7错误处理 centos7_VNC_install centos7ruby相关软件安装l Terminal终端快捷键 VIM编辑器常用命令与用法总结 virtualbox虚拟机、centos7安装增强工具 npm NPM使用介绍 NPM常见问题 package.json文件详解 NPM常用的包 其他 Chrome浏览器开发者工具使用 Chrome浏览器有用的插件 gitbook入门教程 常用正则表达式 HTTP方法详解 Markdown常用语法与编辑器支持情况 VS2010编译器设置 VS2010开发控制台程序遇到的问题 阻止定向广告 英文字母缩写的含义 VUE开发遇见的问题 工作相关 工作常用代码片段 开发注意事项 类和模块 项目常用的配置 angular angularJS资料 angularJS开发遇见的问题 arcgis开发记录 angular2开发知识点 angular2网页前端执行流程 angular2中引入插件 angular-CLI中一些问题 angular下arcgis开发遇见的问题 angular编程规范 TS_JS中一些知识点 ruby、rails ruby中语法知识 include和extend以及模块中ClassMethods require,load,include,extend的显著区别 Object、Class、Module之间关系 rails中常见问题 ruby比较常用的gems包 ruby_gems命令 国内RubyGems镜像 Ruby中任务构建工具rake的入门学习教程 Ruby中的Rake任务详述 ruby_on_Rails中的Rake教程 rubyor_rails错误解决 ruby面试题 RubyMine常用快捷键 rubymine习惯设置 haml语法符号的含义 manageIQ manageIQ开发环境安装centos manageIQ开发环境安装Mac manageIQ代码结构、框架、执行流程分析 manageIQ汉化 manageIQ网页部分功能代码实现 新建提供者 manageiq各种云平台provide资料 manageIQ服务部署 manageIQ网页图标、图片、网页导航栏风格修改 开发manageiq遇见的问题、错误解决 添加新的Providers代码开发 azure azure获取TenantID、SubscriptionID、ClientID、ClientKey azure开发连接的国内网站 azure-armrest中链接作用 azure使用虚拟机生成私有镜像 面试 JS CSS 问过的问题 powered by Gitbook文件最后修改时间： 2020-01-02 10:18:24 "},"doc/git/001-GIT介绍、安装、配置.html":{"url":"doc/git/001-GIT介绍、安装、配置.html","title":"GIT介绍、安装、配置","keywords":"","body":" 1. GIT介绍 2. 使用GIT的好处 3. GIT 安装 4. GIT 配置 4.1 GIT 初始化设置、命令别名设置 4.2 如果终端安装了oh-my-zsh，会带一堆git命令别名 4.3 GIT配置文件介绍 5. git设置远程仓库账号密码(拉取、上传代码不用输入用户名密码) 6. git文件夹详解 [TOC] 1. GIT介绍 git是一个分布式版本控制软件，与常用的版本控制工具如CVS、Subversion不同，支持离线开发，离线存储。强大的分支功能，适合多个独立开发者协作。速度块。如果拥有CVS或者SVN的使用背景，那么更熟悉的方法是客户端-服务器端模式，所有的文件仓库(repository)都是存放在服务器上的，用户需要在本地安装客户端去服务器上的项目中获取旧版本，提交新版本。GIT抛弃了这种模式，当用户从远端GIT仓库下载一个工程(project)时，这个工程的所有文件，包括版本历史，文件改动都会下载下来，这时 候本地GIT就演变成了一个服务器，所有的提交(check-in)、提出(check-out)都会在这个本地服务器上执行，当你确定一项修改之后，可 以再和远端仓库进行合并和同步(merge)。所以，GIT的安装和配置步骤无论在本机还是服务器上都是完全一样的。 2. 使用GIT的好处 更顺畅的工作流程，开发过程中，完全可以离线操作 快速，Git分布式架构使得本地仓库包含所有的历史版本信息，你可以在不同的版之间快速切换 弹性的本地分支，在svn下，你建一个分支需要把源代码复制到另外一个文件夹，而在Git下，创建分支的代价是非常小的，只需一条命令 仓库目录结构简洁，用Git复制一个项目，只会在项目根目录创建一个.git的目录，而其他目录很干净 内容按原数据方式存储，所有的版本信息都位于.git目录下 完整性好，更易于协作开发 用户群大，现在已经有成千上万个开源项目采用Git来做项目管理，github上更是有无数个代码仓库 参考链接： http://blog.csdn.net/fyx708711/article/details/52606252 3. GIT 安装 https://git-scm.com/book/zh/v2/起步-安装-Git # centos7.2 linnux sudo yum update sudo yum install -y git # ubuntu 安装 # http://www.linuxidc.com/Linux/2016-09/135527.htm sudo apt-get install git # Mac OS 需要事先安装了homebrew ~ brew install git # windows 下 # 下载客户端安装： https://git-for-windows.github.io/ # 安装教程 # https://jingyan.baidu.com/article/20095761b48041cb0721b4fc.html 4. GIT 配置 4.1 GIT 初始化设置、命令别名设置 这里是为了在频繁git操作的时候，命令简化。 # linux, Mac OS, window 都适用 # https://git-scm.com/book/zh/v2/起步-初次运行-Git-前的配置 # https://git-scm.com/book/zh/v2/自定义-Git-配置-Git git config --global user.name \"you name\" # 设置GIT的用户名 git config --global user.email you_email_addr@gmail.com # 设置GIT的邮箱 git config --global core.mergeoptions --no-edit # 关闭git pull产生的merge信息 git config --global commit.template ~/.gitmessage.txt # git 提交时编辑里面的模板 # false：关闭， auto：自动，有的颜色会忽略， always：忽略掉管道和终端的不同，即在任何情况下着色输出 git config --global color.ui false # 终端内容着色 git config --list # 查看上面的配置 // 必要的配置 git config --global core.editor vim # 使用VIM编辑器编辑作为GIT的默认编辑器 git config --global credential.helper store # 存储credential(凭证)，自动保存远程仓库账号密码 // https://git-scm.com/book/zh/v2/Git-工具-凭证存储 git config --global core.quotepath false # 关闭对0x80以上的字符进行quote， 解决git的中文乱码问题。 git config --global core.autocrlf true # 自动转换LF和CRLF(不同操作系统换行不同问题)。 git config core.ignorecase false # 设置git识别大小写 // git命令使用别名简化 git config --global alias.co checkout # GIT命令别名 方便操作快捷 git config --global alias.ci commit # GIT命令别名 方便操作快捷 git config --global alias.st status # GIT命令别名 方便操作快捷 git config --global alias.br branch # GIT命令别名 方便操作快捷 git config --global alias.hist 'log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short' git config --global alias.type 'cat-file -t' # GIT命令别名 方便操作快捷 git config --global alias.dump 'cat-file -p' # GIT命令别名 方便操作快捷 # 查看git路径 which git 4.2 如果终端安装了oh-my-zsh，会带一堆git命令别名 Mac 用户和 Linux 用户通过在您的终端中运行以下命令来安装oh-my-zsh： sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" oh-my-zsh带的git命令别名： g - git gst - git status gl - git pull gup - git pull --rebase gp - git push gd - git diff gdc - git diff --cached gdv - git diff -w \"$@\" | view gc - git commit -v gc! - git commit -v --amend gca - git commit -v -a gca! - git commit -v -a --amend gcmsg - git commit -m gco - git checkout gcm - git checkout master gr - git remote grv - git remote -v grmv - git remote rename grrm - git remote remove gsetr - git remote set-url grup - git remote update grbi - git rebase -i grbc - git rebase --continue grba - git rebase --abort gb - git branch gba - git branch -a gcount - git shortlog -sn gcl - git config --list gcp - git cherry-pick glg - git log --stat --max-count=10 glgg - git log --graph --max-count=10 glgga - git log --graph --decorate --all glo - git log --oneline --decorate --color glog - git log --oneline --decorate --color --graph gss - git status -s ga - git add gm - git merge grh - git reset HEAD grhh - git reset HEAD --hard gclean - git reset --hard && git clean -dfx gwc - git whatchanged -p --abbrev-commit --pretty=medium gsts - git stash show --text gsta - git stash gstp - git stash pop gstd - git stash drop ggpull - git pull origin $(current_branch) ggpur - git pull --rebase origin $(current_branch) ggpush - git push origin $(current_branch) ggpnp - git pull origin $(current_branch) && git push origin $(current_branch) glp - _git_log_prettily 参考资料： https://segmentfault.com/a/1190000007145316 https://www.hinjin.com/2018/04/13/%E5%A6%82%E4%BD%95%E5%8A%A0%E5%BF%AB%E4%BD%A0%E7%9A%84git%E6%93%8D%E4%BD%9C%EF%BC%9F/ 4.3 GIT配置文件介绍 Linux，Mac OS Git 使用一系列配置文件来保存你自定义的行为。它首先会查找 /etc/gitconfig 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 --system 选项给 git config，它就会读写该文件。接下来 Git 会查找每个用户的 ~/.gitconfig 文件（或者 ~/.config/git/config 文件）。 你可以传递 --global 选项让 Git 读写该文件。最后 Git 会查找你正在操作的版本库所对应的 Git 目录下的配置文件（.git/config）。 这个文件中的值只对该版本库有效。以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 .git/config 中的值会覆盖掉 /etc/gitconfig 中所对应的值。 windows windows7系统： C:\\Documents and Settings\\用户名，其中有一个.gitconfig的文件。windows8系统： C盘 -> 用户(Users) -> 用户名 文件夹下，有个.gitconfig的文件。 在上述那个目录底下， 可发现另外一个文件.git-credentials，里面记录的就是用户名密码了。 5. git设置远程仓库账号密码(拉取、上传代码不用输入用户名密码) github Personal access tokens 使用token可以不需要密码就可以读取远程仓库代码，如果你的远程仓库网站提供了账户访问token，那么设置一个读取token，没有tokens的请忽略。 https://github.com/settings/tokens![WX20170421-105344.png](https://bitbucket.org/repo/oE6yEX/images/964748538-WX20170421-105344.png) git-credentials git读取账号密码文件 这里是为了你在拉取代码的时候不用在输入用户名密码了， 但是这里会暴露你远程仓库的用户名密码，注意保密，如果电脑不用了记得删除这个文件。 # 打开文件，如果没有则会自动创建文件 $ vim ~/.git-credentials # 编辑好文件后运行git命令来让文件生效 $ git config --global credential.helper store 里面文件内容： http://用户名:密码或token@仓库地址 http://yulilong:password@192.168.102.9 https://yulilong:password@bitbucket.org http://yulilong:password@bitbucket.org https://yulilong:5199818388420@github.com http://yulilong:github_Personal_access_tokens@github.com 6. git文件夹详解 探索.git目录 .git文件夹详解 Git 内部原理 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/git/002-git使用教程.html":{"url":"doc/git/002-git使用教程.html","title":"git使用教程","keywords":"","body":" 基础 一、电脑本地初始化一个仓库 1.1 git init: 初始化一个电脑上本地仓库 1.2 创建远程仓库： 存放代码 1.3 本地Git添加远程仓库地址 1.3.1 git remote add shortname url： 添加仓库 1.3.2 git remote -v：查看本地git的远程仓库地址 1.3.3 git remote show [remote-name] ：查看远程仓库详细信息 1.3.4 远程仓库的重命名、移除、修改地址 二、从远程仓库(服务器)获取代码 2.1 获取默认分之代码：git clone [URL] 2.1.1 拉取仓库时自定义本地仓库文件名： git clone [URL] [新名字] 2.2. 直接拉取特定分之的代码：git clone -b [分支名] [代码地址] 2.3 直接拉取特定标签(tag)的代码：git clone -b [标签名] [代码地址] 2.4 如果已经拉取了代码，还需要拉取其他分支代码：git checkout -b [分支名] [远程仓库名]/[分支名] 2.5 有多个远程仓库，拉取指定仓库：git pull 仓库名 分支名 三、记录每次更新到仓库 3.1 GIT中文件状态介绍(已跟踪/未跟踪) 3.2 已跟踪的两种状态 3.2.1 已暂存(Changes to be committed) 3.2.2 已修改(Changes not staged for commit) 3.2.3 未跟踪(Untracked files) 3.2 git status: 查看当前文件状态 3.3 git status -s紧凑格式输出 3.4 GIT代码管理：改变文件的状态 3.4.1 git add 3.4.2 git checkout -- file： 撤消对文件的修改 3.4.3 git reset HEAD file：取消暂存的文件 3.5 .gitignore：忽略文件，不纳入GIT版本控制 3.6 git diff: 查看代码修改详细内容 3.6.1 git diff： 查看尚未暂存的文件修改记录 3.6.2 git diff --staged： 查看以暂存文件修改记录 3.6.3 git diff 的其他用法: --stat HEAD SHA1 3.7 把代码纳入版本控制中： 提交更新 git commit 3.7.1 commit命令的其他的用法： -m选项，提交信息简写 3.7.2 commit命令的其他的用法： -a选项,提交所有修改过的文件（已暂存，已修改） 3.8 git push： 把本地的跟新推送到远程仓库服务器上 四、 查看提交历史: git log 4.1 git log 的常用选项: -stat, -p, --name-status, --pretty=oneline, --abbrev-commit 4.1.1 git log --stat:显示每次更新的文件修改统计信息(修改的文件名，每个文件添加的多少、删除了多少数字)。 4.1.2 git log --name-only: 只显示修改的文件名，没有其他信息 4.1.3 git log --pretty=oneline: 用一行显示信息 五、 打标签(一个版本发布) git tag 5.1 什么是标签？ 5.2 查看现有的标签 5.2.1 查看所有标签：git tag 5.2.2 查看符合条件的标签：git tag -l 'v1.*' 5.2.3 查看一个标签的详细信息：git tag show V1.4 5.3 创建标签：Git 使用两种主要类型的标签： 5.3.1 git tag -a:创建附注标签（annotated） 5.3.2 git tag V1.4: 创建轻量标签（lightweight） 5.3.3 git tag -a v1.2 9fceb02：对某个历史提交打标签(后期打标签) 5.4 把创建的标签推送到服务器上：git push origin [tagname] 5.5 检出标签: 代码变成标签的样子 5.6 删除标签 5.6.1 git tag -d v1.0:删除本地标签 5.6.2 git push origin :refs/tags/v0.1:删除服务器标签 六、 GIT分支 6.1 分支介绍作用 6.2 本地分支的创建、切换、删除： 6.2.1 创建分支：git branch testing` 6.2.2 切换分支：git checkout testing 6.2.3 创建并且换：git checkout -b testing 6.2.4 删除分支：git branch -d testing 6.3 远程仓库分支的新建与删除 6.3.1 远程仓库分支的新建： git push origin testing 6.3.2 删除远程仓库的无用分支：git push origin --delete testing 6.4 分支合并：git merge 6.4.1 合并命令：git merge [分支名] 6.4.2 合并很完美，直接合并成功的提示 6.4.3 合并过程中代码有冲突，解决冲突 6.4.4 取消合并 GIT的高级用法（平时用的很少，了解就好） 八、GIT工具： 储藏与清理 8.1 git stash : 修改的代码暂存起来，把工作目录变干净，方便切换分支等做一些其他事情 8.1.1 把代码储藏起来： git stash 8.1.2 查看储藏的代码： git stash list 8.1.3 把储藏的代码取出来： git stash apply 8.1.4 git stash apply --index 8.1.5 删除储藏堆栈上的某个储藏：git stash drop stash@{0} 8.1.6 应用储藏然后立即从栈上扔掉它：git stash pop 8.1.7 git stash --keep-index: 不要储藏任何你通过 git add 命令已暂存的东西 8.1.8 git stash -u: 把任何创建的未跟踪文件也储藏 8.1.9 从储藏创建一个分支:解决应用储藏冲突问题 8.2 清理工作目录 8.2.1 git clean -f -d:移除工作目录中所有未追踪的文件以及空的子目录 8.2.2 git clean -f -d -n: 做一次演习然后告诉你 将要 移除什么 8.2.3 git clean -f -d -x: 移除.gitiignore文件中忽略的文件 九、重写历史：git 提交历史修改 9.1 修改最后一次提交 9.1.1 只是修改最后一次提交的提交信息：git commit --amend 9.1.2 修改最后一次提交的快照：git add或git rm然后git commit --amend 9.1.3 把修改的最后一次提交信息强推到服务器：git push --f 9.1.4 gitlab服务器强推被拒绝： 仓库 - 设置 - 保护分支： 把被保护的分支去掉即可解决问题 9.2 使用git rebase合并多次commit 9.3 把一个文件从提交历史中彻底删除：git filter-branch --tree-filter 'rm -f 1.txt' HEAD 9.3.1 如果后悔删除了，可使用如下命令恢复：git reset --hard refs/original/refs/heads/[分支名] 9.3.2 把删除后的项目提交到服务器：git push origin +[分支名], 注意：一旦运行此命令，删除的文件不能找回 9.3.3 删除一堆类似文件：git filter-branch --tree-filter \"find * -type f -name '*~' -delete\" HEAD 9.4 全局性地更换电子邮件地址 十、GIT的工作原理 10.1 HEAD 10.2 index 10.3 Working Directory 10.4 工作流程 十一、git重置git reset，代码回退操作介绍 11.1 只移动HEAD(相当于取消上一次提交)：git reset --soft HEAD~或 git reset --soft 99ad0ec 11.2 移动HEAD，更新index： git reset HEAD~ 或git reset --mixed HEAD~ 11.3 移动HEAD，更新index,更新工作目录（working Directory）: git reset --hard HEAD~ 11.4 使用git reflog命令来查看所有已经提交过的commit 11.5 通过路径来重置：git reset file.txt 十二、 git checkout 介绍 12.1 切换分支：git checkout [分支名] 12.2 放弃index与working Directory的改动：git checkout [分支名] file.txt 12.3 值放弃修改working Directory 工作目录中的修改：git checkout file.txt放弃单个修改或使用git checkout .放弃所有修改 常用命令 13. git 一些查看命令 14. 获取Git仓库 15. git tag — 标签相关操作 16. 代码存储，代码修改记录:git stash, git diff tmp.patch 17. 分支管理 18. git 回滚到某个commit 19. git 查看改动 20. git恢复删除的文件 21. \"git rm\" 和 \"rm\" 的区别 22. 关闭git pull产生的merge 信息 22.1 git pull 产生merge信息的原因 22.2 解决 23. git pull文件时和本地文件冲突 24. git删除远程仓库的一次commit提交 [TOC] 参考资料： 廖雪峰git教程 基础 一、电脑本地初始化一个仓库 1.1 git init: 初始化一个电脑上本地仓库 终端进入项目目录，输入： $ git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。详细介绍； https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 1.2 创建远程仓库： 存放代码 目前我知道的git网站仓库： 码云:https://gitee.com/共有仓库、私有仓库都免费使用， 国内访问速度快。 github:https://github.com/共有仓库免费使用， 私有仓库收费， 有时候访问速度慢。 Bitbucket:https://bitbucket.org/共有仓库、私有仓库都免费使用， 但是免费的最多只能有5个用户对仓库进行读写，超过的就需要付费。访问速度有时很慢。 gitlab:公司自建的git服务器，随意使用。 创建仓库都差不多，在网站中点击新建仓库，然后选择仓库的类型(公有、私有)，然后点击创建即可。 1.3 本地Git添加远程仓库地址 1.3.1 git remote add ： 添加仓库 本地git初始化后，此时还没有添加远程仓库地址，需要添加一个远程仓库地址才能上传代码到服务器。可在终端中运行git remote add 添加一个新的远程 Git 仓库。shortname是url的简写，当上传代码的时候，可用这个简写代替url地址。命令详细介绍：https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用 $ git remote add pb https://github.com/paulboone/ticgit 1.3.2 git remote -v：查看本地git的远程仓库地址 当添加好远程仓库后，可以使用命令来查看添加的仓库是否正确。 # 列出你指定的每一个远程服务器的简写 $ git remote origin # 指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。 $ git remote -v origin https://github.com/schacon/ticgit (fetch) origin https://github.com/schacon/ticgit (push) 1.3.3 git remote show [remote-name] ：查看远程仓库详细信息 如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息： $ git remote show origin * remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked dev-branch tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 1.3.4 远程仓库的重命名、移除、修改地址 如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做： $ git remote rename pb paul $ git remote origin paul 这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。 如果因为一些原因想要移除一个远程仓库 - 可以使用 git remote rm ： $ git remote rm paul $ git remote origin 修改地址： git remote set-url origin www.baidu.com 关于远程仓库详细介绍 二、从远程仓库(服务器)获取代码 2.1 获取默认分之代码：git clone [URL] 如果本地没有代码，远程仓库有代码，则需要从远程仓库克隆代码。 克隆仓库的命令格式是 git clone [url] 。 比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令： $ git clone https://github.com/libgit2/libgit2 这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 2.1.1 拉取仓库时自定义本地仓库文件名： git clone [URL] [新名字] 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令： $ git clone https://github.com/libgit2/libgit2 mylibgit 这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 mylibgit。 关于克隆远程仓库命令详细介绍：https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 2.2. 直接拉取特定分之的代码：git clone -b [分支名] [代码地址] 如果不想克隆默认分之的代码， 也可以克隆特定分之的代码： $ git clone http://192.168.102.9/jas-paas/cloudlink-front-framework.git Cloning into 'cloudlink-front-framework'... remote: Counting objects: 14436, done. remote: Compressing objects: 100% (3072/3072), done. remote: Total 14436 (delta 11224), reused 14226 (delta 11075) Receiving objects: 100% (14436/14436), 17.93 MiB | 4.98 MiB/s, done. Resolving deltas: 100% (11224/11224), done. 2.3 直接拉取特定标签(tag)的代码：git clone -b [标签名] [代码地址] git允许直接克隆特定分之的代码，不过克隆好后，项目里没有分之，需要自己创建一个分支： $ git clone -b V2.2 http://192.168.102.9/jas-paas/cloudlink-front-framework.git Cloning into 'cloudlink-front-framework'... remote: Counting objects: 14436, done. remote: Compressing objects: 100% (3072/3072), done. remote: Total 14436 (delta 11224), reused 14226 (delta 11075) Receiving objects: 100% (14436/14436), 17.93 MiB | 4.70 MiB/s, done. Resolving deltas: 100% (11224/11224), done. Note: checking out 'eeea534cdae1f82c48c7b0de8f9993b54ffa065d'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b 从信息中就可以看见，克隆特定标签的项目后，是没有分之的，需要进入项目目录后，使用命令创建一个分支： $ git checkout -b V2.2 2.4 如果已经拉取了代码，还需要拉取其他分支代码：git checkout -b [分支名] [远程仓库名]/[分支名] 例如，本地就一个master分支，远程有2个分支(master,develop)，把远程的develop拉取到本地： # 本地的分支是干净的，也就是没有修改的文件 # 获取远程所有分支名字 ~ git fetch # 显示远程所有分支名字 ~ git branch -a # 提取远程新分支到本地 ~ git checkout -b develop origin/develop 2.5 有多个远程仓库，拉取指定仓库：git pull 仓库名 分支名 比如 远程仓库有2个： origin、github，默认残酷史origin，如果想要来去github仓库的代码： ~ git pull github master 三、记录每次更新到仓库 3.1 GIT中文件状态介绍(已跟踪/未跟踪) 工作目录下每个文件只有两种状态： 3.2 已跟踪的两种状态 指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。git会自动管理已跟踪的文件，记录文件处于什么状态中。 3.2.1 已暂存(Changes to be committed) 文件在这个状态下的，说明已经准备好把文件提交了，可以把这次代码变动记录保存在历史记录中。这个状态为GIT可以提交的内容。 3.2.2 已修改(Changes not staged for commit) 这状态下的文件， git只是知道修改了那些内容，但是并不会在提交代码的时候把这部分内容提交上去。如果需要提交这部分代码需要使用命令git add 把文件添加到 已暂存中，然后提交代码。 3.2.3 未跟踪(Untracked files) 工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。git不会去管理这些文件。 3.2 git status: 查看当前文件状态 使用git status命令可以查看文件处于什么状态，例如： $ git status On branch P02 // 告诉你当前是哪个分之下 Your branch is up-to-date with 'origin/P02'. // 当前分之是从哪个仓库更新的 Changes to be committed: // 已暂存状态 (use \"git reset HEAD ...\" to unstage) // 使用这个命令可回退到Changes not staged for commit: modified: fileName.ts Changes not staged for commit: // 已跟踪文件的内容发生了变化 (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: // 未跟踪的文件 (use \"git add ...\" to include in what will be committed) src/library/ 在git status命令输出的信息中： Changes to be committed:已暂存状态如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 Changes not staged for commit:已跟踪文件的内容发生了变化，但还没有放到暂存区。 Untracked files:未跟踪的文件，意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 3.3 git status -s紧凑格式输出 使用git status -s命令或git status --short命令，你将得到一种更为紧凑的格式输出。 $ git status -s M README // 出现在右边的 M 表示该文件被修改了但是还没放入暂存区 MM Rakefile // 文件已经放入暂存区，但是又修改过了，在已修改中也存在 A lib/git.rb // 新添加到暂存区中的文件前面有 A 标记 M lib/simplegit.rb // 出现在靠左边的 M 表示该文件被修改了并放入了暂存区 ?? LICENSE.txt // 新添加的未跟踪文件前面有 ?? 标记 3.4 GIT代码管理：改变文件的状态 3.4.1 git add git add命令是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。例子：src/test.txt文件是一个未跟踪文件，可使用git add命令开始跟踪： $ git add src/test.txt //指定单个文件添加 $ git add src/* //指定src目录下所有文件都添加 3.4.2 git checkout -- ： 撤消对文件的修改 如果你并不想保留对 CONTRIBUTING.md 文件的修改,将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）可使用如下命令： git checkout -- CONTRIBUTING.md 注：你需要知道 git checkout -- [file] 是一个危险的命令，这很重要。你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了，否则不要使用这个命令。 3.4.3 git reset HEAD ：取消暂存的文件 如果你在提交代码的时候，不想提交一些文件，可使用该命令把文件从暂存中回退到已修改的文件中。 git reset HEAD CONTRIBUTING.md 关于撤销操作的详细介绍： https://git-scm.com/book/zh/v2/Git-基础-撤消操作 3.5 .gitignore：忽略文件，不纳入GIT版本控制 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以在项目根目录创建一个名为 .gitignore 的文件，列出要忽略的文件模式。 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 一个 .gitignore 文件的例子： # 忽略所有后缀为 .a 的文件 *.a # 但是要跟踪lib.a，即使你上面忽略了 .a文件 !lib.a # 仅忽略当前目录的TODO文件夹， 不是subdir/TODO /TODO # 忽略build /目录中的所有文件 build/ # 忽略doc / notes.txt，而不是doc / server / arch.txt doc/*.txt # 忽略doc 目录中的所有.pdf文件 doc/**/*.pdf GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表:https://github.com/github/gitignore 这部分详细介绍： https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库 3.6 git diff: 查看代码修改详细内容 如果你想知道文件具体修改了什么，可以用git diff命令。 3.6.1 git diff： 查看尚未暂存的文件修改记录 git diff命令查看修改之后还没有暂存起来的变化内容。也就是git status命令输出信息中，Changes not staged for commit:下面的文件， 例如： $ git diff //查看所有详细修改 $ git diff 1.txt //只查看 1.txt文件的 详细修改 //输出信息如下 diff --git a/.gitignore b/.gitignore //① index e722882..f98470c 100644 //② --- a/.gitignore //③ +++ b/.gitignore //③ @@ -3,8 +3,8 @@ //④ *~ *.sw[mnpcod] -.DS_Store //⑤ *.log //⑥ +text.t //⑦ *.tmp *.tmp.* log.txt ① git格式的diff,进行比较的是，a版本的.gitignore（即变动前）和b版本的.gitignore（即变动后）。② 表示两个版本的git哈希值（index区域的e722882对象，与工作目录区域的f98470c对象进行比较）， 最后的六位数字是对象的模式（普通文件，644权限）。③ 表示进行比较的两个文件。 \"---\"表示变动前的版本，\"+++\"表示变动后的版本。④ 下面代码所在的行： -3,7： 修改前下面信息变化的行， 从第3行开始一直到第7行 +3,6： 修改后下面信息变化的行， 从第3行开始一直到第6行⑤ 以- 开头表示删除的代码⑥ 以空格开头表示没有修改 ⑦ 以+开头便是增加的代码 git diff输出结果介绍 3.6.2 git diff --staged： 查看以暂存文件修改记录 查看已暂存的将要添加到下次提交里的内容可是使用命令git diff --staged(GIT版本1.6.1以上)。 也可以使用git diff --cached命令。 git diff --staged // 查看所有已暂存文件的修改记录 git diff --staged t.txt // 只查看1.txt文件 已暂存的修改记录 3.6.3 git diff 的其他用法: --stat HEAD SHA1 ~ git diff --stat // 查看简单的diff结果，只查看修改的文件名、修改了多少内容 ~ git diff HEAD // 查看所有修改记录(已暂存、已修改)：显示工作版本(Working tree)和HEAD的差别 ~ git diff topic master // 直接将两个分支上最新的提交做diff ~ git diff HEAD^ HEAD // 比较上次提交commit和上上次提交 ~ git diff SHA1 SHA2 // 比较两个历史版本之间的差异 3.7 把代码纳入版本控制中： 提交更新 git commit 当所有需要提交的代码都放到暂存区后，就可以提交代码了： $ git commit 这种方式会启动文本编辑器以便输入本次提交的说明。一般都是 vim 或 emacs。使用 git config --global core.editor 命令设定你喜欢的编辑软件。编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）： // # Please enter the commit message for your changes. Lines starting // # with '#' will be ignored, and an empty message aborts the commit. // # On branch master // # Changes to be committed: // # new file: README // # modified: CONTRIBUTING.md // # // ~ // ~ // \".git/COMMIT_EDITMSG\" 9L, 283C 可以在这段文本信息中看见， 所有以#符号开头的行，都会被忽略，也就是#是注释行，不会放到提交信息中去。接下来就可以输入一些提交信息了，关于写提交信息的建议： 信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比 - 这是一个值得遵循的好规则。 提交信息简单的模板： 修改的摘要（50 个字符或更少） 如果必要的话，加入更详细的解释文字。在 大概 72 个字符的时候换行。在某些情形下， 第一行被当作一封电子邮件的标题，剩下的 文本作为正文。分隔摘要与正文的空行是 必须的（除非你完全省略正文）；如果你将 两者混在一起，那么类似变基等工具无法 正常工作。 3.7.1 commit命令的其他的用法： -m选项，提交信息简写 在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行，如下所示： $ git ci -m \"测试提交\" [master f949399] 测试提交 1 file changed, 1 insertion(+) 从输出的信息中可以看见：当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（f949399），以及在本次提交中，有多少文件修订过，多少行添加和删改过。 注意：提交时记录的是放在暂存区域的快照。 任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 3.7.2 commit命令的其他的用法： -a选项,提交所有修改过的文件（已暂存，已修改） 有时候把修改的提交到暂存区，然后在提交代码比较繁琐， GIT提供了一种-a选项，在提交代码的时候，跳过暂存区，把所有已经跟踪的文件暂存起来一并提交，从而跳过git add步骤，例如： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: CONTRIBUTING.md no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git commit -a -m 'added new benchmarks' [master 83e38c7] added new benchmarks 1 file changed, 5 insertions(+), 0 deletions(-) 从输出信息中可以看到：提交之前不再需要 git add 文件“CONTRIBUTING.md”了。 关于git commit命令详解：https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库 3.8 git push： 把本地的跟新推送到远程仓库服务器上 当在本地开发完毕，需要把代码提交到服务器时，可使用it push [remote-name] [branch-name]命令。你想要将 master 分支推送到 origin 服务器时： $ git push origin master // 把更新上传到 origin服务器的 master分之上。 $ git push // 上传本地所有分支代码到远程对应的分支上 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 四、 查看提交历史: git log 在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令： $ git log commit ca82a6dff817ec66f44342007202690a93763949 // 提交的 SHA-1 校验和 Author: Scott Chacon // 作者的名字和电子邮件地址 Date: Mon Mar 17 21:52:11 2008 -0700 // 提交时间 changed the version number // 提交说明 commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 Author: Scott Chacon Date: Sat Mar 15 16:40:33 2008 -0700 removed unnecessary test 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。 4.1 git log 的常用选项: -stat, -p, --name-status, --pretty=oneline, --abbrev-commit 4.1.1 git log --stat:显示每次更新的文件修改统计信息(修改的文件名，每个文件添加的多少、删除了多少数字)。 4.1.2 git log --name-only: 只显示修改的文件名，没有其他信息 4.1.3 git log --pretty=oneline: 用一行显示信息 $ git log 1.txt //查看 1.txt文件的历史修改记录。 $ git log -n //只查看前n次修改记录，例如查看前2次的记录： git log -2 $ git log -p // 按补丁格式显示每个更新之间的差异。 $ git log --shortstat // 只显示 --stat 中最后的行数修改添加移除统计。 $ git log --name-status // 显示新增、修改、删除的文件清单。 $ git log --abbrev-commit // 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。 $ git log --relative-date // 使用较短的相对时间显示（比如，“2 weeks ago”）。 $ git log --graph // 显示 分支合并历史。 $ git log --pretty=oneline // 用一行显示信息 // 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。 关于git log命令详解 五、 打标签(一个版本发布) git tag 像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布版本节点（v1.0 等等）。 5.1 什么是标签？ 标签可以认为是版本管理工具的一个版本，也就是说像很多第三方开源软件安装包表示的版本号，比如说1.0,2.0等等，它代表修复了一个bug,或者重大的重构，git的标签也是这样的一个作用，可以对版本的不同阶段做一个标示。 5.2 查看现有的标签 5.2.1 查看所有标签：git tag $ git tag v0.1 v1.3 v1.4 这个命令以字母顺序列出标签；但是它们出现的顺序并不重要。 5.2.2 查看符合条件的标签：git tag -l 'v1.*' 也可以使用特定的模式查找标签, 如果只对 1.0以上tag感兴趣，可以运行： $ git tag -l 'v1.*' 5.2.3 查看一个标签的详细信息：git tag show V1.4 该命令会输出打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 5.3 创建标签：Git 使用两种主要类型的标签： 5.3.1 git tag -a:创建附注标签（annotated） 附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。 通常建议创建附注标签，这样你可以拥有以上所有信息。 创建一个附注标签，使用tag命令时指定-a选项： $ git tag -a v1.4 -m 'my version 1.4' -m选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会运行编辑器要求你输入信息。 如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的-a改为-s（取 signed 的首字母）即可： git tag -s v1.5 -m 'my signed 1.5 tag' 再运行 git show 会看到对应的 GPG 签名也附在其内. 5.3.2 git tag V1.4: 创建轻量标签（lightweight） 如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，则可以选择使用轻量标签。轻量标签本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息。创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字： $ git tag v1.4-lw 5.3.3 git tag -a v1.2 9fceb02：对某个历史提交打标签(后期打标签) 如果你在项目版本发布的时候忙忘记打标签，你可以在之后补上标签。要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）: git tag -a v1.2 9fceb02 5.4 把创建的标签推送到服务器上：git push origin [tagname] 默认情况下，git push命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 $ git push origin v1.5 Counting objects: 14, done. Delta compression using up to 8 threads. Compressing objects: 100% (12/12), done. Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done. Total 14 (delta 3), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.5 -> v1.5 如果想要一次性推送很多标签，也可以使用带有--tags选项的git push命令。这将会把所有不在远程仓库服务器上的标签全部传送到服务器。 $ git push origin --tags Counting objects: 1, done. Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done. Total 1 (delta 0), reused 0 (delta 0) To git@github.com:schacon/simplegit.git * [new tag] v1.4 -> v1.4 * [new tag] v1.4-lw -> v1.4-lw 现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。 5.5 检出标签: 代码变成标签的样子 在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定的标签版本完全一样，可以使用git checkout -b [branchname] [tagname]在特定的标签上创建一个新分支： $ git checkout -b version2 v2.0.0 Switched to a new branch 'version2' 5.6 删除标签 5.6.1 git tag -d v1.0:删除本地标签 $ git tag -d v1.0 Deleted tag 'v1.0' (was 2ffea56) 5.6.2 git push origin :refs/tags/v0.1:删除服务器标签 推送一个空tag到远程tag，就可以删除同名的tag： $ git push origin :refs/tags/v0.1 To http://192.168.95.95/user/test.git - [deleted] v0.1 如果服务器的标签删除后，本地的也需要自己删除。 或者使用这种形式： git push origin --delete tag 关于git tag详解 六、 GIT分支 6.1 分支介绍作用 Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 它会在每次的提交操作中自动向前移动。 分支作用： 开发多个项目任务，比如说我有两个任务都比较紧急，任务1需要两天完成，任务2需要一天完成，而任务1是之前就已经开始进行的，任务二是中间加的新任务，所以需要第一天就完成任务2. master分支始终要保证可发布的状态，用dev分支和bug分支进行开发和错误调试，这样能够保证主干代码的干净、可发布。 自己开发测试或者修复BUG等等，可以避免代码的丢失。 6.2 本地分支的创建、切换、删除： 6.2.1 创建分支：git branch testing` 比如，创建一个 testing 分支， 你需要使用 git branch 命令： $ git branch testing 这条命令会根据当前的分支来创建一个新分支，分支中内容与当前分支内容完全一样。git branch命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。 6.2.2 切换分支：git checkout testing 要切换到一个已存在的分支，你需要使用git checkout命令。 我们现在切换到新创建的 testing 分支去： $ git checkout testing 6.2.3 创建并且换：git checkout -b testing $ git checkout -b testing Switched to a new branch \"testing\" 这个命令会创建一个分支并切换到新分支中去， 实际上他是上面2条命令的简化版。 6.2.4 删除分支：git branch -d testing 删除一个分支的时候，你不能在要删除的分支中，要切换到别的分支中，否则会报错。如果要删除 testing分支，可以使用带 -d 选项的 git branch 命令来删除分支： $ git br -d testing Deleted branch testing (was 4baf2a3). 6.3 远程仓库分支的新建与删除 6.3.1 远程仓库分支的新建： git push origin testing 如果想把本地的新分支推送到远程仓库，可使用 git push [远程仓库名] [分支名]： $ git br -a testing * master remotes/origin/master $ git push origin testing Total 0 (delta 0), reused 0 (delta 0) To http://192.168.132.55/user/test.git * [new branch] testing -> testing 6.3.2 删除远程仓库的无用分支：git push origin --delete testing 如果远程仓库某个分支无用了，想要删除，可以运行带有 --delete 选项的 git push 命令来删除一个远程分支： git push origin --delete testing To http://192.168.132.55/user/test.git - [deleted] testing 6.4 分支合并：git merge 如果一个分支的功能开发完毕了，需要把开发的内容合并的其他分支中去，则需要使用 git的 merge命令。例如， 现在有2个分支(master, ningning), master分支的代码要合并到ningning,2个分支代码都已经git commit过了。如果没有commit，需要先commit，否则不能合并代码。 6.4.1 合并命令：git merge [分支名] // 切换到需要添加新功能的分支上 $ git checkout ningning // 把 master分支上的代码合并到ningning分支上 $ git merge master 6.4.2 合并很完美，直接合并成功的提示 如果合并成功了则输出的信息类似于下面： $ git merge master Updating f42c576..3a0874c Fast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) // 或者下面的输出信息 Merge made by the 'recursive' strategy. index.html | 1 + 1 file changed, 1 insertion(+) Git 将合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 6.4.3 合并过程中代码有冲突，解决冲突 ![WX20170420-172823.png](https://bitbucket.org/repo/oE6yEX/images/3353411608-WX20170420-172823.png) 错误信息类似于： Auto-merging index.html CONFLICT (content): Merge conflict in index.html Automatic merge failed; fix conflicts and then commit the result. Auto-merging是指已经自动合并的文件， CONFLICT (content)是指有冲突的文件，需要解决冲突的文件。 打开有冲突的文件，冲突部分代码类似于下面： contact : email.support@github.com ======= please contact us at support@github.com >>>>>>> master ======= >>>>>> 中的是 master分支的代码。经过对比后删除冲突部分的代码， 并把 >>> 所在行全部删除。保存后，使用git add添加修改的文件。使用git commit命令来完成合并提交：![WX20170421-144406.png](https://bitbucket.org/repo/oE6yEX/images/913542449-WX20170421-144406.png)![WX20170421-173612.png](https://bitbucket.org/repo/oE6yEX/images/1127660136-WX20170421-173612.png) 解决冲突文件：git checkout --ours/--theirs放弃其中一个分支的冲突代码 如果想放弃一个分支文件的冲突代码，只保留一个分支的代码，可使用如下命令。 假如：冲突文件名为 1.txt，要放弃master分支的修改，可使用如下命令： $ git checkout --ours 1.txt 放弃ningning分支冲突代码，可使用如下命令： $ git checkout --theirs 1.txt 6.4.4 取消合并 冲突太多，解决冲突乱了， 可取消合并：git reset --hard HEAD 如果冲突代码太多了，解决冲突代码过程中产生了混乱，想要重新合并，可使用下面命令取消这次合并： git reset --hard HEAD HEAD is now at 9e791f3 提交信息 合并已经commit，还没上传远程仓库，取消合并：git reset --hard HEAD^ 如果合并的代码产生了错误，或者合并有问题，但是已经commit了，但是还没有把合并提交到远程仓库，则可以使用如下命令取消这次合并： $ git reset --hard HEAD^ GIT的高级用法（平时用的很少，了解就好） 八、GIT工具： 储藏与清理 8.1 git stash : 修改的代码暂存起来，把工作目录变干净，方便切换分支等做一些其他事情 当你的工作已经做了一段时间后，所开发的功能还没有完成， 而这时候你想要切换分支做一点别的事情。但你又不想应为过一会就回到这一点而为做了一半工作就创建一次提交，这个时候你就可以使用git stash命令。git stash命令会处理工作目录的脏的状态，即修改的跟踪文件与暂存的改动。然后将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动。 8.1.1 把代码储藏起来： git stash $ git status Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: index.html Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: lib/simplegit.rb //储藏代码 $ git stash Saved working directory and index state \\ \"WIP on master: 049d078 added the index file\" HEAD is now at 049d078 added the index file (To restore them type \"git stash apply\") $ git status # On branch master nothing to commit, working directory clean 上面使用了git stash 储藏了代码，这时候在看工作目录就变成干净了，这个时候你就可以做别的事情了。 还可以使用git stash save命令，与 git stash 是一样的。 8.1.2 查看储藏的代码： git stash list 要查看储藏的东西，可以使用git stash list命令： $ git stash list stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \"added file_size\" stash@{2}: WIP on master: 21d80a5 added number to log 最新的是stash@{0} 8.1.3 把储藏的代码取出来： git stash apply 如果想把储藏的代码应用回来，可使用git stash apply命令，如果不指定一个储藏，Git 认为指定的是最近的储藏。如果想要应用其中一个更旧的储藏，可以通过名字指定它，像这样：git stash apply stash@{2}。 $ git stash apply --index // # On branch master // # Changed but not updated: // # (use \"git add ...\" to update what will be committed) // # // # modified: index.html // # modified: lib/simplegit.rb // # 8.1.4 git stash apply --index 文件的改动被重新应用了,但是之前已修改未暂存的文件却没有回到原来的位置，想要完全回到之前的样子，必须使用--index选项来运行git stash apply命令，来尝试重新应用暂存的修改。如果已经那样做了，那么你将回到原来的位置： $ git stash apply --index // # On branch master // # Changes to be committed: // # (use \"git reset HEAD ...\" to unstage) // # // # modified: index.html // # // # Changed but not updated: // # (use \"git add ...\" to update what will be committed) // # // # modified: lib/simplegit.rb // # 8.1.5 删除储藏堆栈上的某个储藏：git stash drop stash@{0} 使用git stash apply 命令只会尝试应用暂存的工作 ，在堆栈上还有它。可以运行git stash drop加上将要移除的储藏的名字来移除它： $ git stash list stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \"added file_size\" stash@{2}: WIP on master: 21d80a5 added number to log $ git stash drop stash@{0} Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43) 8.1.6 应用储藏然后立即从栈上扔掉它：git stash pop 这个命令只会应用最新的，然后丢掉它。 8.1.7 git stash --keep-index: 不要储藏任何你通过 git add 命令已暂存的东西 当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。 $ git status -s M index.html M lib/simplegit.rb $ git stash --keep-index Saved working directory and index state WIP on master: 1b65b17 added the index file HEAD is now at 1b65b17 added the index file $ git status -s M index.html 8.1.8 git stash -u: 把任何创建的未跟踪文件也储藏 默认情况下，git stash只会储藏已经在索引中的文件。如果指定 --include-untracked或-u标记，Git 也会储藏任何创建的未跟踪文件。 $ git status -s M index.html M lib/simplegit.rb ?? new-file.txt $ git stash -u Saved working directory and index state WIP on master: 1b65b17 added the index file HEAD is now at 1b65b17 added the index file $ git status -s $ 8.1.9 从储藏创建一个分支:解决应用储藏冲突问题 如果储藏了一些工作，将它留在那儿了一会儿，然后继续在储藏的分支上工作，在重新应用工作时可能会有问题。如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。如果想要一个轻松的方式来再次测试储藏的改动，可以运行git stash branch创建一个新分支，检出储藏工作时所在的提交，重新在那应用工作，然后在应用成功后扔掉储藏： $ git stash branch testchanges Switched to a new branch \"testchanges\" // # On branch testchanges // # Changes to be committed: // # (use \"git reset HEAD ...\" to unstage) // # // # modified: index.html // # // # Changed but not updated: // # (use \"git add ...\" to update what will be committed) // # // # modified: lib/simplegit.rb // # // Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359) 8.2 清理工作目录 有时候你想清除工作目录一些无用的文件，或是为了运行一个干净的构建而移除之前构建的残留。这个时候你可以使用git clean命令。 它被设计为从工作目录中移除未被追踪的文件。如果你改变主意了，你也不一定能找回来那些文件的内容。一个更安全的选项是运行 git stash --all 来移除每一样东西并存放在栈中。 8.2.1 git clean -f -d:移除工作目录中所有未追踪的文件以及空的子目录 -d 是 目录的意思。-f 意味着 强制 或 “确定移除”。 $ git clean -f -d Removing 5.txt Removing tttt/ 8.2.2 git clean -f -d -n: 做一次演习然后告诉你 将要 移除什么 8.2.3 git clean -f -d -x: 移除.gitiignore文件中忽略的文件 默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除。如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 .o 文件，可以给 clean 命令增加一个 -x 选项。 $ git status -s M lib/simplegit.rb ?? build.TMP ?? tmp/ $ git clean -n -d Would remove build.TMP Would remove tmp/ $ git clean -n -d -x Would remove build.TMP Would remove test.o Would remove tmp/ 九、重写历史：git 提交历史修改 9.1 修改最后一次提交 修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。对于你的最近一次提交，你往往想做两件事情：修改提交信息，或者修改你添加、修改和移除的文件的快照。 9.1.1 只是修改最后一次提交的提交信息：git commit --amend 如果只是想修改最后一次提交的提交信息，可以直接使用如下命令： $ git commit --amend [dev 3fa2e1a] 合并提交测试3号,测试修改最后一次提交。在测试一下。 Date: Thu Nov 2 11:29:00 2017 +0800 1 file changed, 1 insertion(+) create mode 100644 5.txt 这会把你带入文本编辑器，里面包含了你最近一条提交信息，供你修改。当保存并关闭编辑器后，编辑器将会用你输入的内容替换最近一条提交信息。 9.1.2 修改最后一次提交的快照：git add或git rm然后git commit --amend 如果你已经完成提交，又因为之前提交时忘记添加一个新创建的文件，想通过添加或修改文件来更改提交的快照，也可以通过类似的操作来完成。 通过修改文件然后运行git add或git rm一个已追踪的文件，随后运行git commit --amend拿走当前的暂存区域并使其做为新提交的快照。 使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。它类似于一个小的变基 - 如果已经推送了最后一次提交则需要慎重修改。 9.1.3 把修改的最后一次提交信息强推到服务器：git push --f 此操作要慎重，如果要修改服务器上的最后一次提交，可现在本地修改，然后使用git push --f(force)强推到服务器中去。 git push --force Counting objects: 3, done. Delta compression using up to 8 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 458 bytes | 458.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To http://192.168.102.9/yulilong/test.git + 5c0a032...3fa2e1a dev -> dev (forced update) 9.1.4 gitlab服务器强推被拒绝： 仓库 -> 设置 -> 保护分支： 把被保护的分支去掉即可解决问题 9.2 使用git rebase合并多次commit 使用git log 查看一下历史： $ git log commit 3fa2e1a951ff823fbec625a96049e27ef35a85b8 (HEAD -> dev, origin/dev) Author: yulilong Date: Thu Nov 2 11:29:00 2017 +0800 合并提交测试3号,测试修改最后一次提交。在测试一下。 commit f526876def0b80676bfcf52937f78052e2d63955 Author: yulilong Date: Thu Nov 2 11:27:20 2017 +0800 合并提交测试2号 commit 4d2b6ce4d5154c0b739e552e679bb7f4ce05fb2c Author: yulilong Date: Thu Nov 2 11:25:59 2017 +0800 合并提交测试一号 commit 9e791f38f4d5f472a371a8c147f37670185582f8 Author: yulilong Date: Mon Oct 30 10:22:02 2017 +0800 这是dev分支上的合并提交测试 commit 4baf2a319c0de8f46630ba85db11cc4aebd1d2cd Author: yulilong Date: Fri Sep 29 10:20:08 2017 +0800 这是测试-a -m命令提交记录 如果想要合并最后三次的提交，可使用git rebase -i HEAD~3或git rebase -i 9e791f38f4d命令来压缩.该命令执行后，会弹出一个编辑窗口，3次提交的commit倒序排列，最上面的是最早的提交，最下面的是最近一次提交。 1 pick 4d2b6ce 合并提交测试一号 2 pick f526876 合并提交测试2号 3 pick 3fa2e1a 合并提交测试3号,测试修改最后一次提交。在测试一下。 4 5 # Rebase 9e791f3..3fa2e1a onto 9e791f3 (3 commands) 6 # 7 # Commands: 8 # p, pick = use commit 9 # r, reword = use commit, but edit the commit message 10 # e, edit = use commit, but stop for amending 11 # s, squash = use commit, but meld into previous commit 12 # f, fixup = like \"squash\", but discard this commit's log message 13 # x, exec = run command (the rest of the line) using shell 14 # d, drop = remove commit 15 # 16 # These lines can be re-ordered; they are executed from top to bottom. 17 # 18 # If you remove a line here THAT COMMIT WILL BE LOST. 19 # 20 # However, if you remove everything, the rebase will be aborted. 21 # 22 # Note that empty commits are commented out 修改第二行、第三行的第一个单词pick为squash(这些命令什么意思下面的注释有说明)。然后保存退出，git会压缩提交历史，如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。修改以后要记得敲下面的命令： $ git add . # git rebase --continue 如果你想放弃这次压缩的话，执行以下命令： $ git rebase --abort 如果没有冲突，或者冲突已经解决，则会出现如下的编辑窗口： 1 # This is a combination of 3 commits. 2 # This is the 1st commit message: 3 4 合并提交测试一号 5 6 # This is the commit message #2: 7 8 合并提交测试2号 9 10 # This is the commit message #3: 11 12 合并提交测试3号,测试修改最后一次提交。在测试一下。 13 14 # Please enter the commit message for your changes. Lines starting 15 # with '#' will be ignored, and an empty message aborts the commit. 16 # 17 # Date: Thu Nov 2 11:25:59 2017 +0800 18 # 19 # interactive rebase in progress; onto 9e791f3 20 # Last commands done (3 commands done): 21 # squash f526876 合并提交测试2号 22 # squash 3fa2e1a 合并提交测试3号,测试修改最后一次提交。在测试一下。 23 # No commands remaining. 24 # You are currently rebasing branch 'dev' on '9e791f3'. 25 # 26 # Changes to be committed: 27 # modified: 1.txt 28 # new file: 4.txt 29 # new file: 5.txt 编辑好合并的提交信息后保存，可看见如下输出信息： [detached HEAD 83d65c7] 三次合并提交的测试，成功了。 Date: Thu Nov 2 11:25:59 2017 +0800 3 files changed, 7 insertions(+) create mode 100644 4.txt create mode 100644 5.txt Successfully rebased and updated refs/heads/dev. 最后把合并的记录强推到服务器中去： git push -f Counting objects: 5, done. Delta compression using up to 8 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (5/5), 596 bytes | 596.00 KiB/s, done. Total 5 (delta 1), reused 0 (delta 0) To http://192.168.102.9/yulilong/test.git + 3fa2e1a...83d65c7 dev -> dev (forced update) 服务器合并提交前： 服务器合并后： 参考链接：http://blog.csdn.net/yangcs2009/article/details/47166361 9.3 把一个文件从提交历史中彻底删除：git filter-branch --tree-filter 'rm -f 1.txt' HEAD 有些人不经思考使用git add .，意外地提交了一个巨大的二进制文件，你想将它从所有地方删除。也许你不小心提交了一个包含密码的文件，而你想让你的项目开源。filter-branch大概会是你用来清理整个历史的工具。如果想要从整个历史总删除1.txt文件，你可以在filter-branch上使用--tree-filter选项： $ git filter-branch -f --tree-filter 'rm -f 1.txt' HEAD Rewrite 83d65c7b098e0ec1f14d9a332187632b49d2ad9f (5/5) (0 seconds passed, remaining 0 predicted) Ref 'refs/heads/dev' was rewritten 如果执行命令的时候提示如下错误，删除 .git/refs/original/ 目录,或使用-f命令强制覆盖： $ git filter-branch -f --tree-filter 'rm -f 1.txt' HEAD Cannot create a new backup. A previous backup already exists in refs/original/ Force overwriting the backup with -f git filter-branch -f --tree-filter 'rm -f 1.txt' HEAD Rewrite 83d65c7b098e0ec1f14d9a332187632b49d2ad9f (5/5) (0 seconds passed, remaining 0 predicted) Ref 'refs/heads/dev' was rewritten 9.3.1 如果后悔删除了，可使用如下命令恢复：git reset --hard refs/original/refs/heads/[分支名] $ git reset --hard refs/original/refs/heads/dev HEAD is now at 83d65c7 三次合并提交的测试，成功了。 9.3.2 把删除后的项目提交到服务器：git push origin +[分支名], 注意：一旦运行此命令，删除的文件不能找回 $ git push origin +dev Counting objects: 14, done. Delta compression using up to 8 threads. Compressing objects: 100% (9/9), done. Writing objects: 100% (14/14), 1.40 KiB | 1.40 MiB/s, done. Total 14 (delta 1), reused 0 (delta 0) To http://192.168.102.110/user/test.git + 83d65c7...4b4da80 dev -> dev (forced update) 注意，分支名字前面的+号一定不能忘记，否则会报如下错误： To http://192.168.102.110/user/test.git ! [rejected] dev -> dev (non-fast-forward) error: failed to push some refs to 'http://192.168.102.110/user/test.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送之前要把服务器的分支保护去掉，否则会报如下错误： remote: GitLab: You are not allowed to force push code to a protected branch on this project. To http://192.168.102.110/user/test.git ! [remote rejected] dev -> dev (pre-receive hook declined) error: failed to push some refs to 'http://192.168.102.110/user/test.git' 9.3.3 删除一堆类似文件：git filter-branch --tree-filter \"find * -type f -name '*~' -delete\" HEAD 9.4 全局性地更换电子邮件地址 $ git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME=\"Scott Chacon\"; GIT_AUTHOR_EMAIL=\"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 参考链接： https://git-scm.com/book/zh/v2/Git-工具-重写历史 十、GIT的工作原理 Git 的思维框架（将其作为内容管理器）是管理三棵不同的树。“树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的： ---------------------------- 树 用途 HEAD 上一次提交的快照，下一次提交的父节点 index 预期的下一次提交的快照 Working Directory 沙盒（工作目录） 10.1 HEAD HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。 下例命令就显示了HEAD快照实际的目录列表，以及其中每个文件的SHA-1校验和： $ git cat-file -p HEAD tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf author Scott Chacon 1301511835 -0700 committer Scott Chacon 1301511835 -0700 initial commit $ git ls-tree -r HEAD 100644 blob a906cb2a4a904a152... README 100644 blob 8f94139338f9404f2... Rakefile 040000 tree 99f1a6d12cb4b6f19... lib cat-file与ls-tree是底层命令，它们一般用于底层工作，在日常工作中并不使用。不过它们能帮助我们了解到底发生了什么。 10.2 index index(索引)是你的预期的下一次提交。也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行git commit时Git看起来的样子。 Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。 $ git ls-files -s 100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README 100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile 100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib/simplegit.rb ls-files是底层命令，它会显示出索引当前的样子。确切来说，索引并非技术上的树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。 10.3 Working Directory Working Directory（工作目录），最后，你就有了自己的工作目录。另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。 10.4 工作流程 +-------------------------------------------------------------------+ | +--------------+ +---------------+ +--------------+ | | | Working | | Index | | HEAD | | | | Directory | | | | | | | +-----+--------+ +-------+-------+ +-------+------+ | | | | | | | | | Checkout the project | | | | | | | | | | Commit | | | | +--------------------> | | | | | | | +-------------------------------------------------------------------+ 假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。现在运行git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的分支（master 还不存在）。 此时，只有工作目录有内容。 现在我们想要提交这个文件，所以用git add来获取工作目录中的内容，并将其复制到索引(Index)中。 接着运行git commit，它首先会移除索引中的内容并将它保存为一个永久的快照，然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。 此时如果我们运行git status，会发现没有任何改动，因为现在三棵树完全相同。现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。我们称其为该文件的 v2 版本，并将它标记为红色。 如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit,” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行git add来将它暂存到索引中。 此时，由于索引和 HEAD 不同，若运行git status的话就会看到 “Changes to be committed” 下的该文件变为绿色.也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行git commit来完成提交。 现在运行git status会没有输出，因为三棵树又变得相同了。切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照，然后将 索引 的内容复制到 工作目录 中。 git工作详细介绍 十一、git重置git reset，代码回退操作介绍 11.1 只移动HEAD(相当于取消上一次提交)：git reset --soft HEAD~或 git reset --soft 99ad0ec reset做的第一件事是移动HEAD的指向。reset移动HEAD指向的分支。reset --soft本质上是撤销了上一次git commit命令。 当你在运行git commit时，Git会创建一个新的提交，并移动HEAD所指向的分支来使其指向该提交。当你将它reset回HEAD~HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。现在你可以更新索引并再次运行git commit来完成git commit --amend所要做的事情了。 11.2 移动HEAD，更新index： git reset HEAD~ 或git reset --mixed HEAD~ 它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有git add和git commit的命令执行之前。 11.3 移动HEAD，更新index,更新工作目录（working Directory）: git reset --hard HEAD~ 必须注意，--hard标记是reset命令唯一的危险用法，它也是Git会真正地销毁数据的仅有的几个操作之一。其他任何形式的reset调用都可以轻松撤消，但是--hard选项不能，因为它强制覆盖了工作目录中的文件。在这种特殊情况下，我们的Git数据库中的一个提交内还留有该文件的v3版本，我们可以通过reflog来找回它。但是若该文件还未提交，Git仍会覆盖它从而导致无法恢复。 reset命令会以特定的顺序重写这三棵树，在你指定以下选项时停止： 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止） 使索引看起来像 HEAD （若未指定 --hard，则到此停止） 使工作目录看起来像索引 11.4 使用git reflog命令来查看所有已经提交过的commit 11.5 通过路径来重置：git reset file.txt 假如我们运行git reset file.txt（这其实是git reset --mixed HEAD file.txt的简写形式，因为你既没有指定一个提交的SHA-1或分支，也没有指定--soft或--hard），它会： 移动HEAD分支的指向 （已跳过） 让索引看起来像HEAD（到此处停止） 所以它本质上只是将file.txt从HEAD复制到索引中。它还有取消暂存文件的实际效果。 我们可以不让Git从HEAD拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。我们只需运行类似于git reset eb43bf file.txt的命令即可。 十二、 git checkout 介绍 12.1 切换分支：git checkout [分支名] 运行git checkout [branch]与运行git reset --hard [branch]非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。 首先不同于reset --hard，checkout对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有还未修改过的文件都会被更新。而reset --hard则会不做检查就全面地替换所有东西。 第二个重要的区别是如何更新HEAD。reset会移动HEAD分支的指向，而checkout只会移动HEAD自身来指向另一个分支。 例如，假设我们有master和develop分支，它们分别指向不同的提交；我们现在在develop上（所以HEAD指向它）。如果我们运行git reset master，那么develop自身现在会和master指向同一个提交。而如果我们运行git checkout master的话，develop不会移动，HEAD自身会移动。 现在HEAD将会指向master。 所以，虽然在这两种情况下我们都移动HEAD使其指向了提交 A，但做法是非常不同的。reset 会移动HEAD分支的指向，而checkout则移动HEAD自身。 12.2 放弃index与working Directory的改动：git checkout [分支名] file.txt 该命令不会移动HEAD，只会把HEAD中的代码恢复到index中，同时把工作目录文件也恢复到HEAD中代码的样子。 12.3 值放弃修改working Directory 工作目录中的修改：git checkout file.txt放弃单个修改或使用git checkout .放弃所有修改 这个命令只会放弃工作目录中的修改，已经提交到index中的修改则不会改动。 reset\\checkout命令详细介绍 常用命令 13. git 一些查看命令 ~ git help status # 查看status命令的帮助 # 查看状态和修改 # https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库, git st -s 详细介绍 ~ git status -s # 状态简览,或 git status --short,得到一种更为紧凑的格式输出. # git diff 将通过文件补丁的格式显示具体哪些行发生了改变。 ~ git diff filename # 查看未暂存的修改,git diff 只显示尚未暂存的改动,已经add 的文件修改看不见，需要下面的命令 ~ git diff --staged filename # 或git diff --cached, 查看已暂存的将要添加到下次提交里的内容 # commit 提交 ~ git commit # 这种方式会启动文本编辑器以便输入本次提交的说明 ~ git commit -m \"提交信息\" # 将提交信息与命令放在同一行,直接提交， ~ git commit -a -m '提交信息' # `-a`选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过`git add`步骤。 # 查看提交历史 https://git-scm.com/book/zh/v2/Git-基础-查看提交历史 ~ git reflog # 查看commit 引用日志记录信息 ~ git log -p -2 # -p:用来显示每次提交的内容差异, -2:仅显示最近两次提交. ~ git log --stat # 每次提交的简略的统计信息,列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 ~ git log --pretty=oneline # 每个提交放在一行显示,还有 short，full 和 fuller 可以用 ~ git log -p files # 查看某个文件的详细修改记录 ~ git log --oneline --decorate --graph --all # 提交历史、各个分支的指向以及项目的分支分叉情况 ~ git log --oneline --decorate # 查看各个分支当前所指的对象 14. 获取Git仓库 # https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 # 进入该项目目录 ~ git init ~ git remote add origin http://192.168.102.9/username/ttt.git # 添加远程仓库地址 # 仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪,通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交. ~ git clone https://github.com/libgit2/libgit2 # 克隆现有的仓库 ~ git clone https://github.com/libgit2/libgit2 mylibgit # 克隆现有的仓库,自定义本地仓库的名字 # Git 支持多种数据传输协议,https:// 协议,git:// 协议或者使用 SSH 传输协议 # https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用 ~ git remote show origin # 查看某一个远程仓库的更多信息 ~ git remote rename pb paul # 将 pb 重命名为 paul ~ git remote rm paul # 移除一个远程仓库 15. git tag — 标签相关操作 http://blog.csdn.net/wangjia55/article/details/8793577http://gitref.org/zh/branching/#tag # https://git-scm.com/book/zh/v2/Git-基础-打标签 # 列出标签 $ Git tag # 在控制台打印出当前仓库的所有标签 $ git tag -l ‘v0.1.*’ # 搜索符合模式的标签 # 打标签 $ git tag v0.1.2-light # 创建轻量标签 ,使用这个命令后，只有一个版本号，没有备注信息 # 建议使用附注标签 $ git tag -a v0.1.2 # 这个标签会进入vi中编辑tag提交信息。 $ git tag -a v0.1.2 -m “0.1.2版本” # 创建附注标签， 不进入vi中，直接把tag信息写在这里。 # 切换到标签 $ git checkout [tagname] # 切换到标签 # 如果你想在这个标签中开发，那么则创建一个新分支 $ git checkout -b new_branch_name $ git show v0.1.2 # 查看标签的版本信息 # 删除标签 # 删除本地标签 $ git tag -d v0.1.2 # 删除标签 参数d即delete的缩写，意为删除其后指定的标签。 # 删除远程标签 $ git push origin :refs/tags/ # 推送一个空tag到远程tag $ git push origin --delete tag # 在Git v1.7.0 之后，可以使用这种语法删除远程分支 # 给指定的commit打标签 $ git tag -a v0.1.1 9fbc3d0 # 需要你知道某个提交对象的校验和（通过git log获取） # 标签发布 # 通常的git push不会将标签对象提交到git服务器，我们需要进行显式的操作： $ git push origin v0.1.2 # 将v0.1.2标签提交到git服务器 $ git push origin --tags # 将本地所有标签一次性提交到git服务器 注意：如果想看之前某个标签状态下的文件，可以这样操作：1.git tag 查看当前分支下的标签2.git checkout v0.21 此时会指向打v0.21标签时的代码状态，（但现在处于一个空的分支上） cat test.txt 查看某个文件 16. 代码存储，代码修改记录:git stash, git diff > tmp.patch 当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态，而这时你想要切换到另一个分支做一点别的事情。或者是要拉取新代码， # 方法一： # 把修改的代码备份一下 ~ git diff > tmp.patch # 放弃所有修改的代码 ~ git co . # 拉取代码 ~ git pull # 把备份的代码还原回去 ~ git apply tmp.patch # 注意，不要有冲突，如果拉取的代码与修改的代码重复就会冲突，小心慎重 # 方法二： # https://git-scm.com/book/zh/v2/Git-工具-储藏与清理 ~ git stash # 或使用命令：git stash save 暂存当前状态 # 运行上面的命令后，工作目录就变干净了，使用git status 命令查看 ~ git stash list # 显示已暂存列表 stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \"added file_size\" ~ git stash apply # 将最近的储藏工作重新应用 ~ git stash apply stash@{1} # 应用其中一个更旧的储藏 ~ git stash pop # 应用储藏然后立即从栈上扔掉它 ~ git stash drop stash@{0} # 移除这个存储 # 当你做了几个改动并只想提交其中的一部分，过一会儿再回来处理剩余改动时，这个功能会很有用。 ~ git stash --keep-index # 不要储藏任何你通过 git add 命令已暂存的东西 ~ git stash -u # 指定 --include-untracked 或 -u 标记，Git 也会储藏任何创建的未跟踪文件。 17. 分支管理 $ git branch testing # 创建本地分支 $ git checkout testing # 切换分支 $ git checkout -b euwe-1-jas # 创建分支并切换到这个分支 $ git branch -d testing # 删除本地分支分支 # 删除远程分支 # 如果删除失败看看是不是这个分支时默认分支，修改默认分支就好 $ git push origin --delete # 在Git v1.7.0 之后，可以使用这种语法删除远程分支 $ git push origin : # 推送一个空分支到远程分支，其实就相当于删除远程分支 #重命令本地分支， $ git br -m 旧名字 新名字 # 如果想重命名远程分支，那么先重命名本地分支，然后上传，最后删除就分知名 18. git 回滚到某个commit http://www.shouce.ren/api/view/a/13832 # 回滚到老的commit # 方法一 # 记住最新的commit，然后在用此命令回滚 $ git reset --hard resetVersionHash //将当前branch的HEAD指针指向commit hash $ git reset --hard 3628164 //老的commit # 只看commit SHA1 不看作者跟时间 ~ git log --pretty=oneline # 方法二： # Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164...882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 $ git reset --hard HEAD^ HEAD is now at ea34578 add distributed # 回到新 # 如果记得新commit的号码 $ git reset --hard 3628164 # 3628164 是新的commit HEAD is now at 3628164 append GPL # 如果不记得commit号，那么可使用如下命令查看： $ git reflog ea34578 HEAD@{0}: reset: moving to HEAD^ 3628164 HEAD@{1}: commit: append GPL ea34578 HEAD@{2}: commit: add distributed 19. git 查看改动 # 当修改文件但是没有提交时： $ git diff # 查看所有的改动 $ git diff 文件名 #查看这个文件的改动 # 查看某个commit做了哪些改动 $ git show 046bd7b5c1d134b8123f 20. git恢复删除的文件 # 要查看删除的文件： $ git ls-files --deleted # 使用命令checkout来恢复： $ git checkout -- file_name # 如果要恢复多个被删除的文件，可以使用批处理命令： $ git ls-files -d | xargs git checkout -- # 如果要恢复被修改的文件，命令： $ git ls-files -m | xargs git checkout -- 1.git pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u, git commit之后才能成功pull. 2.如果想放弃本地的文件修改，可以使用git reset --hard FETCH_HEAD，FETCH_HEAD表示上一次成功git pull之后形成的commit点。然后git pull. 21. \"git rm\" 和 \"rm\" 的区别 http://blog.csdn.net/jfkidear/article/details/12152167 这是一个比较肤浅的问题，但对于 Git 初学者来说，还是有必要提一下的。用 git rm来删除文件，同时还会将这个删除操作记录下来；用rm来删除文件，仅仅是删除了物理文件，没有将其从 git 的记录中剔除。 直观的来讲，git rm删除过的文件，执行git commit -m \"abc\"提交时，会自动将删除该文件的操作提交上去。 而对于用rm命令直接删除的文件，执行git commit -m \"abc\"提交时，则不会将删除该文件的操作提交上去。不过不要紧，即使你已经通过rm将某个文件删除掉了，也可以再通过git rm命令重新将该文件从git的记录中删除掉，这样的话，在执行git commit -m \"abc\"以后，也能将这个删除操作提交上去。 如果之前不小心用rm命令删除了一大批文件呢？是的，此时用git rm逐个地再删除一次就显得相当蛋疼了。所幸还有更方便的处理方案，用如下的方式做提交就没有问题了：git commit -am \"abc\" 总结一下： 在被 git 管理的目录中删除文件时，可以选择如下两种方式来记录删除动作：一、rm + git commit -am \"abc\"二、git rm + git commit -m \"abc\"另外，git add . 仅能记录添加、改动的动作，删除的动作需靠git rm来完成。最后，rm删除的文件是处于not staged状态的，也就是一种介于 “未改动” 和 “已提交过” 之间的状态。 22. 关闭git pull产生的merge 信息 linux, 编辑 ~/.gitconfig: [core] mergeoptions = --no-edit 或者终端执行：git config --global core.mergeoptions --no-edit 22.1 git pull 产生merge信息的原因 Git 作为分布式版本控制系统，所有修改操作都是基于本地的，在团队协作过程中，假设你和你的同伴在本地中分别有各自的新提交，而你的同伴先于你 push 了代码到远程分支上，所以你必须先执行 git pull 来获取同伴的提交，然后才能 push 自己的提交到远程分支。而按照 Git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），Git 会执行一次 merge 操作，因此产生一次没意义的提交记录，从而造成了像上图那样的混乱。 22.2 解决 参考：洁癖者用 Git：pull --rebase 和 merge --no-ff其实在 pull 操作的时候，，使用 git pull --rebase 选项即可很好地解决上述问题。 加上 --rebase 参数的作用是，提交线图有分叉的话，Git 会 rebase 策略来代替默认的 merge 策略。 使用 rebase 策略有什么好处呢？假设提交线图在执行 pull 前是这样的： A---B---C remotes/origin/master / D---E---F---G master 如果是执行git pull 后，提交线图会变成这样： A---B---C remotes/origin/master / \\ D---E---F---G---H master 结果多出了 H 这个没必要的提交记录。如果是执行 git pull --rebase的话，提交线图就会变成这样： remotes/origin/master | D---E---A---B---C---F'---G' master F G 两个提交通过 rebase 方式重新拼接在 C 之后，多余的分叉去掉了，目的达到。 会把你的本地master分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到\".git/rebase\"目录中),然后把本地master分支更新 到最新的\"origin\"分支，最后把保存的这些补丁应用到本地\"maser\"分支上。 关于git --rebase介绍：http://gitbook.liuhui998.com/4_2.htmlhttp://blog.csdn.net/hudashi/article/details/7664631/ 23. git pull文件时和本地文件冲突 http://www.01happy.com/git-resolve-conflicts/ 当拉去远程代码时，出现如下错误： error: Your local changes to 'c/environ.c' would be overwritten by merge. Aborting. Please, commit your changes or stash them before you can merge. 这个意思是说更新下来的内容和本地修改的内容有冲突，先提交你的改变或者先将本地修改暂时存储起来。处理的方式非常简单，可使用git stash命令或者提交修改。 24. git删除远程仓库的一次commit提交 # 参考链接： http://zhuqingcode.github.io/git/2014/05/15/github-a-bug-commit.html # 方法一： 删除远程一次提交 ~ git reset --hard HEAD~1 ~ git push --force ## 强制推送提交， ~ git push -f origin master ## 强制推送提交 # 方法二： 采取revert的方法，相当于重新生成一个提交，来撤销前一次错误的commit。 ~ git revert HEAD ~ git push origin master 跳转到这里： powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/git/003-git常见问题及解决.html":{"url":"doc/git/003-git常见问题及解决.html","title":"git常见问题及解决","keywords":"","body":" 1. 不同操作系统使用git时，CRLF的处理换行问题 1.1 什么是CRLF和LF 1.2 在Git中设置自动转换 2. 多个仓库相同代码推送被拒绝 3. 由于Mac电脑升级导致 git不能用 4. git使用vi编辑器时候报错：Swap file \"./.git/.COMMIT_EDITMSG.swp\" already exists! 5. Git中文乱码的问题 6. GIT不识别大小写文件夹解决 7. 同一个文件跟踪两次 8. gitlab保护分支，导致本地git push -f报错 9. 代码回滚到以前的版本 9.1 代码还没有push到远程仓库，回滚使用git reset 9.2 代码已经push到远程仓库 9.2.1 代码刚push，还没有扩散 9.2.2 代码已经被其他开发拉取或已经被自动部署工具拉取了 9.2.3 代码已经扩散，麻烦别人删除分支，然后从新拉取代码 10. 使用git log统计你在项目中的工作量 10.1 按提交记录时间段来统计 10.2 按照提交用户名来统计 10.3 按照用户名和时间段来统计 10.4 统计自己一天代码行数 10.5 其他的统计方法 目录 [TOC] 1. 不同操作系统使用git时，CRLF的处理换行问题 错误信息类似于： # https://git-scm.com/book/zh/v2/自定义-Git-配置-Git ~ git diff > tmp.patch warning: LF will be replaced by CRLF in src/app/theme/components/menuItem/menuItem.component.css. The file will have its original line endings in your working directory. warning: LF will be replaced by CRLF in config/webpack.dev.js. 1.1 什么是CRLF和LF CRLF 是 carriage return line feed的缩写。中文意思是回车换行。LF是line feed的缩写，中文意思是换行。CRLF->Windows-styleLF->Unix StyleCR->Mac StyleCRLF表示句尾使用回车换行两个字符(即我们常在Windows编程时使用\"\\r\\n\"换行)LF表示表示句尾，只使用换行.CR表示只使用回车. 1.2 在Git中设置自动转换 在Git通过下面的命令配置: $git config --global core.autocrlf true # Configure Git on Windows to properly handle line endings 设置为true，添加文件到git仓库时，git将其视为文本文件。他将把crlf变成lf。设置为false时，line-endings将不做转换操作。文本文件保持原来的样子。设置为input时，添加文件git仓库石，git把crlf编程lf。当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置。1) true: x -> LF -> CRLF2) input: x -> LF -> LF3) false: x -> x -> x 其他的命令 # AutoCRLF #提交时转换为LF，检出时转换为CRLF git config --global core.autocrlf true #提交时转换为LF，检出时不转换 git config --global core.autocrlf input #提交检出均不转换 git config --global core.autocrlf false # SafeCRLF #拒绝提交包含混合换行符的文件 git config --global core.safecrlf true #允许提交包含混合换行符的文件 git config --global core.safecrlf false # 设置这个命令会把警告取消 #提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn 2. 多个仓库相同代码推送被拒绝 当添加一个仓库后，推送文件上去不允许,错误信息类似于： git push github master To https://github.com/user/my_wiki.wiki.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'https://github.com/user/my_wiki.wiki.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 如果远程仓库的代码没用了，不要了，则可以选择强推代码解决问题： ~ git push -u github master -f 3. 由于Mac电脑升级导致 git不能用 使用git的时候出现类似下面的信息： xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决方法,终端下输入下面命令： xcode-select --install 需要安装一会就可以了。 4. git使用vi编辑器时候报错：Swap file \"./.git/.COMMIT_EDITMSG.swp\" already exists! 非正常关闭vi编辑器时会生成一个.swp文件。使用vi，经常可以看到swp这个文件,那这个文件是怎么产生的呢，当你打开一个文件，vi就会生成这么一个.(filename)swp文件 以备不测（不测下面讨论），如果你正常退出，那么这个这个swp文件将会自动删除 。swp文件的来历，当你强行关闭vi时，比如电源突然断掉或者你使用了Ctrl+ZZ，vi自动生成一个.swp文件，下次你再编辑时，就会出现一些提示。 比如你正在使用vi编辑file.txt文件，然后强制关闭终端，这个时候就会产生.file.txt.swp文件。当再次使用vi打开file.txt文件就会出现提示， 这个时候可使用下面的命令来恢复未保存的操作： vi -r file.txt 这个时候保存中断之前的操作后，.swp文件不会自动删除，需要自己手动删除： rm .file.txt.swp 5. Git中文乱码的问题 在使用git命令的时候，如果文件名是中文的，就会出现如\\200\\273\\347\\273\\223.png的乱码。 解决方法，在终端中输入如下命令： git config --global core.quotepath false core.quotepath设为false的话，就不会对0x80以上的字符进行quote。中文显示正常。 参考链接： http://blog.csdn.net/tyro_java/article/details/53439537 6. GIT不识别大小写文件夹解决 在mac电脑下，git仓库中有文件夹首字母大写，修改成首字母小写后，git没有识别出文件夹的修改， 可使用如下命令设置为大小写敏感： git config core.ignorecase false 7. 同一个文件跟踪两次 由于修改了文件名，仅仅是文件名首字母大小写修改了，然后就导致git同时把这一个文件跟踪了两次，比如我修改了文件夹名字，由Settings 改成 settings,导致文件夹下的文件重复出现： modified: src/views/Settings/TagSet/TagDialog.jsx modified: src/views/settings/TagSet/TagDialog.jsx 此时可使用git rm --cached来取消对重命名之前的文件跟踪 git rm --cached src/views/Settings/TagSet/TagDialog.jsx rm 'src/views/Settings/TagSet/TagDialog.jsx' 取消跟踪后，使用git status查看，就会发现这个文件自动添加到删除中了： ~ git rm --cached src/views/Settings/TagSet/TaDialog.jsx rm 'src/views/Settings/TagSet/TagDialog.jsx' ~ git status On branch master Your branch is up-to-date with 'origin/master'. Changes to be committed: (use \"git reset HEAD ...\" to unstage) deleted: src/views/Settings/RuleSet/RuleDialog.jsx deleted: src/views/Settings/TagSet/TagDialog.jsx modified: src/views/settings/RuleSet/RuleDialog.jsx modified: src/views/settings/TagSet/TagDialog.jsx 8. gitlab保护分支，导致本地git push -f报错 产生原因：服务器提交了错误或者无用的代码，本地回滚代码，然后把代码强推到服务器上，由于gitlab上有分支保护导致代码推送失败： git push origin master -f Total 0 (delta 0), reused 0 (delta 0) remote: GitLab: You are not allowed to force push code to a protected branch on this project. To http://git.baijiahulian.com/yunying/bi-fe.git ! [remote rejected] master -> master (pre-receive hook declined) error: failed to push some refs to 'http://git.baijiahulian.com/yunying/bi-fe.git' 在gitlab上查看保护的分支 在gitlab上打开项目，点击Repository, 然后点击Branches,就能看见所有分支，在分支名字后面有个绿色的protected就是保护分支。 关闭gitlab上的保护分支(需要项目的master或者Owner) 点击项目右上角(用户logo下面)的小齿轮，选择Protected Branches,在打开的页面里面就能看见保护的分支了，然后点击保护分支右边的Unprotect,就能删除对这个分支的保护了。 开启gitlab上的保护分支(需要项目的master或者Owner) 点击项目右上角(用户logo下面)的小齿轮，选择Protected Branches, 在Protect a branch中输入分支名字，选择对应权限，然后点击Protect，就会立刻添加一个保护分支了。 9. 代码回滚到以前的版本 改完代码匆忙提交,上线发现有问题,怎么办? 赶紧回滚. 改完代码测试也没有问题,但是上线发现你的修改影响了之前运行正常的代码报错,必须回滚. 回滚分两种情况 9.1 代码还没有push到远程仓库，回滚使用git reset 当代码还在本地仓库，在add、commit后发现代码有问题，想回退到以前的提交点，此时可用reset命令： git reset option 历史提交点 option：reset的操作选项可用命令有： --hard: 移动HEAD，更新index,更新工作目录（working Directory） --mixed: 移动HEAD，更新index, 此选项是reset的默认选项，也就是不写option默认就是此操作。 --soft: 只移动HEAD, 历史提交点: commit标识代码， 也就是git log命令中的一串字符串，如:d42a68c81， 通常前8位以上就可以 reset命令会以特定的顺序重写这三棵树，在你指定以下选项时停止： 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止） 使索引看起来像 HEAD （若未指定 --hard，则到此停止） 使工作目录看起来像索引 使用例子： git reset --hard 9e53f30b7ab56e HEAD is now at 9e53f30 开始页面：添加提交按钮。 此时所有历史commit记录可使用git reflog来查找： git reflog 26c5d5a (HEAD -> test, origin/test) HEAD@{0}: reset: moving to 26c5d5a 9e53f30 HEAD@{1}: reset: moving to 9e53f30b7ab56e 26c5d5a (HEAD -> test, origin/test) HEAD@{2}: commit: 添加测试包 9e53f30 HEAD@{3}: commit: 提交信息 如果回退错了，可使用上面命令把最早的提交在回退回来。 9.2 代码已经push到远程仓库 9.2.1 代码刚push，还没有扩散 代码刚push，还没有被其他开发人员拉取，或者还没有用于自动部署工具拉取(如Jenkins)。 此时使用git reset 回退后，然后使用git push -f 来强推代码到仓库即可： git reset --hard 9e53f30b7 HEAD is now at 9e53f30 开始页面：添加提交按钮。 git push -f Total 0 (delta 0), reused 0 (delta 0) remote: remote: Create merge request for tt: remote: http://git.github.com/finance-system/zi-fe/merge_requests/new?merge_request%5Bsource_branch%5D=tt remote: To http://git.github.com/finance-system/zi-fe.git + 26c5d5a...54ebaf8 tt -> tt (forced update) 注意，如果推送的分支是保护分支(gitlab仓库有保护分支设置)，那么只能是master权限才能强推代码，或暂时把保护分支关闭才能正确推送代码。 9.2.2 代码已经被其他开发拉取或已经被自动部署工具拉取了 由于此时代码已扩散了，如果在使用reset回退然后强推则会导致被人在拉取你代码的时候导致冲突，拉取失败。 此时可使用git revert来回退了： git revert用于反转提交,执行evert命令时要求工作树必须是干净的. git revert用一个新提交来消除一个历史提交所做的任何修改. revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题) revert 使用,需要先找到你想回滚版本唯一的commit标识代码： git revert 26c5d5a7ce5b [tttt 5774123] Revert \"哈勃包名更改测试。\" 3 files changed, 3 insertions(+), 5 deletions(-) git revert 26c5d5a7ce5b命令会回把26c5d5a7ce5b的提交回退，并生成一次提交记录。 如果想一次revert多个提交点： git revert 2c71073d2..b688116bde 注意： 2c71073d2 ：是旧提交点，也就是比 b688116bde提交时间早 提交点是两个点之间的，每一个提交都会生成已给提交记录。 使用2c71073d2..b688116bde其实比单独一个2c71073d2是一样的，如果回退5个提交，则会出现5次提交记录。 9.2.3 代码已经扩散，麻烦别人删除分支，然后从新拉取代码 如果别人已经拉取你的分支代码了，还可以然他删除这个分支，然后从新拉取代码。 本地使用git reset回退到一个历史版本中。 使用git push -f强推到服务器仓库。 别人要做如下操作： git checkout master // 切换到其他分支 git branch -d tt // 删除有问题的分支 git fetch -a // 提取所有git信息到本地 git checkout tt // 此时你的新分支代码就没问题了 git pull 如果是Jenkins构建的，可在Jenkins配置里面的脚本先执行下面代码： git checkout master && git branch -d $branch && git fetch -a && git checkout $branch && git pull\" $branch是Jenkins里面的分支名字变量。 10. 使用git log统计你在项目中的工作量 10.1 按提交记录时间段来统计 此方法统计从提交的开始时间到结束这一段时间所有的提交代码 git log --since=2018-01-01 --until=2018-12-31 --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 36874, removed lines: 12214, total lines: 24660 上面的git命令按照2018-01-01到2018-12-31这段时间来统计你的代码提交量 10.2 按照提交用户名来统计 此方法可以统计项目中，该用户的工作量 git log --author=\"username\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 29146, removed lines: 7457, total lines: 21689 注意把username改成真正的用户名。 10.3 按照用户名和时间段来统计 此方法过滤一段时间内，某个用户的代码量 git log --author=\"username\" --since=2018-10-01 --until=2018-12-31 --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' added lines: 2068, removed lines: 953, total lines: 1115 注意把username改成真正的用户名。 10.4 统计自己一天代码行数 git log --author=\"$(git config --get user.name)\" --no-merges --since=1am --stat git log --author=\"$(git config --get user.name)\" --no-merges --since=1am --stat --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' 10.5 其他的统计方法 查看仓库提交者排名前 5 git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5 贡献值统计 git log --pretty='%aN' | sort -u | wc -l 提交数统计 git log --oneline | wc -l 添加或修改的代码行数： git log --stat|perl -ne 'END { print $c } $c += $1 if /(\\d+) insertions/' powered by Gitbook文件最后修改时间： 2019-12-04 18:11:10 "},"doc/git/004-合并多个Commit.html":{"url":"doc/git/004-合并多个Commit.html","title":"合并多个Commit","keywords":"","body":" git修改未push的最后一次commit注释 这个合并只能是本地git仓库的操作，服务器仓库则不行。 如图所示，有三个commit需要合并： 使用命令： # -i 的参数是不需要合并的 commit 的 hash 值，为第四个提交的 commit， 接着我们就进入到 vi 的编辑模式 ~git rebase -i 568361540e8cd90d1 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令，而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成。当前我们只要知道 pick 和 squash 这两个命令即可：pick 的意思是要会执行这个 commitsquash 的意思是这个 commit 会被合并到前一个commit pick：正常选中 reword：选中，并且修改提交信息； edit：选中，rebase时会暂停，允许你修改这个commit（参考这里） squash：选中，会将当前commit与上一个commit合并 fixup：与squash相同，但不会保存当前commit的提交信息 exec：执行其他shell命令 我们将 1b45fb6 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出这时我们会看到 commit message 的编辑界面： 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 注意事项：如果这个过程中有操作错误，可以使用 git rebase --abort来撤销修改，回到没有开始操作合并之前的状态。 注意推送代码之前的命令： # --rebase 还不知道什么意思 ~git pull --rebase 参考链接： http://www.jianshu.com/p/964de879904ahttp://yongpoliu.com/reorganize-git-local-commits/ git修改未push的最后一次commit注释 其commit提供了一个--amend参数，可以修改最后一次提交的信息.但是如果你已经push过了，那么其历史最后一次，永远也不能修改了。 # 如果设置了 commit简写为 ci，则可以用： git ci --amend # https://git-scm.com/book/zh/v2/Git-基础-撤消操作 git commit --amend # 这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。 参考链接：http://blog.csdn.net/taget/article/details/7045046 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/git/005-git代码冲突处理软件P4Merge.html":{"url":"doc/git/005-git代码冲突处理软件P4Merge.html","title":"git代码冲突处理软件P4Merge","keywords":"","body":" 下载安装 教程参考链接 下载安装 下载地址：https://www.perforce.com/downloads/helix-visual-client-p4v下载教程：http://blog.csdn.net/wirelessqa/article/details/9035215这里下载之前需要注册。![WX20170601-134653.png](https://bitbucket.org/repo/oE6yEX/images/1135708659-WX20170601-134653.png) 配置脚本 编写一个全局包装脚本来运行你的命令。 我们会使用 Mac 上的路径来指定该脚本的位置，在其他系统上，它将是 p4merge 二进制文件所在的目录。 创建一个名为 extMerge 的脚本包装 merge 命令，让它把参数转发给 p4merge 二进制文件： $ cat /usr/local/bin/extMerge #!/bin/sh /Applications/p4merge.app/Contents/MacOS/p4merge $* 创建一个extDiff的脚本： $ cat /usr/local/bin/extDiff #!/bin/sh [ $# -eq 7 ] && /usr/local/bin/extMerge \"$2\" \"$5\" 确保这些脚本具有可执行权限： $ sudo chmod +x /usr/local/bin/extMerge $ sudo chmod +x /usr/local/bin/extDiff 配置git命令支持这个软件： $ git config --global merge.tool extMerge # 下面的参考链接里面这部分有误，照这个做 $ git config --global mergetool.extMerge.cmd 'extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\"' $ git config --global mergetool.extMerge.trustExitCode false $ git config --global diff.external extDiff 或编辑你的 ~/.gitconfig 文件，添加以下各行： # 上面终端命令跟下面的做法是一样的 [merge] tool = extMerge [mergetool \"extMerge\"] cmd = extMerge \"$BASE\" \"$LOCAL\" \"$REMOTE\" \"$MERGED\" trustExitCode = false [diff] external = extDiff 待一切设置妥当后，如果你像这样运行 diff 命令git diff 32d1776b1^ 32d1776b1 Git 将启动 P4Merge，而不是在命令行输出比较的结果.如果你尝试合并两个分支，随后遇到了合并冲突，运行 git mergetool，Git 会调用 P4Merge 让你通过图形界面来解决冲突。 教程参考链接 git-book： https://git-scm.com/book/zh/v2/自定义-Git-配置-Git csdn： http://blog.csdn.net/ccf0703/article/details/7661789 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/git/006-git内部原理揭秘.html":{"url":"doc/git/006-git内部原理揭秘.html","title":"git内部原理揭秘","keywords":"","body":" 说明 [TOC] 说明 转载自知乎：https://zhuanlan.zhihu.com/p/96631135 powered by Gitbook文件最后修改时间： 2019-12-13 17:15:25 "},"doc/mac/001-Mac下常用的软件.html":{"url":"doc/mac/001-Mac下常用的软件.html","title":"Mac下常用的软件","keywords":"","body":" 1. Homebrew 2. Homebrew Cask 3. 替换系统默认Shell — Oh My ZSH! 4. 窗口管理软件 – SizeUp 5. 快速切换和打开应用程序 — Manico 6. FileZilla 7. keyCue 8. CheatSheet 9. IINA视频播放器 10. Office 2016 for Mac 11. install gadmin3 12. caffeine 防止mac电脑休眠软件 13. 好用的截屏工具-Snip 14. go2shell 快速进入Shell 15. 增强资源管理器 — XtraFinder 16. 替换系统默认终端 — iTerm 2 17. 有道词典Mac版本 mac 右上角菜单栏时间显示点击出现日历 18. Bandwidth+ Mac上免费流量监测软件 19. MagicanLite 流量监控，CPU,内存使用 温度监控 20. CHM View .chm格式文件阅读器 21. Foxmail 邮件客户端 22. lantern 蓝灯翻墙软件 23. paintbrush 类似Windows画图板的软件 Paintbrush version:2.1.1 类似于Windows下面的画板 24. fHash 计算 MD5、SHA1文件校验软件 25. Kill Mouse Accel 关闭mac下鼠标加速 26. MagicPrefs 苹果鼠标的多手势辅助软件 27. Hostbuddy修改host地址的软件 28. FOLX 5Downloader for Mac 29. Charles 抓包工具 duet 扩展屏软件 sublime text 3 expect 可以与终端交互的脚本语言 文件恢复软件TestDisk Mac下 罗技G602无线鼠标驱动下载 解压工具 7z : brew install p7zip typora: Markdown编辑器 PS6 安装 gif截图工具：Gifox 目录 [TOC] 1. Homebrew # Mac下包管理工具，官方称之为 The missing package manager for OS X 。 # 官网：https://brew.sh/index.html # 安装步骤：先打开 Terminal 应用，输入： ~ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" # 有了 brew 以后，要下载工具，比如 MySQL、Gradle、Maven、Node.js 等工具，就不需要去网上下载了，只要一行命令就能搞定： # PS：安装 brew 的时候会自动下载和安装 Apple 的 Command Line Tools。 # 卸载： $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" ![WX20170721-110833.png](https://bitbucket.org/repo/oE6yEX/images/2928716488-WX20170721-110833.png) 2. Homebrew Cask brew cask 允许你使用命令行安装 OS X 应用。比如你可以这样安装 Chrome： brew cask install google-chrome 。还有 Evernote、Skype、Sublime Text、VirtualBox 等都可以用 brew cask 安装。brew-cask 是社区驱动的，如果你发现 brew cask 上的应用不是最新版本，或者缺少你某个应用，你可以自己提交 pull request。应用也可以通过 App Store 安装，而且有些应用只能通过 App Store 安装，比如 Xcode 等一些 Apple 的应用。App Store 没有对应的命令行工具，还需要 Apple ID。倒是更新起来很方便。几乎所有常用的应用都可以通过 brew cask 安装，而且是从应用的官网上下载，所以你要安装新的应用时，建议用 brew cask 安装。如果你不知道应用在 brew cask 中的 ID，可以先用 brew cask search 命令搜索。 # 安装cask ~ brew install caskroom/cask/brew-cask # 如果上面命令失败了，则用下面的命令安装：http://www.cnblogs.com/dayou123123/p/6867936.html ~ brew install brew-cask-completion # 搜索软件 ~ brew cask search chrome # 安装软件 ~ brew cask install chrome # 卸载软件 ~ brew cask uninstall chrome ​ 3. 替换系统默认Shell — Oh My ZSH! Bash作为大多数系统默认安装的Shell，大家都多少有所接触，Zsh和Bash类似都是一个Shell，但是Zsh更注重用户体验和与人的交互，OS X默认也安装好了Zsh，然而你想自己从头开始配置一个顺手的Zsh是比较浪费时间的，有人已经帮我们配置好了，这个流行的Zsh配置叫—Oh My ZSH!，直观的效果如下图所示，代码开源在github。 # Mac OS X默认已经安装好了Zsh，你可以打开终端，输入zsh --version来确认 ~ zsh --version # 切换默认Shell为Zsh, 成功后需要重启终端 ~ chsh -s /bin/zsh # 切换Zsh为Shell， 成功后需要重启终端 ~ chsh -s /bin/bash # 查看zsh配置的环境变量： ~ cat ~/.zshrc # 此时还没有酷炫的效果，需要安装插件 # 安装Oh My ZSH! sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" # 卸载Oh My ZSH，注意：卸载后，.zshrc文件还在 uninstall_oh_my_zsh https://www.jianshu.com/p/d194d29e488c 遇到的问题解决： 在安装好后，打开终端出现 执行.sh脚本，异常/bin/sh^M: bad interpreter: No such file or directory 注意，提示中出现了^m符号，这是不同系统编码格式引起的，^M在Linux/Unix中是非常常见的，也就是我们在Win中见过的\\r回车符号，可使用vim编辑器打开脚本文件，在命令行模式下，输入下面命令来删除^M: :%s/\\r//g :wq 这句命令的意思是：％指匹配整个文件，s是指置换的意思，\\r代表^M（或者可以使用Ctrl+V Ctrl +M来输入^M，即也可以使用命令:/s^M$//g来达到同样的目的），M后面的$代表匹配行尾的内容，最后的g表示每行中匹配的内容都要进行替换 Unix系统里，每行结尾只有“”，即\"\\n\"；Windows系统里面，每行结尾是“”，即“\\r\\n”；Mac系统里，每行结尾是“”，即\"\\r\"；。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 4. 窗口管理软件 – SizeUp SizeUp快速移动软件窗口在屏幕之间，可以在一个屏幕中上下左右移动，也可以在2个显示器之间移动，该软件可以永久免费试用。 # sizeup网站介绍： http://www.irradiatedsoftware.com/sizeup/ # 使用brew cask安装 ~ brew cask install sizeup # SizeUp需要你的授权才能控制窗口， 打开‘系统与偏好设置’ -> ‘安全与隐私’ -> '隐私' -> '辅助功能'，把sizeup前面打上对号。 5. 快速切换和打开应用程序 — Manico MacBook系统默认设置了一个快捷键来显示当前运行中的应用程序，同时按下tab + command.Manico 是一个为 OS X 设计的快速的 App 启动和切换工具 # manico网站：https://manico.im/ # 使用brew cask安装,也可以去网站上下载后安装 ~ brew cask install manico 6. FileZilla 这个软件可以连接远程电脑并且可以上传下载文件，并且在线编辑文件。这个软件在Windows，Linux，Mac OS 都有客户端，下载地址：https://filezilla-project.org/download.php?type=client 7. keyCue 安装后，只要按住cmd键，就可以显示当前所有可用快捷键，放开后恢复，非常方便。效率生活必备。http://www.yxdown.com/soft/247108.html注册码： KC-FMO-032015-S-426-631227-819538-50 8. CheatSheet CheatSheet 能够显示当前程序的快捷键列表，默认的快捷键是长按 ⌘ 。安装：shbrew cask install cheatsheet 9. IINA视频播放器 https://lhc70000.github.io/iina/https://github.com/lhc70000/iina终端： brew cask install iina 10. Office 2016 for Mac http://bbs.feng.com/read-htm-tid-10868252.html安装完后不要打开office软件，打开破解补丁.dmg，里面有把蓝色的钥匙，双击，出现一把黑色的锁，点击，输入系统密码，OK~搞定Office 2016 for Mac破解版（含破解补丁）百度盘下载链接: https://pan.baidu.com/s/1c1HIrks 密码: r9khhttp://jingyan.baidu.com/article/ce09321b7478072bff858f03.htmlpc6下载：http://www.pc6.com/mac/137931.html 11. install gadmin3 #终端，已经安装了brew ，cask ~ brew search pgadmin3 Caskroom/versions/pgadmin3 ~ brew install Caskroom/versions/pgadmin3 12. caffeine 防止mac电脑休眠软件 #终端，已经安装了brew ，cask ➜ ~ brew search caffeine Caskroom/cask/caffeine ➜ ~ brew cask install caffeine # 还可以网站下载后安装：http://lightheadsw.com/caffeine/ 13. 好用的截屏工具-Snip 使用过QQ的朋友肯定用过上面的自带截图功能,非常好用, 支持添加圈,点,箭头甚至文字, 只要打开QQ, 任何时候都可以通过Ctrl+Command+a来截图, 但是本人平时不太常使用QQ, 截屏功能又非常常用，怎么办呢? 腾讯很贴心地把QQ里的截图功能完整地拆了出来, 成了一个新的App–Snip. ~ brew search snip esniper Caskroom/cask/snip Caskroom/cask/snippets Caskroom/cask/snippet-edit ~ brew cask install snip 14. go2shell 快速进入Shell go2shell是一个对开发者来说非常有用的app, 使用它可以在Finder里快速进入shell环境. 在 App Store中搜索go2shell，点击安装 安装go2shell后，打开finder的application文件夹，找到go2shell 按住command，用鼠标将go2shell拖到finder的toolbar上 在打开的terminal中，输入： open -a Go2Shell --args config命令来修改go2shell的配置安装好以后, 打开Finder, 点击Finder上的图标即可进入terminal: ➜ ~ brew search go2shell Caskroom/cask/go2shell ➜ ~ brew cask install go2shell # 用这个命令安装的是最新版本，这个版本挡在finder中点击go2shell后出来的不是终端而是go2shell的配置，所以卸载， # 找到go2shell的新版本使用方法后可以使用这个命令安装 #卸载，仅适用于用cask命令安装的 ➜ ~ brew cask uninstall go2shell # 配置文件 ➜ ~ open -a Go2Shell --args config 15. 增强资源管理器 — XtraFinder MacBook自带的资源管理器(Finder)已经可以满足一般的需要，但是当你有大量文件维护操作后，你就需要一个更强大的Finder。XtraFinder完全集成到Finder里面，你根本感觉不出它是一个第三方的应用程序，同时还提供很多增强特性，比如： 像浏览器那样的标签页(Tab)支持双操作面板(Panel)增强的全局快捷键，例如新建文件(New File)等多彩的侧边栏图标快速在当前文件夹打开终端快速在当前文件夹新建文件 ➜ ~ brew search XtraFinder Caskroom/cask/xtrafinder ➜ ~ brew cask install xtrafinder ➜ ~ brew cask uninstall xtrafinder 16. 替换系统默认终端 — iTerm 2 如果你经常使用终端，那么推荐你使用iTerm 2来替代系统自带的终端。关于iTerm 2的特性，请看这里。iterm2的介绍：http://www.cnblogs.com/theswiftworld/p/4679010.htmlhttps://www.iterm2.com/features.html 设置 F12 启动iterm2： 1.打开System Preferences，选择Keyboard，切换到Shortcuts这个Tab下，点击Mission Control，取消对应F12的快捷键。2.打开iTerm的Preferences...， 在ProfilesTab里面，点击下面的[+]添加一个新的profile，为什么要新建一个profile？答案是为了定制将来弹出的终端样式和大小等等参数。新的profile假设命名为guake，(注：guake这个名称是为了向Linux下的Guake终端致敬)，你可以自己任意起个名称，下面会用到。3.再切换到WindowTab下，将Style，Screen和Space这3个值设置一下。4.再切换到KeysTab下，设置如下图所示的HotkeyF12。5.现在你按下F12，就立即得到一个占满全屏的黑色命令行终端，再按一下F12隐藏终端，非常的方便。 iterm2终端透明度设置 profile -> 点中profile名字 -> window -> transparency ~ brew cask search iterm2 # 安装 iterm2 ~ brew cask install iterm2 17. 有道词典Mac版本 官网下载：http://cidian.youdao.com/index-mac.html取词方便，打开后，可使用快捷键唤起界面进行查词(alt + cmd + X) mac 右上角菜单栏时间显示点击出现日历 https://shauninman.com/archive/2016/10/20/day_o_2_mac_menu_bar_clock 18. Bandwidth+ Mac上免费流量监测软件 款可以实时查看网络流量的小软件，支持对 Mac 连接的无线 Wi-Fi 以及移动热点上下行流量进行实时监控记载，而且还能对网络流量进行定额记录，就在 Menubar 下可以看到流量的消耗，并且能够以天为单位将每个网络流量记录导出称 csv 文件。 在 App Store 中搜索 Bandwidth+, 点击安装。![WX20170401-152107.png](https://bitbucket.org/repo/oE6yEX/images/2529262879-WX20170401-152107.png) 19. MagicanLite 流量监控，CPU,内存使用 温度监控 http://www.magicansoft.com.cn/这款软件免费，可以监控流量， cup的使用率温度，GPU温度， 内存的使用率等。 在 App Store 中搜索 MagicanLite, 点击安装。 20. CHM View .chm格式文件阅读器 免费的.chm文件阅读器。 在 App Store 中搜索 CHM View, 点击安装。 21. Foxmail 邮件客户端 http://www.foxmail.com/mac/ 22. lantern 蓝灯翻墙软件 https://github.com/getlantern/forumhttps://www.getlantern.org/点击下载安装就好， 每月免费500MB流量。 23. paintbrush 类似Windows画图板的软件 http://mac.brothersoft.com/paintbrush-download.htmlhttp://mac.brothersoft.com/paintbrush.htmlPaintbrush的按钮布局和功能与PC电脑Windows自带的画图都很接近，基本不用介绍了。注意那个地雷按钮！他的作用是清除整个画面---没错，炸成白板---我已经中招了（囧），还好后悔操作的快捷键和系统默认的“后退”键一样：“CMD+Z”。安装后，右键的打开方式菜单里会有用paintbrush打开这一项。 Paintbrush version:2.1.1 类似于Windows下面的画板 Paintbrush-2.1.1 http://mac.brothersoft.com/paintbrush-download.html 链接: https://pan.baidu.com/s/1miObeac 密码: qikg 24. fHash 计算 MD5、SHA1文件校验软件 https://itunes.apple.com/cn/app/fhash/id1055555711?l=en&mt=12app Store 软件中搜索fHash 安装即可。 25. Kill Mouse Accel 关闭mac下鼠标加速 用于罗技等无线鼠标卡顿解决的小插件。 移的越快，鼠标移动距离就越大，这就是鼠标加速度。http://bbs.feng.com/read-htm-tid-445826.html 26. MagicPrefs 苹果鼠标的多手势辅助软件 下载地址： http://magicprefs.com/ 注意：这个软件会是系统的快速移动鼠标以定位鼠标位置 27. Hostbuddy修改host地址的软件 官网地址 Hostbuddy 是Mac里最简单的方法来管理和更新的 /etc/hosts 文件。添加新条目，打开和关闭现有的通过一次单击。这是完美的临时和生产服务器间进行切换，或只是为了测试你的新网站在上线之前。 快速而无需使用命令行添加主机条目 打开/关闭主机组通过一次单击 不会覆盖现有的 /etc/hosts 文件 与 VirtualHostX 兼容 自动刷新 DNS 缓存 28. FOLX 5Downloader for Mac https://mac.eltima.com/download-manager.html mac 下下载工具，有免费版。 29. Charles 抓包工具 Charles 是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 使用注意事项： 如果没有抓取到数据，尝试关闭代理或浏览器的代理。 选择菜单中的 “Proxy” –> “Mac OS X Proxy” 来将 Charles 设置成系统代理 “Proxy” –> “Proxy Settings” -> \"macOS\" 要把 里面选项都勾选上 Enable macOS proxy ​ Use HTTP proxy Enable macOS proxy on launch 如果不勾选上面选项，则不能抓取到包 使用教程： https://www.cnblogs.com/mawenqiangios/p/8270238.html duet 扩展屏软件 https://www.duetdisplay.com/ Duet Display 就可以把 iPad 或 iPhone 变成你电脑的第二台显示器！相对于通过「网络远程控制」实现屏幕扩展的同类 APP，Duet 通过 USB 数据线传输画面，无论清晰度、稳定性还是流畅度都完胜。即使开启 Retina 视网膜分辨率，仍能保持 60 FPS 低延迟不卡顿，实际体验相当好 DuetDisplay 电脑端支持 macOS 和 Windows，也就是说，无论是 PC 台式机、笔记本还是 Macbook、iMac 等设备通通都能用它来扩展桌面！而且不仅仅是显示内容，Duet 还可以让这块 “扩展屏幕” 增加「触摸和手势操作」、支持 Apple Pencil 数字笔、以及增加 TouchBar 等特性的支持。 sublime text 3 http://www.sublimetext.com/官网下载后直接安装 expect 可以与终端交互的脚本语言 ~ brew search expect ~ brew install expect 文件恢复软件TestDisk http://www.cgsecurity.org/wiki/下载_TestDisk下载 Mac OS X Intel 的版本。 解压软件 终端进入软件目录， 运行./photorec 进入界面后上下键 选择 磁盘， 左右键选择下方的 search 按钮进行搜索 选择磁盘系统的类型 选择恢复文件存储的目录。 按C键开始恢复。 Mac下 罗技G602无线鼠标驱动下载 http://support.logitech.com.cn/zh_cn/product/g602-wireless-gaming-mouse#imagegallery http://support.logitech.com.cn/zh_cn/product/g602-wireless-gaming-mouse/downloads 解压工具 7z : brew install p7zip ~ brew search 7z ~ brew install p7zip Downloading https://homebrew.bintray.com/bottles/p7zip-16.02.high_sierra.bot ######################################################################## 100.0% ==> Pouring p7zip-16.02.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/p7zip/16.02: 103 files, 4.7MB // 解压命令 解压 演讲稿.7z 7z e 演讲稿.7z typora: Markdown编辑器 https://www.typora.io/这个 Mac、Windows 都有，可以显示编辑软件，下载相应版本后安装就可以了。 这个编辑器的好处是可以显示 [TOC]目录结构在左边，方便预览查看。详细介绍： https://www.jianshu.com/p/5256ecc06eec 注意下载安装更新科学上网速度快，否则下载速度很慢。 PS6 安装 软件下载： https://pan.baidu.com/s/1boZWCzHhttps://pan.baidu.com/s/1boZWCzH 安装 断开网络。 双击安装程序，选择试用(try)，然后点击安装。 在应用程序文件夹里面找到PS6，右键显示包内容(show package content), 然后找到contents/framework文件夹，把amtlib.framework文件拷贝到里面，OK。 参考链接： https://www.jianshu.com/p/097353202b66 gif截图工具：Gifox 下载地址：https://gifox.io/， 也可以在 App Store中搜索Gifox来下载。 该软件是收费的，不过有免费版的，经过使用，发现免费版最多录制10秒，不知道是不是由于是免费的原因。 还可以使用QQ的截图，里面有录屏然后转成gif就可以。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/002-Mac系统操作习惯设置.html":{"url":"doc/mac/002-Mac系统操作习惯设置.html","title":"Mac系统操作习惯设置","keywords":"","body":" 一、finder与文件相关操作 1、finder 进入特定目录 2、finder中标题栏显示全路径 3、.DS_Store文件(禁止自动生成、删除、取消禁止生成) 4、把应用程序图标放在finder上 5、一次性修改finder文件夹显示选项 二、Mac系统相关 1. 鼠标、处模板相关 1.1 鼠标滚轮跟windos统一 1.2 处模板设置三指选则文本 2. mac关闭开机声音 3. app Store相关 3.1 关闭自动更新app Store 3.2 删除正在从app store下载的应用程序 4. 右上角顶级菜单中图标管理 4.1. 图标顺序管理 4.2. 删除无用的图标 5. 完全删除garageband音乐创作软件 6. 隐藏docker中正在运行的应用图标 7. Dashboard 8. 应用程序安装目录 9. 创建应用程序快捷方式 10. 读写mac格式的移动硬盘（去掉写入权限提示） 11. 系统桌面背景图片位置 12. 去掉屏幕右上角的用户名 13. finder中显示与隐藏文件 14. 英文输入时，单词首字母自动大写关闭 15. 使用Mail绑定outlook邮箱 15.1 Mail设置邮件到一个文件夹中 16. 开启任何来源选项:允许第三方软件运行 三. Mac下一些软件配置 3.1. ShadowSocks 自定义代理规则 ssh远程连接mac Mac下的 tree 命令 终端展示你的目录树结构 Mac 了解应用安装后占用的磁盘空间 App最喜欢的几个目录 ~/Library/Application Support ~/Library/Preferences ~/Library/Containers ~/Library/LaunchAgents 腾讯视频.app应用下载的视频存放位置 return home [TOC] OS X EI Capitan Version 10.11.6 (15G31) 一、finder与文件相关操作 1、finder 进入特定目录 finder左上角的菜单中 finder -> 前往(go) -> 前往文件夹(go to folder)，输入路径即可：![](https://bitbucket.org/repo/oE6yEX/images/614659939-WX20170320-132530.png) 2、finder中标题栏显示全路径 打开终端输入如下命令： // finder中标题栏显示全路径 ~ defaults write com.apple.finder _FXShowPosixPathInTitle -bool TRUE;killall Finder // finder中标题栏只显示文件夹名字 ~ defaults delete com.apple.finder _FXShowPosixPathInTitle;killall Finder ![](https://bitbucket.org/repo/oE6yEX/images/3179645349-WX20180209.png) 3、.DS_Store文件(禁止自动生成、删除、取消禁止生成) .DS_Store是Mac OS保存文件夹的自定义属性的隐藏文件，如文件的图标位置或背景色，相当于Windows的desktop.ini。 3.1. 禁止 .DS_Store 生成 打开 “终端” ，复制黏贴下面的命令，回车执行，重启Mac即可生效。 defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE 3.2. 恢复 .DS_Store 生成 终端输入下面命令： defaults delete com.apple.desktopservices DSDontWriteNetworkStores 3.3. 删除所有的 .DS_Store 文件 在terminal中输入以下代码，可以删除所有.DS_Store文件 sudo find / -name \".DS_Store\" -depth -exec rm {} \\; # 命令在10.14.2系统中，已经失效 sudo find / -name .DS_Store -exec rm {} + 3.4. 上面命令不管用，安装 App 解决 .DS_Store 污染问题 安装 Asepsis (https://asepsis.binaryage.com/) 可以解决这个问题，不过该 App 目前不开发了。ASEPSIS 会把所有的.DS_Store重定向到 /usr/local/.dscage 内。 4、把应用程序图标放在finder上 按住 cmd键，鼠标拖动应用即可。 5、一次性修改finder文件夹显示选项 由于修改了Mac屏幕的分辨率，在打开finder查看文件的时候发现文件图标和文件名大小不合适了，需要修改。 在当前finder文件夹下，右上角的View -> show view options, 或者直接使用快捷键cmd + J来直接打开，在打开的界面中： Icon Size: 此选项是设置文件图标的大小，可选择适应的大小 Text Size:此选项是设置文件名字体大小的，选择对应的大小 Use as Defaults: （可能是）如果勾选了此选项则字文件夹及子文件夹内容都会应用此选项 此设置只在当前目录设置有效。如果想要所有目录都生效，则使用如下方式： 1、打开finder，连续使用快捷键Command + ↑方向箭头上，直到目录不在动为止，把目录切换到顶级目录(磁盘图标)，不要选择任何文件。 2、按Command + J或者点击工具栏的小齿轮，打开“查看显示选项(show view options)”； 3、在显示选项内调整好自己想要的效果，图标大小、文件名字体大小等。 4、打开终端，输入如下命令： sudo find / -name .DS_Store -exec rm {} + 注意此命令在MacOS 10.14.2系统版本中，已经失效。可试一下如下命令： sudo find / -name \".DS_Store\" -depth -exec rm {} \\; 此命令目的是删除所有文件夹下的.DS_Store文件，此文件会记录文件夹选项。 5、等待第 4 步完成后，点击屏幕左上角的小苹果图标选择“强制退出(Force Quit)”； 6、在强制退出应用程序窗口中选择“Finder”后点击“重新开启”即可完成。 参考资料：https://bbs.feng.com/mobile-news-read-0-688186.html 二、Mac系统相关 1. 鼠标、处模板相关 1.1 鼠标滚轮跟windos统一 首先打开左上角全局菜单中的“偏好设置” 然后在偏好设置中找到“鼠标”点击进去 最后在“鼠标”设置中把“滚动方向：自然”前面的勾去掉就和windows中一样了。 1.2 处模板设置三指选则文本 系统偏好设置-->辅助功能--->鼠标与触控板--->触控板选项 启用拖移 三指拖移 System Preferences -> Accessibility -> Mouse & Trackpad -> Trackpad Options -> 勾选 Enable Dragging -> 选择 three finger drag 注意：勾选此选项后，使用三指在触摸板上滑触发的Mission Control 就自动改成使用四指触发 2. mac关闭开机声音 # 打开终端 # 关闭声音 $ sudo nvram SystemAudioVolume=%80 # 如果想要恢复正常的开机生硬，只要在终端中再次输入如下命令即可： $ sudo nvram -d SystemAudioVolume 3. app Store相关 3.1 关闭自动更新app Store 用户必须先进入“系统偏好设置”，找到Mac app store。 点击进去之后就就能看到Mac App Store的更新设置，这个时候只需要把自动更新设置去掉即可。 3.2 删除正在从app store下载的应用程序 打开Launchpad, 点击一下正在下载的程序暂停。 Launchpad里面，按住option 这个按键，应用图标左上角就会出现X按钮，点击，会出现问你是否删除，点击删除， 完成 4. 右上角顶级菜单中图标管理 4.1. 图标顺序管理 按下Command然后用鼠标拖动图标即可调整顺序。 4.2. 删除无用的图标 搜狗输入法中有一个语音输入，导致在右上角有个 话筒的图标， 可在 搜狗输入法设置里把语音输入取消即可。 5. 完全删除garageband音乐创作软件 garageband是Mac下的制作音乐的软件，如果不用可以删除，需要的时候在下载。 删除软件后在磁盘管理还能看见这个软件的一些占用的空间，经过在网上查找资料，可用如下方法彻底删除。 终端下运行如下命令： rm -rf /Library/Application\\ Support/GarageBand rm -rf /Library/Application\\ Support/Logic rm -rf /Library/Audio/Apple\\ Loops Macintosh HD/Applications/GarageBand.app (1.16GB)Macintosh HD/Library/Application Support/GarageBand (995MB)Macintosh HD/Library/Application Support/Logic (880MB)Macintosh HD/Library/Audio/Apple Loops (up to 10GB)*xx 6. 隐藏docker中正在运行的应用图标 终端下进入该应用的目录中，使用sudo vi命令打开Info.plist // 进入APP目录 cd /Applications/ // 查看目录下安装的软件 ls // 假设你的软件名字是 YouAppName cd YouAppName/Contents // 编辑配置文件 vim Info.plist // 进入VIM编辑器 进入编辑器之后，找到的部分节点，插入下面红框内的内容 : LSUIElement 保存之后，退出相关程序，再次打开，DOCK栏上就没有这个软件的图标了。 参考链接:http://blog.csdn.net/fungleo/article/details/52262315 7. Dashboard 偏好设置 --> Mission Control --> Dashboard不是所有 Mac 上的工作都需要使用大型应用程式，有些简单的工作不妨让 [tiger] 上的新功能 Dashboard 来为您完成。只要按下一个键，半透明的 Dashboard 就会浮现在电脑桌面上，供您快速取用多种有趣又实用的迷你应用程式 widget。需要加减乘除吗？交给“计算机”widget 吧！想知道心爱的人所坐的班机飞到哪了吗？请看看 Flight Tracker widget。办公室没有窗户让您一窥外头的情况吗？打开 Weather widget 就知道现在窗外是什么天气。http://jingyan.baidu.com/article/066074d6910570c3c21cb0d9.html 8. 应用程序安装目录 硬盘名称(如macintoch HD) /Applications 硬盘点开就能看到一个叫应用程序的文件夹，直接安装或拖拽过去就可以了，http://jingyan.baidu.com/article/363872ecd5b8406e4aa16f5e.html 9. 创建应用程序快捷方式 在 Finder 中的应用程序中，找到想要创建快捷图标的应用程序 随后请先按住键盘上的 option+command 键 接着再把把想要在桌面上创建快捷方式的应用程序拖到桌面了，先松鼠标，当看到有一个快捷箭头以后再把 option+command 键松开。 当创建了快捷方式成功以后，会看到应用程序图标左下方有一个箭头标志 10. 读写mac格式的移动硬盘（去掉写入权限提示） 右键移动硬盘，最下面的 共享与权限，点开，把锁打开，然后把当前的用户添加上就可以写入的时候不用输入管理员密码了。 ![](https://bitbucket.org/repo/oE6yEX/images/1853902689-QQ20171220-001025.png) 11. 系统桌面背景图片位置 /Library/Desktop Pictures/ 12. 去掉屏幕右上角的用户名 系统偏好设置－－用户与群组－－左侧菜单栏选择登陆选项－－右侧“将快速用户切换菜单显示为...”左边的勾去掉就行了 system preferences -> user and groups -> login options，有一条show fast user switching menu as，有三个选项可以设置。不想要勾掉就好了 13. finder中显示与隐藏文件 使用快捷键：shift + command + . https://jingyan.baidu.com/article/d2b1d1027c6dc65c7e37d435.html defaults write com.apple.finder AppleShowAllFiles Yes && killall Finder //显示隐藏文件 defaults write com.apple.finder AppleShowAllFiles No && killall Finder //不显示隐藏文件 14. 英文输入时，单词首字母自动大写关闭 System Preferences -> Keyboard -> Text: Capitalize words automatically(去掉前面的对号即可) 15. 使用Mail绑定outlook邮箱 打开Mail， 左上角菜单中， mail -> add account(邮件 -> 添加账户) 选择 Exchange > 继续 输入Exchange账户的名称、电子邮件地址和密码 > 登陆 选择想要使用此账户Mac应用程序 单击完成 如果邮件程序不能自动设置您的帐户，请稍等几分钟或几小时，然后重复这些步骤。如果重复步骤之后，邮件仍不能自动设置帐户，请参阅本文中的我还需了解哪些信息？。 mac 支持 15.1 Mail设置邮件到一个文件夹中 https://jingyan.baidu.com/article/363872ec11d4046e4ba16fb2.html 1、 创建一个文件夹： 打开mail，鼠标移到邮箱(Mailboxes)右边出现一个加号，点击，输入一个名字后创建一个文件夹。 2、创建邮件规则： 中文版：菜单（邮件）→偏好设置→添加规则，根据实际需要建立规则就可以了。 英文版：右上角Mail -> Preferences -> 出现的弹窗中选择Rules -> Add Rule 16. 开启任何来源选项:允许第三方软件运行 Mac在macOS Sierra系统下，系统偏好设置中的“安全与隐私”默认已经去除了允许“任何来源”App的选项，如果不开启会直接影响到无法运行一些第三方应用。 查看是否开启 打开系统偏好设置 -> 点击“安全与隐私” -> 如果没有“任何来源”这个选项就是没有开启。 开启任何来源选项 打开终端, 输入下面命令： sudo spctl --master-disable 然后输入管理员密码后关闭终端，再次打开系统设置-> 安全与隐私 即可开启。 参考资料：https://jingyan.baidu.com/article/9f63fb9162e3e6c8400f0e30.html 三. Mac下一些软件配置 3.1. ShadowSocks 自定义代理规则 ShadowSocks 默认使用的是 adblock plus 的引擎，要想自己添加规则最好熟悉一下其规则，下面是ShadowSocks 的 pac 规则。 规则大概描述如下 通配符支持，如 *.example.com/* 实际书写时可省略 如 .example.com/ 意即 `.example.com/*` 正则表达式支持，以\\开始和结束， 如 \\[\\w]+:\\/\\/example.com\\ 例外规则 @@，如 @@*.example.com/* 满足@@后规则的地址不使用代理 匹配地址开始和结尾 |，如 |http://example.com、example.com| 分别表示以 http://example.com 开始和以 example.com结束的地址 || 标记，如 ||example.com 则 http://example.com 、https://example.com 、ftp://example.com 等地址均满足条件，只用于匹配地址开头 注释 ! 如 ! Comment 分隔符^，表示除了字母、数字或者 _ - . % 之外的任何字符。如 http://example.com^ ，http://example.com/ 和 http://example.com:8000/ 均满足条件，而 http://example.com.ar/ 不满足条件 如何使用自定义规则 点击ShadowSocks -> proxy Setting -> Edit User Rules For PAC 参考资料 https://adblockplus.org/zh_CN/filters ShadowSocks 自定义规则 ssh远程连接mac mac 默认安装了openssh。依次代开系统设置－－共享，把remote login勾上，选择允许的用户，就ok了在共享里面可以看见ssh命令，看这个命令就可以了。 终端无法使用小键盘 终端：偏好设置-->描述文件-->高级-->（去掉勾选）允许VT100应用程序小键盘模式 Mac下的 tree 命令 终端展示你的目录树结构 find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' 打开 bash 配置文件,把上面命令拷贝粘贴进去``` vi ~/.bash_profile 把下面命令复制到.bash_profile alias tree=\"find . -print | sed -e 's;/*/;|;g;s;|; |;g'\" 保存后执行下面命令 source .bash_profile 直接安装tree工具： ~ brew install tree ➜ /Users/zhangzhi/code/angular-phonecat git:(master) >brew install tree ==> Downloading http://mama.indstate.edu/users/ice/tree/src/tree-1.6.0.tgz Already downloaded: /Library/Caches/Homebrew/tree-1.6.0.tgz ==> make prefix=/usr/local/Cellar/tree/1.6.0 MANDIR=/usr/local/Cellar/tree/1.6.0/share/man/man1 CC=c 🍺 /usr/local/Cellar/tree/1.6.0: 7 files, 140K, built in 2 seconds 帮助查看 ~ tree --help ## Mac 了解应用安装后占用的磁盘空间 https://segmentfault.com/a/1190000005035742 ### App最喜欢的几个目录 Mac和Windows操作系统有一个很大的不同，大部分App是没有安装程序的，一般下载下来就是一个dmg文件， 解开之后直接将App拖到应用程序目录下就可以了，所以给人感觉卸载也就是将App拖到废纸篓然后清空。 如果真这样做就大错特错，即使一个最简单的App都会在下面几个目录中或多或少留下纪念，这些目录一般有： ~/Library ~/Library/Application Support ~/Library/Application Support/CrashReporter ~/Library/Caches ~/Library/Containers ~/Library/LaunchAgents ~/Library/Preferences ~/Library/PreferencePanes 如果一个程序是通过pkg方式安装，或者是在第一次运行时请求管理员权限，那一般还会在如下几个目录中留点纪念： /Library /Library/Application Support /Library/Extensions /Library/LaunchAgents /Library/LaunchDaemons /Library/PreferencePanes /Library/Preferences ``` 以上都还是只是列出了部分，不同的App由于需要还会在其他目录中安装一些文件，比如字处理软件一般会在/Library/Fonts下面安装字体，有些扩展组件会放在/Library/ScriptingAdditions下面。 ~/Library/Application Support 这个目录可以说是App最重要的文件目录，一些App本身并不大，但是需要的支持组件和内容非常多，特别是采用第三方插件和缓存网络内容的软件，例如我用的Dash，本身的大小只有24MB左右，但是由于经常浏览资料，所以缓存了很多网络内容，使得它的Support目录达到了1.37GB！可想而知，如果只是将App扔到废纸篓，几乎不会节省任何空间。 ~/Library/Preferences 这个目录下保存的是App设置，一般来说，稍微有点规模的软件都有自己的配置信息，放在这里的文件虽然占空间不多，但是清理掉还是有好处的，例如有些App不能正常工作，即使卸载重装也不行，往往就是配置文件出错了，把这里清理掉之后再重装就会有比较好的效果。 ~/Library/Containers 这个目录对于App Store上下载的软件来说，是最重要的一个目录，由于Apple的限制，AppStore的软件都在沙箱中运行，每个软件在沙箱都有自己的一个完整空间，对于App来说，它以为自己在一个正常的目录系统中运行，但实际上不是，操作系统重定位了读写位置到沙箱之中。要是卸载软件的时候，只是简单的在Launchpad中点一下叉来删除，那不知道又有多少空间莫名其妙地消失了，我曾经用这种方式卸载了网易云音乐，结果后来才发现，整整417MB的空间不见了…… ~/Library/LaunchAgents Mac上的随机启动方式之一，熟悉OS X操作系统的同学应该立刻想到了launchctl，这里就是存放启动配置文件的地方，大部分App只会往这里写启动信息，请神容易送神难，要送神，只有用第三方工具或是自己手动清理了，还有，LaunchAgents 和 LaunchDaemons 是有一些区别的，两者虽然都是随机启动， 腾讯视频.app应用下载的视频存放位置 /Users/*(用户名文件）/Library/Containers/com.tencent.tenvideo/Data/Library/Application Support/Download/video 里面视频是被分开截的，所以要用腾讯的播放器才能看，其他mac下播放器离线缓存视频同理只能用对应的播放器看。其他播放器（优酷、iqiyi等）路径也在Containers对应的播放器文件目录的/Data/Library/Application Support/Download/video里（也是被截成的片段） 删除视频的时候注意看看这里是否也被删除了。 powered by Gitbook文件最后修改时间： 2019-12-02 10:58:54 "},"doc/mac/003-Mac快捷键和一些常用操作.html":{"url":"doc/mac/003-Mac快捷键和一些常用操作.html","title":"Mac快捷键和一些常用操作","keywords":"","body":" 1. 睡眠重启关机 2. 一个应用多个窗口之间切换快捷键 3. 多个桌面切换快捷键 4. 全屏(变成一整个桌面)，退出全屏再按一次 5. 最小化应用 6. 应用窗口最大化(铺满屏幕) 同一个应用多个窗口切换 关闭窗口 退出应用 强制退出Mac程序 使用快捷键：Command+Option+Esc 使用终端命令强制退出程序 调整OS X系统窗口大小 浏览器快捷键 隐藏 ／显示Dock 删除文件快捷键 检测文件参数MD5、sha1、sha256 [TOC] Mac 官方快捷键地址： https://support.apple.com/zh-cn/HT201236 1. 睡眠重启关机 Ctrl+Shift+Power: 关闭屏幕Cmd+Opt+Power: 睡眠 (sleep)Cmd+Ctrl+Power: 重启 (restart)Cmd+Ctrl+Opt+Power: 关机 (shutdown) 2. 一个应用多个窗口之间切换快捷键 默认 cmd+` 就是程序内窗口切换。 触摸板手势：四指下滑（有些人用三指的） 3. 多个桌面切换快捷键 Control + 箭头 → ← 触摸板手势： 四指（三指）左右滑动 4. 全屏(变成一整个桌面)，退出全屏再按一次 Control-Command-F 5. 最小化应用 Command + M 6. 应用窗口最大化(铺满屏幕) 按住 Option 全屏按钮就会变为 + ， 点就是垂直最大化； 按住 shift+Opt 全屏按钮也会变为 + ， 点击就是最大化，而不是全屏； 同一个应用多个窗口切换 Command + ~(就是esc下面那个按键) 关闭窗口 Command + W 退出应用 Command + Q 强制退出Mac程序 使用快捷键：Command+Option+Esc 来打开“强制退出应用程序”的窗口，然后选中你需要退出的程序，再点右下方的“强制退出”即可。 使用终端命令强制退出程序 终端中输入命令killall [程序名称].比如说强制退出Safari，就输入 killall Safari 再回车即可，这样有关Safari的全部进程就都退出了；如果你想分的细一些，可以通过 ps 或者 ps aux 命令查找某些单独的进行，然后使用 kill -9 [pid] 来单独结束某个进程。很多情况下强制退出程序，之前的内容可能就会不在了，需要注意一下。 使用键盘快捷键强制退出处于活跃状态的Mac程序:快捷键：Command+Option+Shift+Esc , 这样按住一两秒钟，就可以强制退出当前程序了，算是最方便的一种方法。 http://www.cnbeta.com/articles/tech/175447.htm 调整OS X系统窗口大小 1.Option 键双向加宽，按着Option 键再一起拖曳窗口会变成往两边伸展。2.Shift 键放射状加大， shift把窗口长宽一起加大。3.在窗口顶部按两下，最大化窗口。 浏览器快捷键 cmd+1（2、3...）分别是打开书签栏的第一个、第二个...网址切换网页 ：Option + Command + 箭头 → ←从新打开关闭的标签： shift + command +T刷新网页： cmd + R 隐藏 ／显示Dock option + command + D 删除文件快捷键 Command + Delete(|\\上面的按键)：将某个项目直接删除至废纸篓。Shift + Command + Delete：清空废纸篓。Shift + option + Command + Delete：强制清空废纸篓（无警告）。 检测文件参数MD5、sha1、sha256 # 查看文件MD5： md5[空格][拖曳要检测的文件到此处] # 查看文件SHA1: openssl dgst -sha1[空格][拖曳要检测的文件到此处] # 查看文件SHA256： openssl dgst -sha256[空格][拖曳要检测的文件到此处] powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/004-Mac下终端常用设置、命令、快捷键.html":{"url":"doc/mac/004-Mac下终端常用设置、命令、快捷键.html","title":"Mac下终端常用设置、命令、快捷键","keywords":"","body":" 1. 介绍 2. 终端设置 2.1 修改mac终端命令行前缀的显示 2.2 修复终端hostname被篡改为bogon 2.3 终端shell与zsh之间的切换 2.4 设置终端使用命令打开vscode软件打开当前目录 3. 快捷键 3.1 终端光标做操快捷键 3.2 处理窗口和标签页快捷键 4. 终端常用操作 4.1 查看进程 4.2 查看端口号 4.3 终端使用代理 4.3.1 终端临时使用代理，只对这个终端有效，关闭后失效： 4.3.2 终端永久使用代理： 把代理服务器地址写入shell配置文件.bashrc或者.zshrc 4.4 终端进入名称带空格的目录 4.5 终端刷新DNS缓存 5. 终端一些命令安装 5.1 wget安装 5.2 tree命令安装 参考资料 [TOC] 1. 介绍 macos的很多用户都是做it相关的人，类unix系统带来了很多方面，尤其是经常和Linux打交道的人。 但是作为经常使用linux 命令行的人发现macos中的命令行工具很多都是bsd工具，跟linux下得使用方式开始差距挺大的 Max OS X使用的是 BSD版本的命令行工具，这些命令跟 Linux版本是有些不同的，然而它们都遵循 POSIX 标准。 资料： http://blog.csdn.net/orangleliu/article/details/47357339 2. 终端设置 2.1 修改mac终端命令行前缀的显示 /etc/bashrc 中的PS1变量就是用来设置前缀显示的。 终端打开/etc/bashrc文件： sudo vim /etc/bashrc 修改PS1变量，例如修改为如下形式(把原来的注释掉： # PS1='\\h:\\W \\u\\$ ' PS1='\\u\\$ ' wq!保存并退出，将终端退出重新打开生效。 变量代表的含义 \\h表示本地主机名 \\W表示符号~ \\u表示用户名 \\$表示符号$ 2.2 修复终端hostname被篡改为bogon 终端显示bogon原因： terminal显示hostname之前会先根据本机IP做一次rDNS反向查询，就是通过ip地址查询hostname，如果没有查询到，那么使用本机设置的hostname。本机IP通常是局域网IP地址（保留IP地址），一般是查不到的，所以terminal一般显示的本机设置的hostname，比如laowang's-macbook。 上面提到，局域网IP地址一般是查不到hostname，是因为ISP提供商或者用户防火窗的屏蔽保留IP地址，因为保留IP地址在公网中没啥用，即便是没有被屏蔽掉，rDNS服务器一般也会关闭响应保留IP地址的查询请求。凡事都有例外，rDNS服务器对这种保留IP地址对查询一律返回bogon。在ipv4对地址划分中，除了公网分配在用对IP地址外，其余保留IP地址统一叫做bogon space 解决方法： 将DNS设置为Google的DNS服务器地址 8.8.8.8 终端输入如下命令： sudo hostname MBP sudo scutil --set LocalHostName $(hostname) sudo scutil --set HostName $(hostname) 注：上面MBP就是你想要修改的新名字。 2.3 终端shell与zsh之间的切换 # 切换默认Shell为Zsh, 成功后需要重启终端 ~ chsh -s /bin/zsh # 切换Zsh为Shell， 成功后需要重启终端 ~ chsh -s /bin/bash # 查看zsh配置的环境变量： ~ cat ~/.zshrc 2.4 设置终端使用命令打开vscode软件打开当前目录 1、找到打开软件的路径： 打开finder -> Applications(应用程序) -> 找到 vscode，右键，选择Show Package Contents(显示包内容) ….,一级一级的找下去，最终的文件类似于如下： /Applications/Visual Studio Code.app/Contents/Resources/app/bin/code 2、打开终端，进入用户根目录： cd // 或者 cd ~ // 找到.zshrc文件 la -al 3、打开.zshrc文件，在文件的末尾添加如下命令： // 终端使用 code . 命令使用vscode打开当前目录 alias code='/Applications/Visual\\ Studio\\ Code.app/Contents/Resources/app/bin/code' 4、重启终端后，终端打开一个项目文件，使用code .即可使用vscode打开项目。 3. 快捷键 control + L // 终端清屏，相当于 clear命令 open 文件名 // 使用默认程序打开文件 如 open . 使用finder打开该目录 3.1 终端光标做操快捷键 Mac Terminal终端和Linux上终端光标的快捷键操作是一样的，都是来自Emacs这个神级的编辑器,跟VIM不一样。 Ctrl + a 光标移动到行首（Ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（End of line） Alt+← 或 ESC+B：左移一个单词； Alt+→ 或 ESC+F：右移一个单词； Ctrl + d 删除一个字符，相当于通常的Delete键（命令行若无所有字符，则相当于exit；处理多行标准输入时也表示eof） Ctrl + h 退格删除一个字符，相当于通常的Backspace键 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标之前到行尾的字符 Ctrl + c 取消当前行输入的命令，相当于Ctrl + Break Ctrl + f 光标向前(Forward)移动一个字符位置 Ctrl + b 光标往回(Backward)移动一个字符位置 Ctrl + l 清屏，相当于执行clear命令 Ctrl + p 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl + n 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 Ctrl + r 显示：号提示，根据用户输入查找相关历史命令（reverse-i-search） 次常用快捷键： Alt + f 光标向前（Forward）移动到下一个单词 Alt + b 光标往回（Backward）移动到前一个单词 Ctrl + w 删除从光标位置前到当前所处单词（Word）的开头 Alt + d 删除从光标位置到当前所处单词的末尾 Ctrl + y 粘贴最后一次被删除的单词 3.2 处理窗口和标签页快捷键 操作 快捷键 新建窗口 Command-N 使用相同命令新建窗口 Control-Command-N 新建标签页 Command-T 使用相同命令新建标签页 Control-Command-T 显示或隐藏标签页栏 Shift-Command-T 显示所有标签页或退出标签页概览 Shift-Command-反斜杠 () 新建命令 Shift-Command-N 新建远程连接 Shift-Command-K 显示或隐藏检查器 Command-I 编辑标题 Shift-Command-I 编辑背景颜色 Option-Command-I 放大字体 Command-加号键 (+) 缩小字体 Command-减号键 (–) 下一个窗口 Command-重音符键 (`) 上一个窗口 Command-Shift-波浪符号 (~) 下一个标签页 Control-Tab 上一个标签页 Control-Shift-Tab 将窗口拆分为两个面板 Command-D 关闭拆分面板 Shift-Command-D 关闭标签页 Command-W 关闭窗口 Shift-Command-W 关闭其他标签页 Option-Command-W 全部关闭 Option-Shift-Command-W 滚动到顶部 Command-Home 滚动到底部 Command-End 上一页 Command-Page Up 下一页 Command-Page Down 上一行 Option-Command-Page Up 下一行 Option-Command-Page Down 4. 终端常用操作 4.1 查看进程 # 搜索特定进程， ~ ps aux|grep 进程名字 # 动态显示进程 ~ top 4.2 查看端口号 # 搜索端口号为8080, 可以看见进程名字与ID lsof -i:8080 # 查看IPv4端口：(最好加 sudo) ~ lsof -Pnl +M -i4 # 查看IPv6协议下的端口 lsof -Pnl +M -i6 ~ sudo netstat antup 参考链接： http://blog.csdn.net/u011619283/article/details/53116291http://blog.csdn.net/winkenjiang/article/details/7588658 4.3 终端使用代理 4.3.1 终端临时使用代理，只对这个终端有效，关闭后失效： export http_proxy=http://proxyAddress:port export http_proxy=\"http://127.0.0.1:1080\" export https_proxy=\"http://127.0.0.1:1080\" 这个办法的好处是简单直接，并且影响面很小（只对当前终端有效）。 4.3.2 终端永久使用代理： 把代理服务器地址写入shell配置文件.bashrc或者.zshrc 直接在.bashrc或者.zshrc添加下面内容: # vi ~/.ashrc export http_proxy=\"http://localhost:port\" export https_proxy=\"http://localhost:port\" # 以使用shadowsocks代理为例，ss的代理端口为1080,那么应该设置为： export http_proxy=\"http://127.0.0.1:1080\" export https_proxy=\"http://127.0.0.1:1080\" localhost就是一个域名，域名默认指向 127.0.0.1，两者是一样的。然后ESC后:wq保存文件，接着在终端中执行source ~/.bashrc或者退出当前终端再起一个终端。 这个办法的好处是把代理服务器永久保存了，下次就可以直接用了。 4.4 终端进入名称带空格的目录 可使用\\ ' ' \" \" 将空格转义就可以了。 1. cd Appications/Android\\ Studio.app/sdk 2. cd Appications/Android' 'Studio.app/sdk 3. cd Appications/Android\" \"Studio.app/sdk 4.5 终端刷新DNS缓存 sudo killall -HUP mDNSResponder 5. 终端一些命令安装 5.1 wget安装 wget是unix上一个发送网络请求的命令工具，不过mac本身并没有，mac自带的是curl，都是发送网络请求，但是两者之间肯定存在一些差异。一般来说，wget主要专注于下载文件，curl长项在于web交互、调试网页等。 需要使用homebrew进行安装，如果没安装请先安装这个 终端安装wget命令： brew install wget --with-libressl ==> Installing dependencies for wget: libunistring, libidn2 and openssl ==> Installing wget dependency: libunistring ==> Downloading https://homebrew.bintray.com/bottles/libunistring-0.9.10.high_si ######################################################################## 100.0% ==> Pouring libunistring-0.9.10.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/libunistring/0.9.10: 54 files, 4.4MB ==> Installing wget dependency: libidn2 ==> Downloading https://homebrew.bintray.com/bottles/libidn2-2.0.5.high_sierra.b ######################################################################## 100.0% ==> Pouring libidn2-2.0.5.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/libidn2/2.0.5: 68 files, 668.6KB ==> Installing wget dependency: openssl ==> Downloading https://homebrew.bintray.com/bottles/openssl-1.0.2q.high_sierra. ######################################################################## 100.0% ==> Pouring openssl-1.0.2q.high_sierra.bottle.tar.gz ==> Caveats A CA file has been bootstrapped using certificates from the SystemRoots keychain. To add additional certificates (e.g. the certificates added in the System keychain), place .pem files in /usr/local/etc/openssl/certs and run /usr/local/opt/openssl/bin/c_rehash openssl is keg-only, which means it was not symlinked into /usr/local, because Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries. If you need to have openssl first in your PATH run: echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' >> ~/.zshrc For compilers to find openssl you may need to set: export LDFLAGS=\"-L/usr/local/opt/openssl/lib\" export CPPFLAGS=\"-I/usr/local/opt/openssl/include\" ==> Summary 🍺 /usr/local/Cellar/openssl/1.0.2q: 1,794 files, 12.1MB Warning: wget: this formula has no --with-libressl option so it will be ignored! ==> Installing wget ==> Downloading https://homebrew.bintray.com/bottles/wget-1.20.high_sierra.bottl ######################################################################## 100.0% ==> Pouring wget-1.20.high_sierra.bottle.tar.gz 🍺 /usr/local/Cellar/wget/1.20: 50 files, 3.9MB ==> Caveats ==> openssl A CA file has been bootstrapped using certificates from the SystemRoots keychain. To add additional certificates (e.g. the certificates added in the System keychain), place .pem files in /usr/local/etc/openssl/certs and run /usr/local/opt/openssl/bin/c_rehash openssl is keg-only, which means it was not symlinked into /usr/local, because Apple has deprecated use of OpenSSL in favor of its own TLS and crypto libraries. If you need to have openssl first in your PATH run: echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' >> ~/.zshrc For compilers to find openssl you may need to set: export LDFLAGS=\"-L/usr/local/opt/openssl/lib\" export CPPFLAGS=\"-I/usr/local/opt/openssl/include\" ➜ ~ ~ wget --version GNU Wget 1.20 built on darwin17.7.0. 参考资料：https://www.jianshu.com/p/f6b290710262 5.2 tree命令安装 tree命令用来在终端下显示目录树结构，在Mac下默认是没有安装该命令的。 需要使用终端使用brew命令来安装tree： brew install tree ==> Downloading http://mama.indstate.edu/users/ice/tree/src/tree-1.7.0.tgz Already downloaded: /Library/Caches/Homebrew/tree-1.7.0.tgz ==> make prefix=/usr/local/Cellar/tree/1.7.0 MANDIR=/usr/local/Cellar/tree/1.7.0/share/man/man1 CC=c 🍺 /usr/local/Cellar/tree/1.7.0: 7 files, 140K, built in 2 seconds 安装后可使用tree --help来查看使用帮助。 在使用过程中，如果目录中有中文文件，会显示乱码，可使用tree -N命令来解决。 参考资料 “终端”键盘快捷键 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/005-Mac下Iterm2使用及快捷键.html":{"url":"doc/mac/005-Mac下Iterm2使用及快捷键.html","title":"Mac下Iterm2使用及快捷键","keywords":"","body":" 1. 光标控制 2. 终端操作快捷键 2.1 窗口面板管理：一个窗口分割 2.2 新建Tab标签页 2.3 多个窗口操作 2.4 其他功能 2.4.1 粘贴历史 2.4.2 即时回放 2.5 自定义快捷键设置 2.5.1设置光标按照单词快速移动 3. 个性化的设置 3.1 设置无分栏边框 3.2 终端显示边框 3.2 显示、隐藏终端快捷键 3.3 鼠标移动切换窗口 3.4 设置光标形状 3.5 新窗口打开的路径跟当前终端的路径一直 3.6 新窗口在电脑获取焦点的窗口生成 3.7 设置开机启动不显示界面 参考资料 [TOC] 1. 光标控制 ctrl + a: 到行首 ctrl + e: 行末 ctrl + f/b: 前进后退，相当于左右方向键，但是显然比移开手按方向键更快 ctrl + p: 上一条命令，相当于方向键上 ctrl + r: 搜索命令历史，这个大家都应该很熟悉了 ctrl + d: 删除当前字符 ctrl + h: 删除之前的字符 ctrl + w: 删除光标前的单词 ctrl + k: 删除到文本末尾 ctrl + t: 交换光标处文本 ⌘ + —/+/0: 调整字体大小 ⌘ + r:清屏，其实是滚到新的一屏，并没有清空。ctrl + l 也可以做到。 2. 终端操作快捷键 2.1 窗口面板管理：一个窗口分割 垂直分割: Command + D 水平分割: Shift + Command + D 前一个面板: Command + [ 或 Option + Command + 左右方向键 后一个面板: Command + ] 切换到上/下/左/右面板: Option + Command + 上下左右方向键 关闭panel：⌘ + w 最大化Tab中的pane，隐藏本Tab中的其他pane：⌘+ shift +enter , 再次还原 2.2 新建Tab标签页 新建标签页: Command + T 关闭标签页: Command + W 前一个标签页: Command + 左方向键，Shift + Command + [ 后一个标签页: Command + 右方向键，Shitf + Command + ] 进入标签页1，2，3…: Command + 标签页编号 Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页） 窗口太多，可以使用 ⌘ + / 快速定位到光标所在位置 2.3 多个窗口操作 新建窗口：command + N 关闭窗口： command + w 前一个窗口：command + ` 后一个窗口：Shitf + command + ` 进入窗口 1,2,3：option + command + 编号 2.4 其他功能 支持自定义全局快捷键用于显示和隐藏iTerm2 Preference -> Keys －> Show/hide iTerm2 with a system-wide hotkey 打上勾之后 进入和退出全屏: Command + Enter 查看当前终端中光标的位置: Command + / 命令自动补全: Command + ;（很少用这个，还是感觉Zsh的补全更好用） 开启和关闭背景半透明: Command + u 清屏（重置当前终端）: Command + r 2.4.1 粘贴历史 使用Command + Shift + h 可以呼出粘贴历史，支持模糊检索。还可以设置将粘贴历史保存在磁盘上（Preferences -> General） 2.4.2 即时回放 使用Command + Opt + b 打开即时回放，按Esc退出。即时回放可以记录终端输出的状态，让你“穿越时间”查看终端内容。默认每个会话最多储存4MB的内容，可以在设置中更改（Preferences -> Genernal -> Instant Replay）。 2.5 自定义快捷键设置 2.5.1设置光标按照单词快速移动 iTerm2之后，发现option+←和option+→这两组快捷键并不能实现光标按照单词快速移动， 在Mac自带的终端中是可以使用这两个快捷键的，经过查找和测试发现，需要重新配置相应的映射。iTerm2中将这两组快捷键用作了其他的功能。 打开iTerm2的Preferences设置 选择相应的Profile（默认为Default），选择“Keys”选项卡，然后可以在Key Mappings看到option+←和option+→这两组快捷键用作了其他功能，这里我们只需要重新绑定新的映射即可 找到option+← ， 双击就会弹出一个编辑框，选择Action为“Send Escape Sequence”, 然后在 Esc+选项中输入b 找到option+→， 双击就会弹出一个编辑框，选择Action为“Send Escape Sequence”, 然后在 Esc+选项中输入f 修改映射之后，再重新启动iTerm2就可以使用option+←和option+→来实现光标按单词快速移动了，非常方便。如果不想使用option+←和option+→这两个组合键的话，也可以自行添加新的Shortcut即可。 3. 个性化的设置 3.1 设置无分栏边框 preference->appearance： 取消：Show per-pane title bar with split panes 勾选：Hide scrollbars 3.2 终端显示边框 preference->appearance： 勾选：Show border around window 3.2 显示、隐藏终端快捷键 Preferences -> Keys -> Hotkey: 勾选： Show/hide iTerm2 with a system-wide hotkey 然后在下面的Hotkey里面填上F12， 这个F12可能被系统占用了，这修改系统的快捷键，或更换别的快捷键。 3.3 鼠标移动切换窗口 当一个终端打开了多个窗口，可以设置鼠标移动窗口时获取焦点 Preferences -> Pointer: 勾选：Focus follows mouse 3.4 设置光标形状 Preferences -> Profiles -> Profile Name -> Text -> Cursor 选择一个自己喜欢的样式 3.5 新窗口打开的路径跟当前终端的路径一直 Preferences -> Profiles -> General -> Working Directory -> reuse previous session's directory 3.6 新窗口在电脑获取焦点的窗口生成 Preferences -> Profiles -> General -> Window -> Settings for New Windows -> Screen 选择：No Preference 或者选择：Screen with Cursor（在鼠标的窗口） 3.7 设置开机启动不显示界面 1、打开系统设置(System Perferences) -> 用户与群组(User & groups) -> 登陆项(Login Items)， 点击加号，然后去应用程序里面找到Iterm2添加到启动项里面。 2、启动iterm2程序，打开一个窗口，然后手动点击关闭按钮，确保电脑右上角苹果图标右边是iTerm2,然后 按【Command】+【Shift】+【S】，保存名为No Window 3、打开一个iterm2终端界面，然后按cmd + ,打开iterm的设置界面，选择Arrangements，点击刚才保存的No Window， 然后点击Set Default。 4、在iterm的设置界面选择General, 在Startup中选择Open Default Window Arrangement。 参考资料：https://blog.csdn.net/weixin_34023863/article/details/85958226 参考资料 iterm2使用快捷键 关于iTerm2 你不知道的一些事 Mac下iTerm2光标按照单词快速移动设置 打造有情怀的 iTerm2 终端 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/006-Mac中常见错误以及处理方法.html":{"url":"doc/mac/006-Mac中常见错误以及处理方法.html","title":"Mac中常见错误以及处理方法","keywords":"","body":" The GitHub credentials in the macOS keychain may be invalid. ftp Received unexpected end-of-file from SFTP server 键盘大小写切换灯不亮，但是可以切换大小写 [TOC] The GitHub credentials in the macOS keychain may be invalid. 错误信息： 解决方法： # https://github.com/Homebrew/brew/issues/93 # 终端命令 ~ brew update # 这个命令执行时间有点长要耐心等待 ftp Received unexpected end-of-file from SFTP server https://superuser.com/questions/901992/filezilla-does-not-open-connection-putty-does https://www.digitalocean.com/community/questions/sftp-connection-error-received-unexpected-end-of-file-from-sftp-server 键盘大小写切换灯不亮，但是可以切换大小写 可能是QQ音乐播放器导致的，退出QQ音乐就好了。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/007-Mac下vscode编辑器设置.html":{"url":"doc/mac/007-Mac下vscode编辑器设置.html","title":"Mac下vscode编辑器设置","keywords":"","body":" 1. 配置设置 1.1 设置格式化缩进为2个空格 1.2 设置一类文件tab键为两个空格 1.2.1 设置当前文件缩进 1.3 关闭文件预览 1.4 react中可以使用emmet 1.5 关闭右侧缩略图（预览面板） 1.6 编辑区域面板拆分 1.7 前端vue相关配置 1.7.1 设置.vue文件HTML模板中emmet支持vue特有的标签 1.8 关闭点击对应文件是，资源管理器自动定位到该文件 1.9 标题栏显示文档全路径 1.10 关闭编辑器的预览，免得打开新文件胡替换老的文件 1.11 设置鼠标双击才打开文件 1.12 编辑器tab标签下面显示打开文件的导航 1.13 编辑器文字超出了编辑器可视区域，是否自动在下一行显示 1.14 修改vscode上终端的字体大小 1.15 添加代码片段snippets 2. 快捷键设置 2.1 复制一行快捷键自定义：command + D 2.2 格式化代码快捷键： option + cmd + L 2.3 格式化选中的代码快捷键：cmd + L 2.4 删除一行快捷键： command + delete 2.5 将选择添加到下一个查找匹配项(Add Selection To Next Find Match) 2.6 切换编辑器组布局(垂直/水平): option + cmd + 数字零 2.7 当前行向上移动一行： option + 向上箭头 2.8 当前行向下移动一行： option + 向下箭头 2.9 当前行缩进 2.10 减少行缩进 3. vscode一些快捷操作 3.1 变量重命名：选中后按F2 4. vscode的一些插件 4.0 适用于 VS Code 的中文（简体）语言包 4.1 Beautify ：代码变得非常好看的格式 4.1.1 Beautify css/sass/scss/less CSS格式化插件 4.2 GitLens supercharges : 显示每行代码GIT的提交记录 4.3 CSS Peek：追踪至样式表中 CSS 类和 ids 定义的地方 4.4 color info: css中颜色的其他写法 4.5 Document This：自动为TSc和JS文件生成详细的JSDoc注释 4.6 vscode-icons:资源树目录加上图标 4.7 Auto Rename Tag:修改标签名称的时候自动修改结束标签 4.8 open native terminal : 在右键菜单中添加打开终端 4.9 console-snippets: console.log快捷插件 4.10 Turbo Console Log: 选中变量快捷添加console.log 4.11 Vim：让vscode像vim中一样使用命令 4.12 Bookmarks：添加标签，快速定位标记的代码 4.13 Bracket Pair Colorizer:代码的各种括号呈现不同的颜色 4.14 ESLint: JavaScript代码格式化检查插件 4.15 对 webpack 别名路径或者自定义别名路径进行快速跳转的插件 4.16 计算引入包的大小 4.17 设置tab强调色 4.18 代码缩进着色 4.19 Settings Sync: 同步vscode设置及扩展配置 5. VUE框架相关的插件 5.1 vetur：语法高亮插件 5.2 Vue VSCode Snippets: vue模板 6. 使用vscode遇到的问题 6.1 html文件使用快捷键注释不对 6.2 保存时，自动把var变量改成了let 其他插件资料 目录 [TOC] 1. 配置设置 打开配置文件：vscode菜单： Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件。 1.1 设置格式化缩进为2个空格 // 一个tab为2个空格 // 如果设置了editor.detectIndentation = true 则会根据根据文件内容进行重写。 \"editor.tabSize\": 2, // 2018-10-20 关闭检测缩进，设置后代码格式化时就会自动变成2个空格了 \"editor.detectIndentation\": false, // 按tab键会变成插入空格 \"editor.insertSpaces\": true, 1.2 设置一类文件tab键为两个空格 // 2018-10-20 关闭检测缩进，设置后代码格式化时就会自动变成2个空格了 \"editor.detectIndentation\": false, // 设置tab键的空格数量为2 \"[html]\": { \"editor.tabSize\": 2 }, \"[css]\": { \"editor.tabSize\": 2 }, \"[javascript]\": { // 按 \"Tab\" 时插入空格。该设置在 `editor.detectIndentation` 启用时根据文件内容进行重写。 \"editor.insertSpaces\": true, // 一个制表符等于的空格数。该设置在 `editor.detectIndentation` 启用时根据文件内容进行重写。 \"editor.tabSize\": 2 }, \"[typescript]\": { \"editor.tabSize\": 2 }, https://blog.csdn.net/example440982/article/details/81543096?utm_source=blogxgwz1 1.2.1 设置当前文件缩进 https://blog.csdn.net/qq_34446663/article/details/88184680 1、点击文件右下角的Tab Size:，会出现一个选择框。 2、点击Indent Using Tabs 3、根据需求，选择自己需要的缩进 1.3 关闭文件预览 单击文件名的缘故，这个是“预览模式”，所以再单击其他文件时，会覆盖当前打开的文件。 预览模式是现在各类编辑器的默认功能，如果你实在不喜欢，可以关掉的,给你配置settings.json里加一条： \"workbench.editor.enablePreview\": false, 1.4 react中可以使用emmet 在配置文件中加入下面代码： \"emmet.syntaxProfiles\": { \"javascript\": \"jsx\" }, 1.5 关闭右侧缩略图（预览面板） 设置里面搜索 \"editor.minimap.enabled\"，设置为false即可。 配置文件中： // Controls if the minimap is shown 关闭右侧缩略图（预览面板） \"editor.minimap.enabled\": false, 1.6 编辑区域面板拆分 右上角 View -> Editor Layout -> 即可选择编辑区域拆分 还可以点击编辑器右上角的拆分按钮，默认垂直拆分， 键盘按住alt键，然后点击此时可水平拆分。 1.7 前端vue相关配置 1.7.1 设置.vue文件HTML模板中emmet支持vue特有的标签 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件。 // 2018-07-17 设置VUE在.vue的模板HTML中vue标签也可以使用emmet // 启用后，按下 TAB 键，将展开 Emmet 缩写。 \"emmet.triggerExpansionOnTab\": true, // vscode 1.25.1版本以后不写下面的配置也会生效，旧版本可能需要 \"emmet.includeLanguages\": { \"vue-html\": \"html\", \"vue\": \"html\" }, 1.8 关闭点击对应文件是，资源管理器自动定位到该文件 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件 // 控制资源管理器是否应在打开文件时自动进行显示并选择。 \"explorer.autoReveal\": false, 1.9 标题栏显示文档全路径 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： \"window.title\": \"${activeEditorLong}${separator}${rootName}\" activeEditorMedium:相对于工作区文件夹的文件路径 (如 myFolder/myFile.txt)。 activeEditorLong:文件的完整路径 (如 /Users/Development/myProject/myFolder/myFile.txt)。 1.10 关闭编辑器的预览，免得打开新文件胡替换老的文件 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： // 控制打开的编辑器是否显示为预览。预览编辑器可以重新使用，直到将其保留(例如，双击或编辑)。 \"workbench.editor.enablePreview\": false, 1.11 设置鼠标双击才打开文件 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： \"workbench.list.openMode\": \"doubleClick\", 如果想改回单击打开文件，可改回参数：singleClick, 设置双击打开文件后，预览模式就不需要在设置了。 1.12 编辑器tab标签下面显示打开文件的导航 View -> toggle breadcrumbs 1.13 编辑器文字超出了编辑器可视区域，是否自动在下一行显示 Code -> Preferences -> Settings(快捷键command + ，)，打开配置文件： // Controls how lines should wrap. // - off: Lines will never wrap. // - on: Lines will wrap at the viewport width. // - wordWrapColumn: Lines will wrap at `editor.wordWrapColumn`. // - bounded: Lines will wrap at the minimum of viewport and `editor.wordWrapColumn`. \"editor.wordWrap\": \"off\", 1.14 修改vscode上终端的字体大小 1、使用cmd + ,打开设置页面，或者屏幕左上角 code -> 首选项 -> 设置。 2、搜索终端，或者 功能 -> 终端。 3、找到Integrated: Font Size，控制终端的字号，设置成自己想要的字体大小即可。 1.15 添加代码片段snippets https://www.jianshu.com/p/1f1132df1def https://segmentfault.com/a/1190000018457312 File > Preferences (Code > Preferences on macOS)` 中选择 `User Snippets windows系统: File > Preferences > User Snippets， Mac系统：Code > Preferences > User Snippets 在出现的弹窗中，选择New Global Snippets file新建一个全局的代码，或者选择一个已经存在的代码片段继续编辑 vscode代码片段存放路径 /Users/用户名/Library/Application Support/Code/User/snippets/tt.code-snippets 例如：/Users/dragon/Library/Application Support/Code/User/snippets/tt.code-snippets 2. 快捷键设置 打开快捷键界面和快速找到想要修改的快捷键 打开快捷键页面： vscode菜单： Code -> Preferences -> Keyboard Shortcuts , 打开快捷键界面。 快速找到要修改的快捷键 在搜索中输入相关关键词 查看快捷键是否已经被占用 在搜索中输入快捷键： 比如想要查看'cmd + /'快捷键是否已经被占用，则在搜索框中输入：\"cmd + /\" 如果有结果就说明该快捷键已经被占用了 shift、control(ctrl)、option(alt)、command(cmd) 2.1 复制一行快捷键自定义：command + D 在搜索框中输入： copy, 找到Copy Line Down向下复制一行快捷键，修改为自己习惯的快捷键：command + D。 2.2 格式化代码快捷键： option + cmd + L 在搜索框中输入：format, 找到Format Document格式化文档，修改为自己的快捷键：control + alt + L，默认的快捷键：shift + alt + F. 2.3 格式化选中的代码快捷键：cmd + L 在搜索框中输入： formatSelection(格式化选定代码)， 可以修改成自己的快捷键 2.4 删除一行快捷键： command + delete 在搜索框中输入：delete, 找到Delete Line删除一行，修改为自己的快捷键：command + delete，默认的快捷键：shift + command + K. 2.5 将选择添加到下一个查找匹配项(Add Selection To Next Find Match) 在快捷键页面搜索框中输入：Add Selection To Next(将选择添加到下一个)事件的默认快捷键：cmd + D 2.6 切换编辑器组布局(垂直/水平): option + cmd + 数字零 关键字：toggleEditorGroupLayout 2.7 当前行向上移动一行： option + 向上箭头 关键字 ： moveLinesUpAction 2.8 当前行向下移动一行： option + 向下箭头 关键字： moveLinesDownAction 2.9 当前行缩进 关键字：indentLines 设置的快捷键: cmd + ] 2.10 减少行缩进 关键字：outdentLines 设置的快捷键： cmd + [ 3. vscode一些快捷操作 3.1 变量重命名：选中后按F2 可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。 4. vscode的一些插件 4.0 适用于 VS Code 的中文（简体）语言包 Chinese (Simplified) Language Pack for Visual Studio Code 安装后，在 locale.json 中添加 \"locale\": \"zh-cn\"，即可载入中文（简体）语言包。要修改 locale.json，你可以同时按下 Ctrl+Shift+P 打开命令面板，之后输入 \"config\" 筛选可用命令列表，最后选择配置语言命令。请参阅文档并获取更多信息。 4.1 Beautify ：代码变得非常好看的格式 它可以让你的html，javascript,json,CSS,Sacc 和 html 代码变得非常好看的格式 4.1.1 Beautify css/sass/scss/less CSS格式化插件 该插件安装后，可以格式化css/sass/scss/less后缀的CSS文件， 使用VSCODE默认的格式化快捷键即可实现快速格式化 https://marketplace.visualstudio.com/items?itemName=michelemelluso.code-beautifier 4.2 GitLens supercharges : 显示每行代码GIT的提交记录 这个插件安装好后在编辑器右上角会有几个按钮 (其中有一个类似git的图标) 4.3 CSS Peek：追踪至样式表中 CSS 类和 ids 定义的地方 使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。 CSS peek 4.4 color info: css中颜色的其他写法 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。 color info 4.5 Document This：自动为TSc和JS文件生成详细的JSDoc注释 “Document This”是一个Visual Studio代码扩展，可自动为TypeScript和JavaScript文件生成详细的JSDoc注释。 Document This 使用方法： 鼠标光标放在方法名前面。 按快捷键 Ctrl+Alt+D再按一次Ctrl+Alt+D，即可生成注释文档 4.6 vscode-icons:资源树目录加上图标 vscode-icons 安装手使用： Linux & Windows => File > Preferences > File Icon Theme > VSCode Icons. MacOS => Code > Preferences > File Icon Theme > VSCode Icons. 4.7 Auto Rename Tag:修改标签名称的时候自动修改结束标签 Auto Rename Tag，非常实用！要修改标签名称的时候自动修改结束标签，节省一半时间，提升效率，非常棒！ Auto Rename Tag 4.8 open native terminal : 在右键菜单中添加打开终端 这个插件可以很方便的直接在VSCODE中打开终端操作 open native terminal 4.9 console-snippets: console.log快捷插件 console-snippets cl or clog console.log() cwarn console.warn() cdir console.dir() ci console.info() cerr console.error() cg console.group() cge console.groupEnd() 4.10 Turbo Console Log: 选中变量快捷添加console.log Turbo Console Log 使用方法： 1，选中变量， 2 按快捷键： control + option + i 注释掉有插件创建的console： control + option + q 取消注释插件创建的console：control + option + u 删除由插件创建的console: control + option + d 注：此插件的创建console与我自己的快捷键冲突了，可打开vscode的快捷键设置， 然后搜索：Turbo Console Log ， 就会出现此插件相关的快捷键，选择冲突的快捷键修改别的快捷。 4.11 Vim：让vscode像vim中一样使用命令 Vim 4.12 Bookmarks：添加标签，快速定位标记的代码 Visual Studio中的Bookmark能加速代码导航能力。可能有一些代码，需要频繁的相互切换。通常你可能是滚动页面，找到该代码块的。Visual Studio已经提供了通过使用快捷键，非常快速地移动到指定的代码段。这就是代码的书签功能。 bookmarks 可设置快捷键，打开快捷键页面（code -> Preferences -> keyboards ShortCuts） 在里面输入bookmarks就能看见相关的快捷键设置: option + cmd + k:开启关闭标签 option + cmd + L:跳到下一个标签 option + cmd + k:跳到上一个标签 还可以在编辑器左边有个书签图标，可以点击在里面管理添加的书签。 可以选一个文件，然后右键店家clear清理所有标记的标签。 4.13 Bracket Pair Colorizer:代码的各种括号呈现不同的颜色 Bracket Pair Colorizer 让代码的各种括号呈现不同的颜色。 4.14 ESLint: JavaScript代码格式化检查插件 ESLint https://github.com/Microsoft/vscode-eslint 注意： 如果在配置文件中写了： \"eslint.autoFixOnSave\": true, 那么在保存文件的时候，会自动把代码格式化成符合eslint风格的代码，比如把var变量自动变成let 4.15 对 webpack 别名路径或者自定义别名路径进行快速跳转的插件 Jump To Alias File https://github.com/wanfu920/jumpToAliasFile 可以对 webpack 别名路径或者自定义别名路径进行快速跳转的插件. 默认webpack配置的alias可自动识别 如果没识别 可以在setting.json里配置webpeckConfigPath或者jumpToAliasFile.alias 4.16 计算引入包的大小 Import Cost 插件会在代码import一个包后计算该包的大小 4.17 设置tab强调色 Material Theme 插件安装好后，会修改vscode编辑器主题色，可以修改回原先的主题色。 修改打开标签页下划线颜色： 打开命令面板(cmd + shift + P)，输入Material，选择Material Theme: Set accent color，然后从出现的列表中选择一个颜色，它将更改选项卡的下划线颜色。 4.18 代码缩进着色 indent-rainbow 安装此插件后，代码的每级缩进都会有不同的颜色，便于区分代码块。 安装此插件即可，不需要进行任何配置。你也可以自己修改缩进的颜色，看介绍文档配置。 4.19 Settings Sync: 同步vscode设置及扩展配置 Settings Sync 实现同步的功能主要依赖于VSCode插件“Settings Sync”。它是基于 GitHub Tokens 和 GitHub Gist 功能实现，可以一键轻松实现上传下载跨多台机器同步设置、代码片段、主题、文件图标、启动、键绑定、工作区和扩展。 配置存在：https://gist.github.com/ https://segmentfault.com/a/1190000020894066 5. VUE框架相关的插件 5.1 vetur：语法高亮插件 5.2 Vue VSCode Snippets: vue模板 安装此插件后，在.vue文件中 输入vbase然后按tab键可以快速生成一个vue项目的模板。其他的请看文档 Vue VSCode Snippets 6. 使用vscode遇到的问题 6.1 html文件使用快捷键注释不对 当在HTML文件中，使用注释快捷键cmd + /，时注释的代码是下面这样子的： {# #} 这个是错误的。 1、首先查看编辑器右下角看看是不是HTML格式的，然后在看看配置等。 2、经过我的查找是由于使用了插件导致的，插件名字：TWIG pack,禁用这个插件后，再次使用快捷键注释就好了： --> 6.2 保存时，自动把var变量改成了let 在打开代码文件时，修改后，保存后，发现编辑器把var变量自动改成了let，导致旧浏览器出现了兼容性问题。 经过查询： 安装了eslint插件 在配置文件里面配置了\"eslint.autoFixOnSave\": true, 安装了eslint插件并配置了参数后， 在保存文件的时候，就会自动把不符合eslint格式的代码自动改成符合eslint要求的代码，所以就把var改成了let，导致了旧浏览器出现了兼容性问题。 解决方法： 在配置文件中注销或删除配置：\"eslint.autoFixOnSave\": true,即可。 其他插件资料 https://zhuanlan.zhihu.com/p/27905838 vscode 插件推荐 - 献给所有前端工程师 segmentfaul powered by Gitbook文件最后修改时间： 2019-12-24 17:42:13 "},"doc/mac/008-Mac下vscode快捷键.html":{"url":"doc/mac/008-Mac下vscode快捷键.html","title":"Mac下vscode快捷键","keywords":"","body":" 1. Mac 键盘符号说明 2. 常用 3. 基本编辑 4. 多光标和选择 5. 搜索和替换 6. 丰富的语言编辑 7. 导航 8. 编辑器管理 9. 文件管理 10. 显示 11. 调试 12. 集成终端 参考资料 [TOC] 1. Mac 键盘符号说明 ⌘ == Command ⇧ == Shift ⇪ == Caps Lock ⌥ == Option ⌃ == Control ↩ == Return/Enter ⌫ == Delete ⌦ == 向前删除键（Fn+Delete） ↑ == 上箭头 ↓ == 下箭头 ← == 左箭头 → == 右箭头 ⇞ == Page Up（Fn+↑） ⇟ == Page Down（Fn+↓） Home == Fn + ← End == Fn + → ⇥ == 右制表符（Tab键） ⇤ == 左制表符（Shift+Tab） ⎋ == Escape (Esc) ⏏ == 电源开关键 2. 常用 描述 Mac 快捷键 显示命令面板 ⇧⌘P, F1 快速打开 ⌘P 新建 窗口/实例 ⌘N(之前的：⇧⌘N) 关闭 窗口/实例 ⌘W 侧边栏开关 command + B 控制台开关 command + J 合并当前行 control + J 整个项目搜索内容 command + shift + F 创建分屏快捷键 command + \\ 3. 基本编辑 Mac 快捷键 介绍 ⌘X 剪切 ⌘C 复制 ⌥↓ / ⌥↑ 移动当前行向 下/上 ⇧⌥↓ / ⇧⌥↑ 复制当前行向 下/上 ⇧⌘K 删除当前行 ⌘Enter / ⇧⌘Enter 在下/上 插入一行 ⇧⌘\\ 跳转到匹配的括号 ⌘] / ⌘[ 向左/向右 缩进当前行 Home / End 跳到当前行的头部，尾部 ⌘↑ / ⌘↓ 跳到当前行的开始，结束 ⌃PgUp 滚动到 ⌃PgDown 滚动到行头/行尾 ⌘PgUp /⌘PgDown 滚动到页头/页尾 ⇧⌘[ / ⇧⌘] 折叠/展开区域 ⌘K ⌘[ / ⌘K ⌘] 折叠/展开所有子区域 ⌘K ⌘0 / ⌘K ⌘J 折叠/展开所有区域 ⌘K ⌘C 添加行注释 ⌘K ⌘U 删除行注释 ⌘/ 切换行注释 ⇧⌥A 切换块注释 ⌥Z 切换文字换行 4. 多光标和选择 Mac 快捷键 介绍 Alt+Click 插入光标 ⌥⌘↑ 在上面插入光标 ⌥⌘↓ 在下面插入光标 ⌘U 撤消上一个光标操作 ⇧⌥I 在所选每行的末尾插入光标 ⌘I 选择当前行 ⇧⌘L 选择当前选择的所有事件 ⌘F2 选择当前单词的所有出现 ⌃⇧⌘→ 展开选择 ⌃⇧⌘← 收缩选择 Shift+Alt + drag mouse（拖动鼠标） 列（框）选择 ⇧⌥⌘↑ 向上列（框）选择 ⇧⌥⌘↓ 向下列（框）选择 ⇧⌥⌘← 向左列（框）选择 ⇧⌥⌘→ 向右列（框）选择 ⇧⌥⌘PgUp 列（框）选择 向上一页 ⇧⌥⌘PgDown 列（框）选择 向下一页 5. 搜索和替换 Mac 快捷键 介绍 ⌘F 查找 ⌥⌘F 替换 ⌘G / ⇧⌘G 查找下一个/上一个 ⌥Enter 选择查找匹配的所有匹配项 ⌘D 将选择添加到下一个查找匹配 ⌘K ⌘D 将最后一个选择移至下一个查找匹配项 6. 丰富的语言编辑 Mac 快捷键 介绍 ⌃Space 触发建议 ⇧⌘Space 触发参数提示 Tab Emmet扩展缩写 ⇧⌥F 格式化文档 ⌘K ⌘F 格式选择 F12 转到定义 ⌥F12 Peek定义 ⌘K F12 打开定义到一边 ⌘. 快速修复 ⇧F12 显示引用 F2 重命名符号 ⇧⌘. / ⇧⌘, 替换为下一个/上一个值 ⌘K ⌘X 修剪尾随空格 ⌘K M 更改文件语言 7. 导航 Mac 快捷键 介绍 ⌘T 显示所有符号 ⌃G 转到行… ⌘P 转到文件… ⇧⌘O 转到符号… ⇧⌘M 显示问题“面板” F8 / ⇧F8 转到下一个/上一个错误或警告 ⌃⇧Tab 浏览编辑器组历史记录 ⌃- / ⌃⇧- 后退/前进 ⌃⇧M 切换选项卡移动焦点 8. 编辑器管理 Mac 快捷键 介绍 ⌘W 关闭编辑窗口 ⌘K F 关闭文件 ⌘\\ 拆分编辑窗口 ⌘1 / ⌘2 / ⌘3 聚焦到第1，第2，第3编辑器组中 ⌘K ⌘← / ⌘K ⌘→ 聚焦到上一个/下一个编辑器组 ⌘K ⇧⌘← / ⌘K ⇧⌘→ 向左/向右移动编辑器 ⌘K ← / ⌘K → 移动活动编辑器组 9. 文件管理 Mac 快捷键 介绍 ⌘N 新建文件 ⌘O 打开文件 ⌘S 保存 ⇧⌘S 保存为… ⌥⌘S 保存所有 ⌘W 关闭 ⌘K ⌘W 关闭所有 ⇧⌘T 重新打开已关闭的编辑器 ⌘K 输入保持打开 ⌃Tab / ⌃⇧ 选项卡打开下一个/上一个 ⌘K P 复制活动文件的路径 ⌘K R 在资源管理器中显示活动文件 ⌘K O 在新窗口/实例中显示活动文件 10. 显示 Mac 快捷键 介绍 ⌃⌘F 切换全屏 ⌥⌘1 切换编辑器布局 ⌘= / ⇧⌘- 放大/缩小 ⌘B 切换侧栏可见性 ⇧⌘E 显示资源管理器/切换焦点 ⇧⌘F 显示搜索 ⌃⇧G 显示Git ⇧⌘D 显示Debug ⇧⌘X 显示扩展名 ⇧⌘H 在文件中替换 ⇧⌘J 切换搜索详细信息 ⇧⌘C 打开新命令提示符/终端 ⇧⌘U 显示输出面板 ⇧⌘V 切换Markdown预览 ⌘K V 打开Markdown预览到一边 11. 调试 Mac 快捷键 介绍 F9 切换断点 F5 开始/继续 F11 / ⇧F11 跳进/出 F10 跳过 ⇧F5 暂停 ⌘K ⌘I 显示悬停 12. 集成终端 Mac 快捷键 介绍 ⌃` 显示集成终端 ⌃⇧` 创建新终端 unassigned（末分配） 复制选择 unassigned（末分配） 粘贴到活动终端 ⌘↑ 向上滑动 ⌘↓ 下身滑动 PgUp 向上滚动页面 PgDown 向下滚动页面 ⌘Home 滚动到顶部 ⌘End 滚动到尾部 参考资料 VScode官网 快捷键 Mac 版 Visual Studio Code 快捷键 Mac 版 CSDN https://code.visualstudio.com/docs/getstarted/keybindings powered by Gitbook文件最后修改时间： 2019-10-25 01:23:46 "},"doc/mac/009-Mac-Office2016使用设置.html":{"url":"doc/mac/009-Mac-Office2016使用设置.html","title":"Mac-Office2016使用设置","keywords":"","body":" 阅读视图 找出标尺工具 目录 [TOC] 阅读视图 视图->侧栏->导航 就可以了 https://www.zhihu.com/question/35087715 找出标尺工具 视图 -> 标尺view -> ruler powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/010-Mac下Nginx的安装运行.html":{"url":"doc/mac/010-Mac下Nginx的安装运行.html","title":"Mac下Nginx的安装运行","keywords":"","body":" 一. 安装Nginx 二. 配置Nginx配置文件 三. Nginx的一些命令 1. Nginx自己的命令 2. 使用brew services 命令 四. Nginx一些常见错误 参考链接 [TOC] 一. 安装Nginx 打开终端 ~ brew install nginx 二. 配置Nginx配置文件 根据安装的提示，配置文件的路径：/usr/local/etc/nginx/nginx.conf打开文件编辑里面的内容： user nginx; worker_processes 1; #error_log /var/log/nginx/error.log warn; #pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; #access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; server { listen 8080; #服务的端口号 server_name localhost; location / { root /www/cloudlink; #访问的项目目录 index index.html index.htm; #访问的文件名 } location ^~ /cloudlink/v1/ { proxy_pass http://192.168.100.92:8050/; #项目需要的代理地址 } location ^~ /cloudlink/zipkin/ { proxy_pass http://192.168.100.90:9411/; #项目需要的代理地址 } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } 保存后从新加载配置文件： nginx -s reload 三. Nginx的一些命令 1. Nginx自己的命令 # 打开终端运行命令 ~ nginx # 启动Nginx # 执行该命令之后，nginx 会在 /usr/local/var/run/ 路径下创建一个名为nginx.pid 的文件 ~ nginx -s reload # 重新加载配置 # 执行该命令之后，nginx会重新启动，但前提是/usr/local/var/run/ 路径下必须存在 nginx.pid 文件 ~ nginx -s reopen # 重启 ~ nginx -s stop # 停止 # 执行该命令之后，nginx 会将 /usr/local/var/run/ 路径下名为nginx.pid 的文件删除掉。但前提是/usr/local/var/run/ 路径下必须存在 nginx.pid 文件 ~ nginx -s quit # 退出 nginx ~ nginx -V # 查看版本，以及配置文件地址 ~ nginx -v # 查看版本 ~ nginx -c filename # 指定配置文件 ~ nginx -h # 帮助 ~ nginx -t # 测试配置是否有语法错误 2. 使用brew services 命令 # brew services [-v|--verbose] [list | run | start | stop | restart | cleanup] [...] ~ brew services start nginx # 启动Nginx服务 ~ brew services stop nginx # 停止Nginx服务 ~ brew services restart nginx # 重启Nginx服务 四. Nginx一些常见错误 1. 重启nginx 报错 ~ sudo nginx -s reload nginx: [error] open() \"/usr/local/var/run/nginx.pid\" failed (2: No such file or directory) 出现该问题的原因是没有nginx.pid 这个文件, 解决方法：重启一下Nginx就好了。 2. 启动nginx报错 ~ nginx nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (48: Address already in use) nginx: [emerg] still could not bind() 出现该问题的原因是/usr/local/var/run/nginx.pid 文件已经存在，也就是说nginx已经启动了，再次执行启动nginx，就会出现这种问题了，接口被占用了 解决方法：重启nginx，而不是启动nginx 参考链接 http://www.jianshu.com/p/918eb337a206 http://blog.csdn.net/dracotianlong/article/details/21817097 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/011-Mac下sublime编辑器设置.html":{"url":"doc/mac/011-Mac下sublime编辑器设置.html","title":"Mac下sublime编辑器设置","keywords":"","body":" 1、安装Package Control 2、sublime 使用Package Control安装插件 3、删除插件、更新插件 4、查看已经安装了哪些插件 5、一些包插件 Vue Syntax Highlight : VUE语法高亮，并且智能提示 Terminal：直接在sublime里面打开终端插件 6、sublime快捷键 7、修改sublime默认快捷键 8、编辑中一些快捷操作 9、sublime设置可以执行JS文件 [TOC] 1、安装Package Control 在安装之前需要自导sublime的版本，打开finder，按快捷键shift + command + .显示隐藏文件，选择用户下的资源库，选择Application Support 文件夹，在里面找到sublime Text 3 文件夹，看名字就只到是哪个版本的了。 安装Package Control参考链接： https://packagecontrol.io/installation 打开sublime，按ctrl+`` 快捷键，或者在菜单栏：View -> Show Console`打开控制台。 复制下面代码回车 import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) 检查是否安装成功：Sublime Text -> Preferences -> Package Control 点击Preferences。如果安装成功了，Package Settings 、Package Control会出现在菜单里了。安装参考链接：https://jingyan.baidu.com/article/455a99508b7ccda1662778e0.html 2、sublime 使用Package Control安装插件 使用快捷键shift + command + p或 Sublime Text -> Preferences -> Package Control打开Package Control 输入Install Package，选择安装包。 输入需要安装的包名，在出来的选项中找到包，点击后，会自动安装，安装进度看sublime左下角的进度提示 包的安装路径:/Users/dragon/Library/Application Support/Sublime Text 3/Installed Packages 3、删除插件、更新插件 使用快捷键shift + command + p或 Sublime Text -> Preferences -> Package Control打开Package Control 删除插件 在Package Control 中 输入Remove Package选择Package Cont:Remove Package 在里面选择需要的删除插件名字，点击即可删除 更新插件 在Package Control 中 输入upgrade packages选择Package Cont:Upgrade/Overwrite All Packages 4、查看已经安装了哪些插件 使用快捷键shift + command + p打开Package Control 输入package，选择list packages 在显示的列表中就是已经安装的package了 在Mac中sublime插件的存放位置： // 第一个 /Users/[用户名]/Library/Application Support/Sublime Text 3/Installed Packages // 第二个 /Users/[用户名]/Library/Application Support/Sublime Text 3/Packages // 如：里面的插件 Terminal /Users/[用户名]/Library/Application Support/Sublime Text 3/Packages/Terminal 5、一些包插件 Typescript Syntax: typescript语法 SublimeLinter：代码校验插件，支持 HTML、CSS、JS、PHP、Java、C++ 等16种语言； Alignment：代码对齐插件； Git：整合 Git 功能的插件； BracketHighlighter： 括号高亮匹配 emmet: HTML 中使用CSS样式语法，然后使用 tab键直接生成对应html元素 Vue Syntax Highlight : VUE语法高亮，并且智能提示 Terminal：直接在sublime里面打开终端插件 安装好插件后， 在sublime上选择一个文件，右键 -> Open Terminal Here，即可在终端打开这个文件。 Mac系统中，该命令的快捷键：shift+command+t. 6、sublime快捷键 cmd + K cmd + B //显示隐藏侧边栏 (文件目录) // View -> layout -> option + cmd + 1 // 编辑器与单屏显示编辑 option + cmd + 2 // 分2屏显示编辑 option + shift + cmd + 2 // 分2个水平屏编辑 7、修改sublime默认快捷键 参考链接： https://blog.csdn.net/xuchao2015/article/details/52556927 打开sublime，左上角：sublime Text -> Preferences -> Key Bindings, 打开修改快捷键文件。 文件左边内容类似于： [ { \"keys\": [\"super+shift+n\"], \"command\": \"new_window\" }, { \"keys\": [\"super+shift+w\"], \"command\": \"close_window\" }, { \"keys\": [\"super+o\"], \"command\": \"prompt_open\" }, { \"keys\": [\"super+shift+t\"], \"command\": \"reopen_last_file\" }, ] keys里面是快捷键，command里面是快捷键说明。 up down right left insert home end pageup pagedown backspace delete tab enter shift ctrl alt super (这个就是win键, mac上是commond键) 找到需要修改的快捷键，然后在右边修改： [ //{ \"keys\": [\"super+shift+d\"], \"command\": \"duplicate_line\" }, { \"keys\": [\"super+d\"], \"command\": \"duplicate_line\" }, // 复制一行 { \"keys\": [\"ctrl+alt+l\"], \"command\": \"reindent\" }, // 格式化代码 ] 8、编辑中一些快捷操作 从编辑器中打开finder， 编辑器打开一个文件，在编辑区右键 -> Reveal in Finder,即可在finder中显示这个文件。 9、sublime设置可以执行JS文件 需要安装JS运行环境nodejs 如果没有安装nodejs，需要安装nodejs nodejs中文网 在sublime中一次打开：Tools > Build System > New Build System...或者中文工具>编译系统>新编译系统 ，粘贴下面代码： { \"cmd\": [\"node\", \"$file\"], \"selector\": \"source.js\" } 保存文件名为：Node.sublime-build, // 该文件在Mac下的路径 /Users/用户名/Library/Application Support/Sublime Text 3/Packages/User // 如果需要修改，可再次打开这个文件修改。 cd ~/Library/Application\\ Support/Sublime\\ Text\\ 3/Packages/User 新建js文件，直接ctrl+b，就可以在控制台输出结果了，停止运行使用ctrl + c 参考资料： Sublime Text内运行javascript(ES6) 在sublime text3里面直接运行js CSDN powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/012-Mac下移动硬盘分区用做TimeMachine的备份.html":{"url":"doc/mac/012-Mac下移动硬盘分区用做TimeMachine的备份.html","title":"Mac下移动硬盘分区用做TimeMachine的备份","keywords":"","body":" 说明 格式化移动硬盘 分区 分 Mac格式的区 分 win下格式的区 TimeMachine [TOC] 说明 新买了一块移动硬盘打算做存储和苹果系统的备份用，苹果系统的备份需要苹果系统的专用格式，如果单独买一块用于苹果系统备份不划算，所以买了一块容量2TB的移动硬盘分区成2块，一块用存储，一块用备份，完美。之前在Windows电脑上先分区，然后在Mac下把其中一个区格式化成苹果格式，但是这种方法imeMachine不识别。在网络上找了一些资料，看见了下面的介绍：http://www.jianshu.com/p/5f8b4d9a8922 原来在window下面把移动硬盘分区后，在Mac下TimeMachine备份磁盘中是找不到的，只有在Mac下把硬盘格式化后在分区，TimeMachine才能识别出分区的2块盘，上面链接的教程现在操作有点改变，现在记录一下（Mac系统： macOS High Sierra 10.13.2）： 格式化移动硬盘 打开commmand+空格打开你的Spotlight，搜索disk Utility.app,也就是苹果的磁盘工具， 点击左上角的显示，选择显示所有设备。 在左边外置中选择移动硬盘， 右键抹掉，在出现的弹窗中： 名称可以忽略 格式选择`Mac OS 扩展（日志式）` 方案选择`GUID 分区图` 然后点击抹掉，等一会就完成了格式化。 分区 分 Mac格式的区 右键移动硬盘，选择分区， 名称： Mac格式磁盘 格式：Mac OS 扩展（日志式） 大小： 填写合适的大小 然后点一下左边饼图下面的 加号，然后点击应用等一会就可以了。 分 win下格式的区 步骤与上面的一样， 但是在格式里面选择Windows NT 文件系统(Tuxera NTFS) 其它的一样。等一会就可以了 经过上面的操作后，就能在Mac电脑里TimeMachine里识别出分区的2块盘了 TimeMachine 打开系统偏好设置，点击TimeMachine，选择那个你刚刚分区成功容量为300GB格式为MAC OS X的硬盘，经过蛮久的等待，就备份成功喽， TimeMachine powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/013-Mac下angular开发环境安装.html":{"url":"doc/mac/013-Mac下angular开发环境安装.html","title":"Mac下angular开发环境安装","keywords":"","body":" install node, install npm # 需要事先安装好 brew ~ brew install node # 2017-07-21 经实际安装，用 brew 安装node后，npm也已经安装好了。 # ~ brew install npm ~ npm -v ~ node -v # 使用brew安装的node版本太高了，告知angular2 里面`.sass`文件`node-sass`包不兼容 # 卸载node最新版本 brew uninstall node # node官网： https://nodejs.org/en/download/ 打开网站选择 LTS 版本的。下载mac版本的，然后店家安装 编辑器安装 VScode免费 下载地址： https://code.visualstudio.com/选择一个Mac版本的，下载后，解压，把程序拖到 应用程序目录中. 一些angularJS开发需要安装的插件：Add Angular2 Files : https://marketplace.visualstudio.com/items?itemName=sebastianbaar.vscode-add-angular2-filesAngular 2, 4 and upcoming latest TypeScript HTML Snippets : https://marketplace.visualstudio.com/items?itemName=UVBrain.Angular2Angular ES6 snips : https://marketplace.visualstudio.com/items?itemName=kasperkeso.es6-angular-snipsAngular Files : https://marketplace.visualstudio.com/items?itemName=alexiv.vscode-angular2-filesAngular v4 TypeScript Snippets : https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2angular2-useful-dev-extensions : https://marketplace.visualstudio.com/items?itemName=boastr.angular2-useful-dev-extensionsAtom One Dark Theme: https://marketplace.visualstudio.com/items?itemName=freebroccolo.theme-atom-one-darkAuto Import : https://marketplace.visualstudio.com/items?itemName=steoates.autoimportAutolinting for Javascript : https://marketplace.visualstudio.com/items?itemName=t-sauer.autolinting-for-javascriptbackground : https://marketplace.visualstudio.com/items?itemName=shalldie.backgroundClass autocomplete for HTML : https://marketplace.visualstudio.com/items?itemName=AESSoft.aessoft-class-autocompleteCSS Auto Prefix : https://marketplace.visualstudio.com/items?itemName=sporiley.css-auto-prefixCSS Peek : https://marketplace.visualstudio.com/items?itemName=pranaygp.vscode-css-peekDark+ Material : https://marketplace.visualstudio.com/items?itemName=vangware.dark-plus-materialEmber JS (ES6) and Handlebars code snippets : https://marketplace.visualstudio.com/items?itemName=phanitejakomaravolu.EmberES6SnippetsExtension Manifest Editor : https://marketplace.visualstudio.com/items?itemName=ms-devlabs.extension-manifest-editorFile Peek : https://marketplace.visualstudio.com/items?itemName=abierbaum.vscode-file-peekFlatland_Dark Theme : https://marketplace.visualstudio.com/items?itemName=gerane.Theme-FlatlandDarkHTML CSS Class Completion : https://marketplace.visualstudio.com/items?itemName=Zignd.html-css-class-completionHTML CSS Support : https://marketplace.visualstudio.com/items?itemName=ecmel.vscode-html-cssHTML SCSS Support : https://marketplace.visualstudio.com/items?itemName=P-de-Jong.vscode-html-scssHTML Snippets : https://marketplace.visualstudio.com/items?itemName=abusaidm.html-snippetsJavaScript (ES6) code snippets : https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippetsJavaScript snippets for Dynamics 365/CRM 2011/2013/2015/2016 : https://marketplace.visualstudio.com/items?itemName=JLattimer.dynamics-crm-jsJS-CSS-HTML Formatter : https://marketplace.visualstudio.com/items?itemName=lonefy.vscode-JS-CSS-HTML-formatterJSFiddle Like Syntax Theme : https://marketplace.visualstudio.com/items?itemName=davidmart.theme-jsfiddle-like-syntax-vscode powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/mac/014-Mac-install-RVM,ruby,pqadmin3,rubymine2016.html":{"url":"doc/mac/014-Mac-install-RVM,ruby,pqadmin3,rubymine2016.html","title":"Mac-install-RVM,ruby,pqadmin3,rubymine2016","keywords":"","body":" 1. install RVM 2. 安装 rubymine ruby编辑器 rubymine 2017安装 Mac install pgadmin3 [TOC] 1. install RVM 1.未装homebrew先装homebrew，否则报错： $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 如果有安装homebrew，但是在后面的ruby安装过程中出现如下错误,有可能是你更新mac系统造成的，我是通过卸载重装homebrew来解决这个问题的. $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" $ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 2.安装rvm $ curl -L https://get.rvm.io | bash -s stable # 启用RVM $ source ~/.rvm/scripts/rvm # 检查一下是否安装正确命令 $ rvm -v # 如果出现邦本则说明安装成功 2. 安装 rubymine ruby编辑器 rubymine 2017安装 在官网下载最新安装包： https://www.jetbrains.com/ruby/download/#section=mac 下载完成安装包后，安装程序（双击打开，将左侧拖拽至右侧应用程序，默认安装）。 打开软件，在注册中选择‘License server’， 在 ‘License server address’ 中输入：http://xidea.online,然后点击Activate即可 Mac install pgadmin3 #终端，已经安装了brew ，cask ~ brew search pgadmin3 Caskroom/versions/pgadmin3 ~ brew install Caskroom/versions/pgadmin3 修改数据库配置文件，允许连接~ vi /usr/local/var/postgres/pg_hba.conf 找到下面的内容：# IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： # 没试过， ~ pg_ctl start -D /usr/local/var/postgres/data -l /usr/local/var/log/postgres/log.log # 停止的话把后面的start换成stop即可。 如果不想每次都指定数据目录，可以创建保存该地址的环境变量PGDATA # export PGDATA=/usr/local/var/postgres/data 查看数据库的运行：# 亲测有效 $ lsof -i:5432 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/001-linux下常用的终端命令.html":{"url":"doc/linux/001-linux下常用的终端命令.html","title":"linux下常用的终端命令","keywords":"","body":" MV移动文件、重命名文件 移动文件：mv [选项] 源文件或目录 目标文件或目录 文件重命名 查找：文件，内容，统计文件 find查找文件 Linux查找文件内容 查看当前用户 linux修改文件所属用户和组 复制文件：cp scp centos添加用户跟组 centos7开机自动关闭网络,开启网络，有线设置 查看文件文件夹大小 linux 压缩、解压 查看当前系统版本 wget/curl return home [TOC] MV移动文件、重命名文件 移动文件：mv [选项] 源文件或目录 目标文件或目录 参考链接：https://www.cnblogs.com/piaozhe116/p/6084214.html 文件重命名 linux下重命名文件或文件夹的命令mv既可以重命名，又可以移动文件或文件夹. 例子：将目录A重命名为B mv A B 例子：将/a目录移动到/b下，并重命名为c mv /a /b/c 其实在文本模式中要重命名文件或目录的话也是很简单的，我们只需要使用mv命令就可以了，比如说我们要将一个名为abc的文件重命名为1234就可以这样来写：mv abc 1234，但是要注意的是，如果当前目录下也有个1234的文件的话，我们的这个文件是会将它覆盖的 查找：文件，内容，统计文件 find查找文件 $ find / -name 文件名 $ find / -name 'azure-armrest*' # 部分名字匹配 例如azure-armrest-0.3.9 # find ver1.d ver2.d -name '*.c' -print 查找ver1.d,ver2.d *.c文件并打印 # find . -type d -print 从当前目录查找，仅查找目录，找到后，打印路径名。可用于打印目录结构。 更多详细点这里 Linux查找文件内容 $ grep \"被查找的字符串\" 文件名 # 从文件内容查找匹配指定字符串的行： $ find / -type f -name \"*.log\" | xargs grep \"ERROR\" # 从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行 更多详细点这里 查看当前用户 whoami linux修改文件所属用户和组 使用chown命令可以修改文件或目录所属的用户： 命令：chown 用户 目录或文件名 例如：chown qq /home/qq (把home目录下的qq目录的拥有者改为qq用户) 使用chgrp命令可以修改文件或目录所属的组： 命令：chgrp 组 目录或文件名 例如：chgrp qq /home/qq (把home目录下的qq目录的所属组改为qq组) 如果需要修改目录及子目录的权限则需要加 -R sudo chown yulilong -R local 复制文件：cp scp http://www.jb51.net/LINUXjishu/70474.html Linux为我们提供了两个用于文件copy的命令，一个是cp，一个是scp，但是他们略有不同。 cp --- 主要是用于在同一台电脑上，在不同的目录之间来回copy文件 scp --- 主要是在不同的Linux系统之间来回copy文件 将档案 aaa 复制(已存在)，并命名为 bbb： cp aaa bbb 从 本地 复制到 远程 cp [options] source1 source2 source3 …. directory 上面第一条命令为单个文件或目录拷贝，下一个为多个文件拷贝到最后的目录。 options选项包括： - a 保留链接和文件属性，递归拷贝目录，相当于下面的d、p、r三个选项组合。 - d 拷贝时保留链接。 - f 删除已经存在目标文件而不提示。 - i 覆盖目标文件前将给出确认提示，属交互式拷贝。 - p 复制源文件内容后，还将把其修改时间和访问权限也复制到新文件中。 - r 若源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。当然，目标文件必须为一个目录名。 - l 不作拷贝，只是链接文件。 -s 复制成符号连结文件 (symbolic link)，亦即『快捷方式』档案； -u 若 destination 比 source 旧才更新 destination。 cp命令使用范例： 1、将文档 file1复制成file2，复制后名称被改file2 cp file1 file2 2、将文档 file1复制到dir1目录下，复制后名称仍未file1 cp file1 dir1 3、将目录dir1复制到dir2目录下，复制结果目录被改名为dir2 cp -r dir1 dir2 # 将web92_dev目录下的node_modules目录所有文件(包括隐藏文件) 复制到 当前目录下的 node_modules 文件夹中 cp -a /Users/dragon/web92_dev/node_modules/ ./node_modules 4、将目录dir1下所有文件包括文件夹，都复制到dir2目录下 cp -r dir1/*.* dir2 常见错误： 1、提示cp: omitting directory错误 复制目录时，使用-r选项即可递归拷贝，如下： cp -r dir1 dir2 # 从 本地 复制到 远程: 把本地的full.tar.gz 复制到远程的 /home/root目录下 scp /home/daisy/full.tar.gz root@172.19.2.75:/home/root # 从 远程 复制到 本地: scp root@172.19.2.75:/home/root/full.tar.gz /home/daisy #（然后会提示你输入另外那台172.19.2.75主机的root用户的登录密码，接着就开始copy了） # 复制目录加参数 -r 即可 # 远程/var/www/miq/vmdb 复制到当前目录下 scp -r root@192.168.100.110:/var/www/miq/vmdb ./ centos添加用户跟组 http://zhidao.baidu.com/link?url=YWnbBbR1fLGrWwQ9bKROr_2A_7fotpIgs2IJA0yh7-MfDDBKf3GSsB8Hab1pn0-Q8xpBnW0rSUUOhY1jIngKlX_O3-O9q2G0uIQCsANK80e centos7开机自动关闭网络,开启网络，有线设置 http://jingyan.baidu.com/article/6dad5075f3d766a123e36eaa.html $ cd /etc/sysconfig/network-scirpts $ ls $sudo vi ifcfg-eth0 修改： ONBOOT=yes 关闭 ONBOOT=no 查看文件文件夹大小 [root@bsso yayu]# du -h --max-depth=1 work/testing 27M work/testing/logs 35M work/testing [root@bsso yayu]# du -h --max-depth=1 work/testing/* 8.0K work/testing/func.php 27M work/testing/logs # 查看磁盘各分区大小、已用空间等信息 $ df -h # 查看foo目录的大小： $ du -sh foo # 查看当前目录以下搜索文件和子目录大小: $ du -sh * linux 压缩、解压 http://www.blogjava.net/jiangjf/archive/2007/07/29/133122.htmlhttp://blog.csdn.net/liangzhao_jay/article/details/48052913 .tar # tar命令可以用来压缩打包单文件、多个文件、单个目录、多个目录。 多个文件压缩打包 tar czvf my.tar.gz file1 file2 ...（file*）（也可以给file*文件mv 目录在压缩） 单个目录压缩打包 tar czvf my.tar.gz dir1 多个目录压缩打包 tar czvf my.tar.gz dir1 dir2 解包至当前目录： tar xzvf my.tar.gz --------------------------------------------- .zip 　　解压：unzip FileName.zip 　　压缩：zip FileName.zip DirName --------------------------------------------- .rar 　　解压：rar a FileName.rar 　　压缩：r ar e FileName.rar 查看当前系统版本 $ lsb_release -a $ cat /etc/issue wget/curl http://www.cnblogs.com/dingn/p/5658442.html # Linux系统中wget是一个下载文件的工具，它用在命令行下。对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。 $ wget http://place.your.url/here http://www.linuxdiyf.com/linux/2800.html # 在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 $ curl www.baidu.com # 会把百度网页元素语言显示出来 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/002-linux下常用软件.html":{"url":"doc/linux/002-linux下常用软件.html","title":"linux下常用软件","keywords":"","body":" GIMP图片编辑工具，用于处理文档图片 星火字典stardict ## [TOC] GIMP图片编辑工具，用于处理文档图片 install在linux应用商店里搜索GIMP 就能出来 语言设置辑—首选项—界面—语言，在下拉列表中选择[汉语_zh-CN]，对应的英文菜单式这样的Edit-Preferences-Interface-Language-[Chinese_zh-CN] 工具选项gimp 2.0到2.4版本 工具箱菜单 文件(File)→对话框(Dialogs)→工具选项(ToolOption)gimp 2.6 用图像窗口菜单 窗口→可停靠对话框→工具选项 滤镜里面-》绘制-》几何图形，就搞定了哦 星火字典stardict installhttp://bckong.blog.51cto.com/5092126/1575904/http://www.centoscn.com/image-text/install/2015/0624/5734.html sudo yum install http://puias.math.ias.edu/data/puias/6/x86_64/os/Addons/stardict-3.0.1-22.puias6.x86_64.rpm 词典的离线字典下載网站字典下载： http://download.huzheng.org/zh_CN/离线字典下载地址： http://download.csdn.net/download/love254443233/7864659下载下来解压以后，有很多的.tar.bz2的包，把包全部解压，然后把包里面的东西，记住一定要是包里面的东西，不是把包， 全部移动到 /usr/share/stardict/dic 这个文件中sudo cp stardict-lazyworm-ec-2.4.2/* /usr/share/stardict/dic/ powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/003-Linux查找文件内容.html":{"url":"doc/linux/003-Linux查找文件内容.html","title":"Linux查找文件内容","keywords":"","body":" shell命令搞定某个文件夹下java代码行数的统计 从文件内容查找匹配指定字符串的行： $ grep \"被查找的字符串\" 文件名 例子：在当前目录里第一级文件夹中寻找包含指定字符串的.in文件 $ grep \"thermcontact\" */*.in 从文件内容查找与正则表达式匹配的行： $ grep –e “正则表达式” 文件名 查找时不区分大小写： $ grep –i \"被查找的字符串\" 文件名 查找匹配的行数： $ grep -c \"被查找的字符串\" 文件名 从文件内容查找不匹配指定字符串的行： $ grep –v \"被查找的字符串\" 文件名 从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行 find / -type f -name \"*.log\" | xargs grep \"ERROR\" 例子：从当前目录开始查找所有扩展名为.in的文本文件，并找出包含”thermcontact”的行 find . -name \"*.in\" | xargs grep \"thermcontact\" http://blog.chinaunix.net/uid-25266990-id-199887.html shell命令搞定某个文件夹下java代码行数的统计 find . -name \"*.java\"|xargs wc -l|grep \"total\"|awk '{print $1}' find . -name \"*.java\"|xargs cat|wc -l #Output:37634 上面的两句效果一样，只不过第二种是先利用cat将多个java文件的内容合并输出了。然后再统计。 不过两个都有共同的毛病——连文件里面的空行都给统计进去算作一行了。 去除空行版: find . -name \"*.java\"|xargs cat|grep -v ^$|wc -l 去除注释版: # exclude the lines begin with // find . -name \"*.java\"|xargs cat|grep -v -e ^$ -e ^\\s*\\/\\/.*$|wc -l 参考链接：https://blog.csdn.net/yhhwatl/article/details/52623879 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/003-find命令详解.html":{"url":"doc/linux/003-find命令详解.html","title":"find命令详解","keywords":"","body":"find命令查找文件路径。http://www.server110.com/linux/201309/1457.htmlhttp://www.cnblogs.com/bigbean/p/3669739.html 1. 基本用法： $ find / -name 文件名 $ find / -name 'azure-armrest*' # 部分名字匹配 例如azure-armrest-0.3.9 # find ver1.d ver2.d -name '*.c' -print 查找ver1.d,ver2.d *.c文件并打印 # find . -type d -print 从当前目录查找，仅查找目录，找到后，打印路径名。可用于打印目录结构。 2. 无错误查找： find / -name access_log 2 >/dev/null 3. 按尺寸查找： $ find / -size 1500c #（查找1,500字节大小的文件，c表示字节） $ find / -size +1500c #（查找大于1,500字节大小的文件，+表示大于） $ find / -size +1500c #（查找小于1,500字节大小的文件，-表示小于） 4. 按时间： $ find / -amin n # 最后n分钟 $ find / -atime n # 最后n天 $ find / -cmin n # 最后n分钟改变状态 $ find / -ctime n # 最后n天改变状态 5. 其它： $ find / -empty # 空白文件、空白文件夹、没有子目录的文件夹 $ find / -false # 查找系统中总是错误的文件 $ find / -fstype type # 找存在于指定文件系统的文件，如type为ext2 $ find / -gid n # 组id为n的文件 $ find / -group gname # 组名为gname的文件 $ find / -depth n # 在某层指定目录中优先查找文件内容 $ find / -maxdepth levels # 在某个层次目录中按递减方式查找 一、Linux中find常见用法示例 find path -option [ -print ] [ -exec -ok command ] {} ; #-print 将查找到的文件输出到标准输出 #-exec command {} ; -----将查到的文件执行command操作,{} 和 ;之间有空格 #-ok 和-exec相同，只不过在操作前要询用户 ==================================================== -name filename #查找名为filename的文件 -perm #按执行权限来查找 -user username #按文件属主来查找 -group groupname #按组来查找 -mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前 -atime -n +n #按文件访问时间来查GIN: 0px\"> -perm #按执行权限来查找 -user username #按文件属主来查找 -group groupname #按组来查找 -mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前 -atime -n +n #按文件访问时间来查找文件，-n指n天以内，+n指n天以前 -ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 -nogroup #查无有效属组的文件，即文件的属组在/etc/groups中不存在 -nouser #查无有效属主的文件，即文件的属主在/etc/passwd中不存 -newer f1 !f2 找文件，-n指n天以内，+n指n天以前 -ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 -nogroup #查无有效属组的文件，即文件的属组在/etc/groups中不存在 -nouser #查无有效属主的文件，即文件的属主在/etc/passwd中不存 -newer f1 !f2 #查更改时间比f1新但比f2旧的文件 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文件 -size n[c] #查长度为n块[或n字节]的文件 -depth #使查找在进入子目录前先行查找完本目录 -fstype #查更改时间比f1新但比f2旧的文件 -mount #查文件时不跨越文件系统mount点 -follow #如果遇到符号链接文件，就跟踪链接所指的文件 -cpio #对匹配的文件使用cpio命令，将他们备份到磁带设备中 -prune #忽略某个目录 ==================================================== $find ~ -name \"*.txt\" -print #在$HOME中查.txt文件并显示 $find . -name \"*.txt\" -print $find . -name \"[A-Z]*\" -pri26nbsp; #对匹配的文件使用cpio命令，将他们备份到磁带设备中 -prune #忽略某个目录 $find . -name \"[A-Z]*\" -print #查以大写字母开头的文件 $find /etc -name \"host*\" -print #查以host开头的文件 $find . -name \"[a-z][a-z][0--9][0--9].txt\" -print #查以两个小写字母和两个数字开头的txt文件 $find . -perm 755 -print $find . -perm -007 -exec ls -l {} ; #查所有用户都可读写执行的文件同-perm 777 $find . -type d -print 打印目录结构 $find . ! -type d -print 打印非目录文件 find /usr/include -name '*.h' -exec grep AF_INEF6 {} ; 因grep无法递归搜索子目录，故可以和find相结合使用。 在/usr/include 所有子目录中的.h文件中找字串AF_INEF6 $find . -type l -print $find . -size +1000000c -print #查长度大于1Mb的文件 $find . -size 100c -print # 查长度为100c的文件 $find . -size +10 -print #查长度超过期作废10块的文件（1块=512字节） $cd / $find etc home apps -depth -print | cpio -ivcdC65536 -o /dev/rmt0 $find /etc -name \"passwd*\" -exec grep \"cnscn\" {} ; #看是否存在cnscn用户 $find . -name \"yao*\" | xargs file $find . -name \"yao*\" | xargs echo \"\" > /tmp/core.log $find . -name \"yao*\" | xargs chmod o-w ====================================================== find -name april* 在当前目录下查找以april开始的文件 find -name april* fprint file 在当前目录下查找以april开始的文件，并把结果输出到file中 find -name ap* -o -name may* 查找以ap或may开头的文件 find /mnt -name tom.txt -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件 find /mnt -name t.txt ! -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件 find /tmp -name wa* -type l 在/tmp下查找名为wa开头且类型为符号链接的文件 find /home -mtime -2 在/home下查最近两天内改动过的文件 find /home -atime -1 查1天之内被存取过的文件 find /home -mmin +60 在/home下查60分钟前改动过的文件 find /home -amin +30 查最近30分钟前被存取过的文件 find /home -newer tmp.txt 在/home下查更新时间比tmp.txt近的文件或目录 find /home -anewer tmp.txt 在/home下查存取时间比tmp.txt近的文件或目录 find /home -used -2 列出文件或目录被改动过之后，在2日内被存取过的文件或目录 find /home -user cnscn 列出/home目录内属于用户cnscn的文件或目录 find /home -uid +501 列出/home目录内用户的识别码大于501的文件或目录 find /home -group cnscn 列出/home内组为cnscn的文件或目录 find /home -gid 501 列出/home内组id为501的文件或目录 find /home -nouser 列出/home内不属于本地用户的文件或目录 find /home -nogroup 列出/home内不属于本地组的文件或目录 find /home -name tmp.txt -maxdepth 4 列出/home内的tmp.txt 查时深度最多为3层 find /home -name tmp.txt -mindepth 3 从第2层开始查 find /home -empty 查找大小为0的文件或空目录 find /home -size +512k 查大于512k的文件 find /home -size -512k 查小于512k的文件 find /home -links +2 查硬连接数大于2的文件或目录 find /home -perm 0700 查权限为700的文件或目录 find /tmp -name tmp.txt -exec cat {} ; find /tmp -name tmp.txt -ok rm {} ; find / -amin -10 # 查找在系统中最后10分钟访问的文件 find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -group cat # 查找在系统中属于 groupcat的文件 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件 find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -nouser #查找在系统中属于作废用户的文件 find / -user fred #查找在系统中属于FRED这个用户的文件 查当前目录下的所有普通文件 -------------------------------------------------------------------------------- # find . -type f -exec ls -l {} ; -rw-r--r-- 1 root root 34928 2003-02-25 ./conf/httpd.conf -rw-r--r-- 1 root root 12959 2003-02-25 ./conf/magic -rw-r--r-- 1 root root 180 2003-02-25 ./conf.d/README 查当前目录下的所有普通文件，并在- e x e c选项中使用ls -l命令将它们列出 ================================================= 在/ l o g s目录中查找更改时间在5日以前的文件并删除它们： $ find logs -type f -mtime +5 -exec -ok rm {} ; ================================================= 查询当天修改过的文件 [root@book class]# find ./ -mtime -1 -type f -exec ls -l {} ; ================================================= 查询文件并询问是否要显示 [root@book class]# find ./ -mtime -1 -type f -ok ls -l {} ; ? y -rw-r--r-- 1 cnscn cnscn 13709 1月 12 12:22 ./classDB.inc.php [root@book class]# find ./ -mtime -1 -type f -ok ls -l {} ; ? n [root@book class]# ================================================= 查询并交给awk去处理 [root@book class]# who | awk '{print $1\"t\"$2}' cnscn pts/0 ================================================= awk---grep---sed [root@book class]# df -k | awk '{print $1}' | grep -v 'none' | sed s\"//dev///g\" 文件系统 sda2 sda1 [root@book class]# df -k | awk '{print $1}' | grep -v 'none' 文件系统 /dev/sda2 /dev/sda1 1)在/tmp中查找所有的*.h，并在这些文件中查找“SYSCALL_VECTOR\"，最后打印出所有包含\"SYSCALL_VECTOR\"的文件名 A) find /tmp -name \"*.h\" | xargs -n50 grep SYSCALL_VECTOR B) grep SYSCALL_VECTOR /tmp/*.h | cut -d':' -f1| uniq > filename C) find /tmp -name \"*.h\" -exec grep \"SYSCALL_VECTOR\" {} ; -print 2)find / -name filename -exec rm -rf {} ; find / -name filename -ok rm -rf {} ; 3)比如要查找磁盘中大于3M的文件： find . -size +3000k -exec ls -ld {} ; 4)将find出来的东西拷到另一个地方 find *.c -exec cp '{}' /tmp ';' 如果有特殊文件，可以用cpio，也可以用这样的语法： find dir -name filename -print | cpio -pdv newdir 6)查找2004-11-30 16:36:37时更改过的文件 # A=`find ./ -name \"*php\"` | ls -l --full-time $A 2>/dev/null | grep \"2004-11-30 16:36:37 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/004-linux下Nginx安装配置.html":{"url":"doc/linux/004-linux下Nginx安装配置.html","title":"linux下Nginx安装配置","keywords":"","body":" 1. 安装 1.1 启动Nginx 1.2 开机自动启动nginx 服务 1.3 关闭开机自动启动nginx 服务 1.4 重启Nginx服务 15 查看Nginx服务 2. 配置 [TOC] 1. 安装 通过命令 apt-get install 安装软件，通过安装 nginx 示例如下： $ apt-get install nginx 如果安装时遇到下面错误： E: Unable to locate package nginx 执行sudo apt-get update命令更新软件源后再安装即可。 软件安装完成后，通过通过 dpkg -L 列出软件包所在的目录，及该软件包中的所有文件： $ dpkg -L nginx /. /usr /usr/share /usr/share/doc /usr/share/doc/nginx /usr/share/doc/nginx/copyright /usr/share/doc/nginx/changelog.Debian.gz $ whereis nginx nginx: /usr/sbin/nginx /etc/nginx /usr/share/nginx 1.1 启动Nginx sudo systemctl start nginx 1.2 开机自动启动nginx 服务 sudo systemctl enable nginx 1.3 关闭开机自动启动nginx 服务 sudo systemctl disable nginx 1.4 重启Nginx服务 nginx -s reload 或者： sudo systemctl restart nginx 15 查看Nginx服务 ps -ef|grep nginx 2. 配置 配置目录：/etc/nginx/nginx.conf 终端打开配置文件： vi /etc/nginx/nginx.conf user www-data; worker_processes auto; pid /run/nginx.pid; events { worker_connections 768; # multi_accept on; } http { server { listen 80; #port server_name 47.104.24.148 www.dragon.com dragon.com; location / { root /website/dist; index index.html index.htm; } } } 配置主要是在http里面的 server，其中参数： listen：监听的端口 server_name：监听的服务名字，以空格间隔 location：访问服务的路径 保存后终端域名命令nginx -s reload重启Nginx来生效命令 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/005-centos7下习惯设置.html":{"url":"doc/linux/005-centos7下习惯设置.html","title":"centos7下习惯设置","keywords":"","body":" return home return home 设置文件默认打开的程序 右键文件选择 属性（properties） -》 open with -> 这里找一个希望的程序， -》 set as default powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/006-centos7搭建samba方法.html":{"url":"doc/linux/006-centos7搭建samba方法.html","title":"centos7搭建samba方法","keywords":"","body":" centos 部署samba centos7 连接服务器 centos 部署samba 1.安装Samba # yum -y install samba samba-client samba-common 2.selinux 设为警告模式 # setenforce 0 3.创建共享目录 # mkdir -p /home/smb/share_folder 4.(可不用)配置内核参数 # ulimit -n 16384 # vi /etc/security/limits.conf #在最后加入以下内容 * - nofile 16384 注：这主要是避免在启动samba出现1024警告信息 5.进入samba目录下备份配置文件 # cd /etc/samba # cp smb.conf smb.conf.bak 6.编辑smb.conf,删除原所有内容添加以下内容： [global] workgroup = SDYTKFQDD netbios name = YTKFQDJJ server string = Samba Server #security = share sercurity = user map to guest = Bad User [smb] path = /home/smb/myself public = no writable = yes write list = @myself 7.创建用户并分配权限 //创建操作系统用户 useradd myself //创建samba用户 smbpasswd -a myself //修改目录权限 chgrp myself /home/smb/myself/ chmod 774 /home/smb/myself/ //查看权限是否生效 ll -d /home/smb/myself/ //重启samba服务并加到开机自启动 systemctl restart smb systemctl enable smb //查看samba运行状态 systemctl status smb //将samba服务添加到防火墙，否则其他电脑无法访问，并重启防火墙 firewall-cmd --permanent --zone=public --add-service=samba firewall-cmd --reload //设置好win7的ip与centos7在同一网段内，开始--运行--输入\\\\服务器IP 即可看到共享文件了 centos7 连接服务器 1.查看samba服务器有那些文件夹 $ smbclient -L 192.168.1.44 -U myself 192.168.1.44:服务器的地址，改为你自己服务器的地址 myself： samba的用户 2.连接samba $ smbclient //192.168.1.44/smb -U myself 192.168.1.44:服务器的地址，改为你自己服务器的地址 smb：文件夹 myself： samba的用户 2.连接后文件上传与下载 连接后是ftp形式的，ftp命令： 1．FTP服务器的登陆 匿名用户：FTP 口令：FTP 用户：ANONYMOUS 口令：任何电子邮件 2．显示文件信息：DIR/LS 3．下载文件：GET 文件名（下载到当前目录） 4．上传文件：PUT 文件名 5．多文件下载：MGET 6．多文件上传：MPUT 7．退出：BYE 8．帮助：HELP ls 列出远程机的当前目录 cd 在远程机上改变工作目录 lcd 在本地机上改变工作目录 ascii 设置文件传输方式为ASCII模式 binary 设置文件传输方式为二进制模式 close 终止当前的ftp会话 hash 每次传输完数据缓冲区中的数据后就显示一个#号 get（mget） 从远程机传送指定文件到本地机 put（mput） 从本地机传送指定文件到远程机 open 连接远程ftp站点 断开与远程机的连接并退出ftp ? 显示本地帮助信息 ! 转到Shell中 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/007-centos7错误处理.html":{"url":"doc/linux/007-centos7错误处理.html","title":"centos7错误处理","keywords":"","body":" 1.dnf -y install memcached Failed to open: 2. tar uncompress xxx.tar.xz 3. sudo dnf -y install nodejs ,error :no package matched: nodejs 4. sudo dnf -y install npm 如果安装失败 sudo yum update 6. 在安装好manageiq 跟rvm后 重起后输入密码后重新输入错误 centos gnome 桌面崩溃 SSH不能连接并提示REMOTE HOST IDENTIFICATION HAS CHANGED解决错误信息： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HASCHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ..... .... Add correcthost key in /root/.ssh/known_hosts to get rid of this message. Offending keyin /root/.ssh/known_hosts:15 #主要看这里，这里是存放ssh主机信任的地方，找到，然后删除这儿ssh地址就好了 RSA host keyfor 192.168.0.252 has changed and you have requested strict checking. Host keyverification failed. rsync:connection unexpectedly closed (0 bytes received so far) [sender] rsync error:error in rsync protocol data stream (code 12) at io.c(359) 的解决办法：vi /root/.ssh/known_hosts找到要连接的主机的ip，把它的那行所有信息删除（就是一行）http://www.linuxidc.com/Linux/2012-07/64941.htm ssh: connect to host 192.168.123.123 port 22: Connection refused 1.linux中打开终端 $ netstat -ntlp # 查看所有端口，如果里面没有22端口则尝试重启ssh # 重启ssh $ sudo systemctl restart sshd # 一般来说到这里就可以，如果不行请查找别的方法， 1.dnf -y install memcached Failed to open: http://stackoverflow.com/questions/32541196/i-attempted-to-enable-the-epel-repo-on-my-fedora-22-machine-and-i-broke-it-now This is what appears to have worked for me. Remove the epel repo rm -rf /etc/yum.repos.d/epel* then try install epel via dnf dnf clean all dnf install epel-release 注： 如果删除了/etc/yum.repos.d/epel* ，那么一旦dnf命令安装失败，然后用yum安装，那么就要恢复删除的这些选项。 可先给yum.repos.d 文件夹做一个备份，如果dnf安装失败，则用yum安装，这个时候恢复这个文件夹。 2. tar uncompress xxx.tar.xz tar xf archive.tar.xz tar xf archive.tar.gz tar xf archive.tar .tar.gz 格式解压为 tar -zxvf xx.tar.gz .tar.bz2 格式解压为 tar -jxvf xx.tar.bz2 uncompress xxx.rar http://blog.csdn.net/alpha_xiao/article/details/52238962$ wget http://www.rarsoft.com/rar/rarlinux-3.9.3.tar.gz $ tar -xvf rarlinux-3.9.3.tar.gz $ cd rar $ sudo make 看见下面这些信息就是安装成功了 mkdir -p /usr/local/bin mkdir -p /usr/local/lib cp rar unrar /usr/local/bin cp rarfiles.lst /etc cp default.sfx /usr/local/lib 运行命令rar时,出现下面这个问题 rar: /lib/i686/nosegneg/libc.so.6: version `GLIBC_2.7' not found (required byrar) 解决办法： $ cp rar_static /usr/local/bin/rar 解壓： $ rar x vpsyou.rar //解压 vpsyou.rar 到当前目录 $ rar vpsyou.rar ./vpsyou.com/ //将 vpsyou.com 目录打包为vpsyou.rar 3. sudo dnf -y install nodejs ,error :no package matched: nodejs 1. 去官网下载安装 https://nodejs.org/ 2.如果官网的没有办法安装， https://www.unixmen.com/install-node-js-centos-7/ 参考这个例子，但可以去github源码网站clone下载 https://github.com/nodejs/node git clone git checkout v4.6.1 然后切换到官网的版本。 sudo yum install gcc gcc-c++ ./configure make sudo make install node --version 如果出现了版本号，则说明安装成功了。 4. sudo dnf -y install npm 如果安装失败 尝试是使用yum安装， $ sudo yum -y install npm 如果yum也提示没有，那么更新yum源 sudo yum update error info: 警告：/var/cache/yum/x86_64/7/elrepo-kernel/packages/python-perf-4.8.4-1.el7.elrepo.x86_64.rpm: 头V4 DSA/SHA1 Signature, 密钥 ID baadae52: NOKEY 从 file:///etc/pki/rpm-gpg/RPM-GPG-KEY-elrepo.org 检索密钥 获取 GPG 密钥失败：[Errno 14] curl#37 - \"Couldn't open file /etc/pki/rpm-gpg/RPM-GPG-KEY-elrepo.org\" process result http://elrepo.org/tiki/tiki-index.php $ rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 1.如果导入失败，则手动下载，然后把文件复制到 /etc/pki/rpm-gpg/ 6. 在安装好manageiq 跟rvm后 重起后输入密码后重新输入错误 bashrc 脚本被清除了 原本： ```.bashrc Source global definitions if [ -f /etc/bashrc ]; then . /etc/bashrc fi Uncomment the following line if you don't like systemctl's auto-paging feature: export SYSTEMD_PAGER= User specific aliases and functions 如果没有这一段，那么首先用root用户登陆，然后进入用户目录把这段加上。 * $HOME/.bash_profile 里面缺少下面这段代码： .bash_profile Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi User specific environment and startup programs PATH=$PATH:$HOME/.local/bin:$HOME/bin export PATH 如果缺少这段代码，那么复制这段代码到里面。 * 导致这个问题的原因： http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection 里面的这段话： source /opt/rh/rh-postgresql94/enable It is good idea to add this to your personal .bash_profile: $ cat > $HOME/.bash_profile centos gnome 桌面崩溃 键盘按 control + alt + F2 root登陆后，切换到个人用户 $ systemctl restart gdm.service 4.切回桌面： control + alt + F1 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/008-centos7_VNC_install.html":{"url":"doc/linux/008-centos7_VNC_install.html","title":"centos7_VNC_install","keywords":"","body":" overview 开始安装 VNC调试参考 常见错误 overview 　　VNC，全称为Virtual Network Computing，它是一个桌面共享系统。它的功能，类似于windows中的远程桌面功能。VNC使用了RFB(Remote FrameBuffer，远程帧缓冲）协议来实现远程控制另外一台计算机。它把键盘、鼠标动作发送到远程计算机，并把远程计算机的屏幕发回到本地。 　　VNC技术与平台无关，VNC Viewer可以和VNC Server在不同的操作系统上。VNC几乎支持所有的操作系统，也支持Java，甚至可以通过支持Java的浏览器来访问VNC Server。多个VNC客户端可以同时连接到一个VNC Server上。 参考链接 CentOs 7安装配置VNC Server---[亲测]http://www.jianshu.com/p/35640fc5672b 用VNC实现远程桌面共享的方法:http://www.educity.cn/linux/1442864.html CentOS安装VNC Server远程桌面：http://www.metsky.com/archives/818.html 开始安装 安装VNCServer # 试试服务器装了 VNC 没 $ rpm -q tigervnc tigervnc-server # 如出现not installed说明没有安装 #install VNC $ yum install tigervnc tigervnc-server # 用YUM删除软件包命令：yum remove ~ 配置NVC # 将/lib/systemd/system/vncserver@.service文件复制一份 $ cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service # 编辑刚刚我们复制得新文件，将文件中得修改成 VNC Client连接的账号 $ sudo vi /etc/systemd/system/vncserver@:1.service 设置VNCServer开机自启动 # 切换到root账号，开启VNCServer并设置开机自启 $ systemctl start vncserver@:1.service $ systemctl enable vncserver@:1.service 设置防火墙 最后，需要配置一下防火墙，允许VNC客户端连接VNC server。VNC server监听的端口从5900开始，display :1的监听5901，display :2监听5902，以此类推。CentOs的防火墙缺省是不允许连接这些端口的，所以需要使用下面的步骤打开防火墙（需要root权限)： # centos 默认使用的防火墙 $ firewall-cmd --permanent --add-service=\"vnc-server\" --zone=\"public\" $ firewall-cmd --reload 开启VNCServer $ vncserver Mac苹果系统链接centos 1.使用Jump Desktop软件。 VNC调试参考 # 查看所有端口，5900 5901 5902 是vnc所用的 $ netstat -ntlp 1.查看VNC进程情况（如果有VNC启动窗口，列表中可看到）： $ ps -ef|grep -i vnc 2.启动一个窗口 $ vncserver :1 3.杀死一个桌面(注意kill后面有个空格) $ vncserver -kill :1 $ rm -f /tmp/.X1-lock 如果是其它桌面号，需要对应修改ID号。 4.修改VNC登录密码 $ vncpasswd 常见错误 1、命令启动VNCServer报错 $ systemctl start vncserver@:1.service 报告如下错误：Job for vncserver@:1.service failed. See ‘systemctl status vncserver@:1.service’ and ‘journ alctl -xn’ for details. 解决方法(2中方法，我第二种成功了，)： 1.删除/tmp/.X11-unix/ 目录，再启用一次即可 2.修改配置文件 vncserver@:1.service 中 Type 为 simple 修改完成后执行：$ systemctl daemon-reload$ systemctl start vncserver:1.service powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/009-centos7ruby相关软件安装.html":{"url":"doc/linux/009-centos7ruby相关软件安装.html","title":"centos7ruby相关软件安装l","keywords":"","body":" return Home 注意：要按照顺序安装 rvm isntall 安装 pqadmin3 install rubymine 如果公司对版权有要求，请公司购买激活码，这时候请安装最新版。官网地址：https://www.jetbrains.com/ruby/ return Home 注意：要按照顺序安装 rvm isntall https://www.digitalocean.com/community/tutorials/how-to-install-ruby-on-rails-on-centos-6-with-rvm rvm install:$ sudo yum update $ sudo yum install curl $ curl -L get.rvm.io | bash -s stable 如果提示缺少密钥，那么按照提示安装密钥 # If you ran the installer as root, run: $ source /usr/local/rvm/rvm.sh # If you installed it through a user with access to sudo: $ source ~/.rvm/rvm.sh $ source ~/.profile $ rvm -v 如果出现版本，那么说明安装成功。 ruby install: $ rvm list known 选一个版本 $ rvm install 2.3.0 $ rvm use 2.3.0 --default $ echo '[[ -s \"$HOME/.rvm/scripts/rvm\" ]] && . \"$HOME/.rvm/scripts/rvm\"' >>~/.bashrc $ source ~/.bashrc $ ruby -v 如果出现版本，那么说明安装成功。 ps: /etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置. /etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取. ~/.bash_profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时该文件被读取. ~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件. Install RubyGems: $ rvm rubygems current $ gem -v 如果出现版本，那么说明安装成功。 Install Rails$ gem install rails $ rails -v 如果出现版本，那么说明安装成功。 安装 pqadmin3 这里首先需要系统中已经安装了postgres，如果没有安装请先安装。 查看linux中postgres 版本$ psql --version PostgreSQL是以加州大学伯克利分校计算机系开发的 POSTGRES，现在已经更名为PostgreSQL，版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分 SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL 可以用许多方法扩展，比如， 通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发 PostgreSQL，不管是私用、商用、还是学术研究使用。$ su postgres bash-4.2$ psql postgres=# \\du $ sudo find / -name postgresql.conf 注： 1.如果postgres 没有设置密码则用如下命令设置： $ sudo passwd postgres 2.如果psql notfound ，则 scl enable rh-postgresql94 bash，这个由于postgres升级导致的，http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection centos7.2安装 pgadmin3https://yum.postgresql.org/http://www.voidcn.com/blog/houzhizhen/article/p-4388378.html $ wget http://ftp.riken.jp/Linux/fedora/epel/6/x86_64/epel-release-6-8.noarch.rpm $ sudo rpm -ivh epel-release-6-8.noarch.rpm $ sudo yum install pgadmin3 修改数据库配置文件，允许连接 $ sudo vi /var/opt/rh/rh-postgresql94/lib/pgsql/data/pg_hba.conf 找到下面的内容： # IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： $ sudo systemctl restart rh-postgresql94-postgresql 查看数据库的运行：$ lsof -i:5432 install rubymine 如果公司对版权有要求，请公司购买激活码，这时候请安装最新版。官网地址：https://www.jetbrains.com/ruby/ 1. rubymine 最好是7.1.4版本的，这个网络上有激活码，此方法不建议。 个人网盘下载： 链接: https://pan.baidu.com/s/1o8PgQ50 密码: mk2q 2.下载后解压，进入bin目录，运行里面的rubymine.sh 即可安装。 使用中的问题： 3.rubymine安装后找不到ruby解释器位置： http://stackoverflow.com/questions/17950288/rubymine-cant-find-sdk-where-is-it * Windows - d:\\dev\\Ruby19\\bin\\ruby.exe * Mac Brew - /usr/local/Cellar/ruby/2.0.0-p247/bin/ruby * Ruby Version Manager - /Users//.rvm/rubies/ruby-1.9.3-p327/bin/ruby * Linux/Mac Default - /usr/bin/ruby powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/010-Terminal终端快捷键.html":{"url":"doc/linux/010-Terminal终端快捷键.html","title":"Terminal终端快捷键","keywords":"","body":" 快捷键 功能 上面的命令在 Mac上的终端也适用 # 快捷键 功能 Tab # 自动补全 Ctrl+a # 光标移动到开始位置 Ctrl+e # 光标移动到最末尾 Ctrl+k # 删除此处至末尾的所有内容 Ctrl+u # 删除此处至开始的所有内容 Ctrl+w # 删除此处到左边的单词 Ctrl+c # 终止进程/命令 Ctrl+l # 相当于clear，即清屏 # 上面的命令在 Mac上的终端也适用 ----------------------- Ctrl+d # 删除当前字符 Ctrl+h # 删除当前字符前一个字符 Ctrl+y # 粘贴由Ctrl+u， Ctrl+d， Ctrl+w删除的单词 Ctrl+r # 查找历史命令 Ctrl+b # 向回移动光标 Ctrl+f # 向前移动光标 Ctrl+t # 将光标位置的字符和前一个字符进行位置交换 Ctrl+& # 恢复 ctrl+h 或者 ctrl+d 或者 ctrl+w 删除的内容 Ctrl+S # 暂停屏幕输出 Ctrl+Q # 继续屏幕输出 Ctrl+Left-Arrow # 光标移动到上一个单词的词首 Ctrl+Right-Arrow # 光标移动到下一个单词的词尾 Ctrl+p # 向上显示缓存命令 Ctrl+n # 向下显示缓存命令 Ctrl+d # 关闭终端 Ctrl+xx # 在EOL和当前光标位置移动 Ctrl+x@ # 显示可能hostname补全 Shift+上或下 # 终端上下滚动 Shift+PgUp/PgDn # 终端上下翻页滚动 Ctrl+Shift+n # 新终端 alt+F2 # 输入gnome-terminal打开终端 Shift+Ctrl+T # 打开新的标签页 Shift+Ctrl+W # 关闭标签页 Shift+Ctrl+C # 复制 Shift+Ctrl+V # 粘贴 Alt+数字 # 切换至对应的标签页 Shift+Ctrl+N # 打开新的终端窗口 Shift+Ctrl+Q # 管壁终端窗口 Shift+Ctrl+PgUp/PgDn # 左移右移标签页 Ctrl+PgUp/PgDn # 切换标签页 F1 # 打开帮助指南 F10 # 激活菜单栏 F11 # 全屏切换 Alt+F 打开 “文件” 菜单（file） Alt+E 打开 “编辑” 菜单（edit） Alt+V 打开 “查看” 菜单（view） Alt+S 打开 “搜索” 菜单（search） Alt+T 打开 “终端” 菜单（terminal） Alt+H 打开 “帮助” 菜单（help） powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/011-VIM编辑器常用命令与用法总结.html":{"url":"doc/linux/011-VIM编辑器常用命令与用法总结.html","title":"VIM编辑器常用命令与用法总结","keywords":"","body":" （一）vi/vim是什么？ （二）为什么要学习vi/vim？ （三）vi的三种模式及各个模式之间的转换关系 （四）一般模式常用操作 （五）一般模式切换到编辑模式的操作 （六）一般模式切换到命令行模式 (十一)vim配置文件 参考链接 [TOC] （一）vi/vim是什么？ Linux世界几乎所有的配置文件都是以纯文本形式存在的，而在所有的Linux发行版系统上都有vi编辑器，因此利用简单的文字编辑软件就能够轻松地修改系统的各种配置了，非常方便。vi就是一种功能强大的文本编辑器，而vim则是高级版的vi，不但可以用不同颜色显示文字内容，还能进行诸如shell脚本、C语言程序编辑等功能，可以作为程序编辑器。 （二）为什么要学习vi/vim？ 首先所有的Linux发行版系统上都会默认内置vi编辑器，而不一定带有其他文本编辑器，非常通用；其次，很多软件的编辑接口都会默认调用vi；第三，vi具有程序编辑的能力；最后，vi程序简单，编辑速度相当快速。 （三）vi的三种模式及各个模式之间的转换关系 +----------------------+ i,o,a(插 入 ),R(替 换 )+------------------------+ | +--------------------------> 【 编 辑 模 式 】 | | 【 一 般 模 式 】 | | | | 【 命 令 行 模 式 ] | | | | 读 取 /保 存 文 件 | | （四）一般模式常用操作 【h(或向左方向键)】 光标左移一个字符【j(或向下方向键)】 光标下移一个字符【k(或向上方向键)】 光标上移一个字符【l(或向右方向键)】 光标右移一个字符 【[Ctrl] + f】 屏幕向下移动一页（相当于Page Down键）【[Ctrl] + b】 屏幕向上移动一页（相当于Page Up键） 【[0]或[Home]】 光标移动到当前行的最前面【[$]或[End]】 光标移动到当前行的末尾 【G】 光标移动到文件的最后一行（第一个字符处）【nG】 n为数字（下同），移动到当前文件中第n行【gg】 移动到文件的第一行，相当于\"1G\"【n[Enter]】 光标向下移动n行 【/word】 在文件中查找内容为word的字符串（向下查找）【?word】 在文件中查找内容为word的字符串（向上查找）【[n]】 表示重复查找动作，即查找下一个【[N]】 反向查找下一个【:n1,n2s/word1/word2/g】 n1、n2为数字，在第n1行到第n2行之间查找word1字符串，并将其替换成word2【:1,$s/word1/word2/g】 从第一行（第n行同理）到最后一行查找word1注册，并将其替换成word2【:1,$s/word1/word2/gc】 功能同上，只不过每次替换时都会让用户确认 【x,X】 x为向后删除一个字符，相当于[Delete]，X为向前删除一个字符，相当于[Backspace]【dd】 删除光标所在的一整行【ndd】 删除光标所在的向下n行 【yy】 复制光标所在的那一行【nyy】 复制光标所在的向下n行【p,P】 p为将已经复制的数据在光标下一行粘贴；P为将已经复制的数据在光标上一行粘贴 【u】 撤消上一个操作【[Ctrl] + r】 多次撤消【.】 这是小数点键，重复上一个操作 （五）一般模式切换到编辑模式的操作 进入插入模式（６个命令） 【i】 从目前光标所在处插入【I】 从目前光标【a】 从当前光标所在的下一个字符处开始插入【A】 从光标所在行的最后一个字符处开始插入【o】 英文小写字母o，在目前光标所在行的下一行处插入新的一行并开始插入【O】 英文大写字母O，在目前光标所在行的上一行处插入新的一行并开始插入 进入替换模式（2个命令） 【r】 只会替换光标所在的那一个字符一次【R】 会一直替换光标所在字符，直到按下[ESC]键为止【[ESC]】 退出编辑模式回到一般模式 （六）一般模式切换到命令行模式 【:w】 保存文件【:w!】 若文件为只读，强制保存文件【:q】 离开vi【:q!】 不保存强制离开vi【:wq】 保存后离开【:wq!】 强制保存后离开【:! command】 暂时离开vi到命令行下执行一个命令后的显示结果【:set nu】 显示行号【:set nonu】 取消显示行号【:w newfile】 另存为 (十一)vim配置文件 vim的配置文件为/etc/vimrc，但一般不建议直接修改这个文件，而是在用户根目录下创建一个新的隐藏文件： $ vim ~/.vimrc # 然后编辑这个文件，常用的配置如下： \"双引号后面的内容为注释 set ts=4 \" 设置tab为4个空格 set expandtab \" TAB替换为空格 %retab! \" 加!是用于处理非空白字符之后的TAB，即所有的TAB，若不加!，则只处理行首的TAB。 set nu \"显示行号 set hlsearch \"查找的字符串反白显示 set backspace=2 \"可随时用退格键进行删除 set autoindent \"自动缩排 set ruler \"在最下方一行显示状态 set showmode \"在左下角显示模式 set bg=dark \"显示不同的底色，还可以为light syntax on \"语法检验，颜色显示 --------------------------------- set nocompatible \" 关闭 vi 兼容模式 syntax on \" 自动语法高亮 colorscheme molokai \" 设定配色方案 set number \" 显示行号 set cursorline \" 突出显示当前行 set ruler \" 打开状态栏标尺 set shiftwidth=4 \" 设定 > 命令移动时的宽度为 4 set softtabstop=4 \" 使得按退格键时可以一次删掉 4 个空格 set tabstop=4 \" 设定 tab 长度为 4 set nobackup \" 覆盖文件时不备份 set autochdir \" 自动切换当前目录为当前文件所在的目录 filetype plugin indent on \" 开启插件 set backupcopy=yes \" 设置备份时的行为为覆盖 set ignorecase smartcase \" 搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感 set nowrapscan \" 禁止在搜索到文件两端时重新搜索 set incsearch \" 输入搜索内容时就显示搜索结果 set hlsearch \" 搜索时高亮显示被找到的文本 set noerrorbells \" 关闭错误信息响铃 set novisualbell \" 关闭使用可视响铃代替呼叫 set t_vb= \" 置空错误铃声的终端代码 \" set showmatch \" 插入括号时，短暂地跳转到匹配的对应括号 \" set matchtime=2 \" 短暂跳转到匹配括号的时间 set magic \" 设置魔术 set hidden \" 允许在有未保存的修改时切换缓冲区，此时的修改由 vim 负责保存 set guioptions-=T \" 隐藏工具栏 set guioptions-=m \" 隐藏菜单栏 set smartindent \" 开启新行时使用智能自动缩进 set backspace=indent,eol,start \" 不设定在插入状态无法用退格键和 Delete 键删除回车符 set cmdheight=1 \" 设定命令行的行数为 1 set laststatus=2 \" 显示状态栏 (默认值为 1, 无法显示状态栏) set statusline=\\ % @=((foldclosed(line('.')) \" 用空格键来开关折叠 参考链接 http://www.cnblogs.com/jiayongji/p/5771444.htmlhttp://www.cnblogs.com/wangj08/archive/2013/03/13/2957309.html 编写 https://blog.csdn.net/qq_38597315/article/details/80627439 https://lzw.me/a/vim-shortcut.html https://blog.csdn.net/ljx_5489464/article/details/50896080 https://blog.csdn.net/xyw_blog/article/details/15550149 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/linux/012-virtualbox虚拟机、centos7安装增强工具.html":{"url":"doc/linux/012-virtualbox虚拟机、centos7安装增强工具.html","title":"virtualbox虚拟机、centos7安装增强工具","keywords":"","body":" 设置终端启动快捷键 添加virtualbox 增强工具 设置共享文件夹 virtualBox语言设置 virtualbox -> file -> perferences -> language ->选择对应的语言 -> OKvirtualbox -> 管理 -> 全局设定 -> 语言 -> 选择相应的语言 -> OK 设置终端启动快捷键 http://www.centoscn.com/CentOS/config/2015/0330/5044.html 1. 首先打开Applications,选择System Tools 2. 选择Setting进入下面界面 3. 选择Keyboard，进入下面界面，点击Shortcuts 4. 再点击+号，弹出对话框 5. Name： Run a Terminal Command: /usr/bin/gnome-terminal (Terminal 程序的路径） 点击apply 6. 一开始是禁用（disabled）的,点击disabled出现下面情形,此时按下你喜欢的快捷键比如Ctrl+Alt+T, 在virtualbox虚拟机中，如果鼠标指针出不来， 按键盘上右边的 alt+ctrl。 添加virtualbox 增强工具 http://www.tuicool.com/articles/VRbq2em $ sudo yum update $ sudo yum install gcc kernel-devel kernel-headers dkms make bzip2 $ reboot 1.点击虚拟机左上角的 Devices ,选择：insert guest addition CD image 2.进入到虚拟机中运行这个镜像自动安装。 设置共享文件夹 http://www.cnblogs.com/zqifa/p/linux-virtualbox-1.html http://www.cnblogs.com/jenry/archive/2013/09/06/3305062.html 1.在VirtualBox的菜单点击\"设备(Devices)\" -> 分配数据空间(Shared Folders)菜单，添加一个共享文件夹，选项固定和临时是指该文件夹是否是持久的。尽量使用英文名称。我这里用winshare. 2. 重新进入虚拟CentOs5.5，在命令行终端下输入： #sudo mkdir /mnt/share #sudo mount -t vboxsf winshare /mnt/share 如果提示 /sbin/mount.vboxsf: mounting failed with the error: No such device 可能是没有载入内核模块 vboxfs ，先查看下： #lsmod | grep vboxsf 如果没有结果返回，说明 vboxsf没有载入，执行 #sudo modprobe vboxsf 正常的话mount -t vboxsf winshare /mnt/share共享文件夹应该可以访问了 #cd /mnt/share #ls -al 假如您不想每一次都手动挂载，可以在/etc/fstab中添加一项 share /mnt/share vboxsf rw,gid=100,uid=1000,auto 0 0 这样就能够自动挂载了。 ssh,IP地址可以访问虚拟机设置 1.VirtualBox Version 5.1.82.virtualbox -> file -> perferences -> network -> Host-only Network -> add new host only network http://blog.csdn.net/astrotycoon/article/details/8143146 http://blog.csdn.net/ixidof/article/details/12685549 虚拟机磁盘扩容 http://blog.csdn.net/ganshuyu/article/details/17954733 $ VBoxManage list hdds # 在列出的信息中找到需要的虚拟机，复制UUID $ VBoxManage modifyhd a0f06f66-f696-41dc-827a-e79bee50f65b --resize 51200 # 操作成功后该虚拟的硬盘即增加了50G，但要注意了，此50G空间还没有分配. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/npm/001-NPM使用介绍.html":{"url":"doc/npm/001-NPM使用介绍.html","title":"NPM使用介绍","keywords":"","body":" 1. 常用命令 2. cnpm 介绍 3. npm一些命令介绍 一、npm install 安装原理 二、npm update 三、registry 四、缓存目录 五、模块的安装过程 六、--cache-min 参数 七、离线安装的解决方案 上文内容的网址 4. 更换npm的源地址 加快国内安装速度 5. npm的其他配置:关闭进度条，看见每一个请求 5.1 运行 npm config set loglevel http 让你知道 npm 发的每一个请求 5.2 运行 npm config set progress false 关闭那个无聊的进度条 参考链接 目录 [TOC] 1. 常用命令 ~ npm install express // 安装express到项目中，安装的是最新版本 ~ npm install express@3.0.6 // 安装express的3.0.6版本， 安装特定版本 ~ npm install -g // 将包安装到全局环境中 ~ npm install lodash --save // save 在package.json文件的dependencies字段添加该package的名称和版本号 ~ npm install lodash --save-dev // 在package.json文件的devDependencies字段添加该package的名称和版本号 ~ npm i -g // 将包安装到全局环境中 i 是 install 的缩写，如果用i失败，则用install试试 ~ npm init // 会引导你创建一个package.json文件，包括名称、版本、作者这些信息等 ~ npm remove // 移除 ~ npm uninstall lodash // 卸载lodash ~ npm uninstall --save lodash // save 卸载的同时想把这个package包的信息从package.json文件的dependencies字段中也一并删除 ~ npm update // 更新 ~ npm root // 查看当前包的安装路径 ~ npm ls // 列出当前安装的了所有包 ~ npm root // 查看当前包的安装路径 ~ npm help // 帮助，如果要单独查看install命令的帮助，可以使用的npm help install ~ which npm // 确认我们现在用的npm是来自哪个目录 ~ npm --version // 查看版本 ~ npm list // 列出自己项目已经安装过的模块 ~ npm list --depth 1 // 列出已安装的包，深度1 ~ npm list -g --depth 0 // 全局包 ~ npm search mkdir // 搜索mkdir是否存在 npm 命令参数： -g：全局安装。 --save：将保存配置信息至package.json（package.json是nodejs项目配置文件）； -dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点； 2. cnpm 介绍 说明：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” 这就是cnpm. 官方网址：http://npm.taobao.org 安装：命令提示符执行npm install cnpm -g --registry=https://registry.npm.taobao.org或npm i -g cnpm 安装完后最好查看其版本号cnpm -v或关闭命令提示符重新打开，安装完直接使用有可能会出现错误 cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 3. npm一些命令介绍 一、npm install 安装原理 npm install 命令用来安装模块到node_modules目录。安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 $ npm install --force 二、npm update 如果想更新已安装模块，就要用到npm update命令。 $ npm update 它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。 三、registry npm update命令怎么知道每个模块的最新版本呢？答案是 npm 模块仓库提供了一个查询服务，叫做 registry 。以 npmjs.org 为例，它的查询服务网址是 :https://registry.npmjs.org/这个网址后面跟上模块名，就会得到一个 JSON 对象，里面是该模块所有版本的信息。比如，访问https://registry.npmjs.org/react ，就会看到 react 模块所有版本的信息。它跟下面命令的效果是一样的。 $ npm view react # npm view 的别名 $ npm info react $ npm show react $ npm v react registry 网址的模块名后面，还可以跟上版本号或者标签，用来查询某个具体版本的信息。比如， 访问 https://registry.npmjs.org/react/v0.14.6 ，就可以看到 React 的 0.14.6 版。返回的 JSON 对象里面，有一个dist.tarball属性，是该版本压缩包的网址。 dist: { shasum: '2a57c2cf8747b483759ad8de0fa47fb0c5cf5c6a', tarball: 'http://registry.npmjs.org/react/-/react-0.14.6.tgz' }, 到这个网址下载压缩包，在本地解压，就得到了模块的源码。npm install和npm update命令，都是通过这种方式安装模块的。 四、缓存目录 npm install或npm update命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。 $ npm config get cache $HOME/.npm 你最好浏览一下这个目录。 $ ls ~/.npm # 或者 $ npm cache ls 你会看到里面存放着大量的模块，储存结构是{cache}/{name}/{version}。 $ npm cache ls react ~/.npm/react/react/0.14.6/ ~/.npm/react/react/0.14.6/package.tgz ~/.npm/react/react/0.14.6/package/ ~/.npm/react/react/0.14.6/package/package.json 每个模块的每个版本，都有一个自己的子目录，里面是代码的压缩包package.tgz文件，以及一个描述文件package/package.json。除此之外，还会生成一个{cache}/{hostname}/{path}/.cache.json文件。比如，从 npm 官方仓库下载 react 模块的时候，就会生成registry.npmjs.org/react/.cache.json文件。这个文件保存的是，所有版本的信息，以及该模块最近修改的时间和最新一次请求时服务器返回的 ETag 。 { \"time\":{ \"modified\":\"2016-01-06T23:52:45.571Z\", // ... }, \"_etag\":\"\\\"7S37I0775YLURCFIO8N85FO0F\\\"\" } 对于一些不是很关键的操作（比如npm search或npm view），npm会先查看.cache.json里面的模块最近更新时间，跟当前时间的差距，是不是在可接受的范围之内。如果是的，就不再向远程仓库发出请求，而是直接返回.cache.json的数据。.npm目录保存着大量文件，清空它的命令如下。 $ rm -rf ~/.npm/* # 或者 $ npm cache clean 五、模块的安装过程 Node模块的安装过程是这样的: 1. 发出npm install命令 2. npm 向 registry 查询模块压缩包的网址 3. 下载压缩包，存放在~/.npm目录 4. 解压压缩包到当前项目的node_modules目录 注意，一个模块安装以后，本地其实保存了两份。一份是~/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。但是，运行npm install的时候，只会检查node_modules目录，而不会检查~/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。这种行为固然可以保证总是取得最新的代码，但有时并不是我们想要的。最大的问题是，它会极大地影响安装速度。即使某个模块的压缩包就在缓存目录中，也要去远程仓库下载，这怎么可能不慢呢？另外，有些场合没有网络（比如飞机上），但是你想安装的模块，明明就在缓存目录之中，这时也无法安装。 六、--cache-min 参数 为了解决这些问题，npm 提供了一个--cache-min参数，用于从缓存目录安装模块。--cache-min参数指定一个时间（单位为分钟），只有超过这个时间的模块，才会从 registry 下载。 $ npm install --cache-min 9999999 上面命令指定，只有超过999999分钟的模块，才从 registry 下载。实际上就是指定，所有模块都从缓存安装，这样就大大加快了下载速度。它还有另一种写法: $ npm install --cache-min Infinity 但是，这并不等于离线模式，这时仍然需要网络连接。因为现在的--cache-min实现有一些问题。 （1）如果指定模块不在缓存目录，那么 npm 会连接 registry，下载最新版本。这没有问题，但是如果指定模块在缓存目录之中，npm 也会连接 registry，发出指定模块的 etag ，服务器返回状态码304，表示不需要重新下载压缩包。 （2）如果某个模块已经在缓存之中，但是版本低于要求，npm会直接报错，而不是去 registry 下载最新版本。 npm 团队知道存在这些问题，正在重写 cache。并且，将来会提供一个--offline参数，使得 npm 可以在离线情况下使用。不过，这些改进没有日程表。所以，当前使用--cache-min改进安装速度，是有问题的。 七、离线安装的解决方案 社区已经为npm的离线使用，提出了几种解决方案。它们可以大大加快模块安装的速度。解决方案大致分成三类。 npm-proxy-cache local-npm用法 npm-lazy 上面三个模块的用法很类似，都是在本机起一个 Registry 服务，所有npm install命令都要通过这个服务代理。 上文内容的网址 http://www.ruanyifeng.com/blog/2016/01/npm-install.html 4. 更换npm的源地址 加快国内安装速度 查看npm包的源地址（包下载地址）： npm config get registry https://registry.npmjs.org/ 更换npm的源地址: // 淘宝源 npm config set registry https://registry.npm.taobao.org // 自己本来的源 npm config set registry https://registry.npmjs.org/ 参考链接：http://blog.csdn.net/v2810769/article/details/52585662 5. npm的其他配置:关闭进度条，看见每一个请求 5.1 运行 npm config set loglevel http 让你知道 npm 发的每一个请求 5.2 运行 npm config set progress false 关闭那个无聊的进度条 运行 npm config set registry https://registry.npm.taobao.org/ ， 从淘宝的服务器下载各种包。不过这会让你在运行 npm adduser 的时候出问题，想要恢复成原样，只需要运行 npm config delete registry 即可。 运行npm config get 运行 touch ~/.bashrc; echo 'export PHANTOMJS_CDNURL=\"http://npm.taobao.org/mirrors/phantomjs\"' >> ~/.bashrc 让 npm 从淘宝下载 phantomjs 运行 touch ~/.bashrc; echo 'export SASS_BINARY_SITE=\"https://npm.taobao.org/mirrors/node-sass\"' >> ~/.bashrc 让 npm 从淘宝下载 SASS 运行 source ~/.bashrc,应用上面的设置 参考链接 http://blog.csdn.net/haidaochen/article/details/8546796/http://www.nodeclass.com/articles/810142http://www.cnblogs.com/jiuyi/p/5353676.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/npm/002-NPM常见问题.html":{"url":"doc/npm/002-NPM常见问题.html","title":"NPM常见问题","keywords":"","body":" NPM常见问题 1. 使用淘宝源安装包出错 2. listen EADDRINUSE 服务端口被占用报错 3. npm start 启动后保存频繁，导致内存溢出 [TOC] NPM常见问题 1. 使用淘宝源安装包出错 使用npm安装webpack包的时候，发生了错误 npm install webpack --save-dev // 发生如下错误 events.js:160░░░░░░⸩ ⠸ extract:repeat-string: sill extract remove-trailing-sepa throw er; // Unhandled 'error' event ^ Error: write after end at writeAfterEnd (_stream_writable.js:193:12) at PassThrough.Writable.write (_stream_writable.js:240:5) at PassThrough.Writable.end (_stream_writable.js:477:10) 后来查看安装源是淘宝的，换源可以解决这个问题： 设置npmjs的源(可能需要VPN)，如果https不行就换成http的。 // 查看安装源 npm config get registry // 设置npm自己的源 npm config set registry https://registry.npmjs.org/ npm config set registry http://registry.npmjs.org/ // 设置为淘宝源 npm config set registry https://registry.npm.taobao.org/ npm config set registry http://registry.npm.taobao.org/ 这个问题有的时候会发生，有时没问题，看人品了。 还有一种情况，使用淘宝源： 使用公司网络安装失败，但是使用自己网络则安装成功。 2. listen EADDRINUSE 服务端口被占用报错 npm start > webpack-dev-server --config ./config/webpack.config.dev.js events.js:160 throw er; // Unhandled 'error' event ^ Error: listen EADDRINUSE 127.0.0.1:8080 at Object.exports._errnoException (util.js:1018:11) at exports._exceptionWithHostPort (util.js:1041:20) at Server._listen2 (net.js:1258:14) at listen (net.js:1294:10) 当使用npm start启动一个web开发服务时，显示上面错误，经查找是端口(8080)被占用了。 解决方法： 换一个端口，重新运行即可。 找到被占用的端口，关掉占用的端口，重新运行即可。 // 查看是哪个进程占用的端口 ~ sudo lsof -n -P | grep :8080 node 6534 dragon 14u IPv4 0x3cf6bb332552824d 0t0 TCP 127.0.0.1:8080 (LISTEN) // 关闭这个服务 kill -9 6534 3. npm start 启动后保存频繁，导致内存溢出 当使用npm start启动服务后，由于修改代码，导致服务频繁编译，由此导致内存溢出错误： ==== JS stack trace ========================================= Security context: 0x15d948ca5879 0: builtin exit frame: stringify(this=0x15d948c890a9 ,0x15d93d0022d1 ,0x15d93d0022d1 ,0x15d9bb6172e9 ) 1: arguments adaptor frame: 1->3 2: /* anonymous */(aka /* anonymous */) [/Users/dragon/work/owl-changshachaonao/node_modules/webpack/lib/EvalSourceMapDevToolModuleTemplatePlugin.js:103] [bytecode=0x15d9f3... FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 1: node::Abort() [/usr/local/bin/node] 2: node::FatalException(v8::Isolate*, v8::Local, v8::Local) [/usr/local/bin/node] 3: v8::internal::V8::FatalProcessOutOfMemory(char const*, bool) [/usr/local/bin/node] 4: v8::internal::Factory::NewRawTwoByteString(int, v8::internal::PretenureFlag) [/usr/local/bin/node] 5: v8::internal::String::SlowFlatten(v8::internal::Handle, v8::internal::PretenureFlag) [/usr/local/bin/node] 解决办法： 1、node v8.0以上版本支持在环境变量中设置最大内存： export NODE_OPTIONS=--max_old_space_size=4096 如果是mac电脑，可在终端环境脚本中添加上面命令，然后重启终端： vi .zshrc export NODE_OPTIONS=--max_old_space_size=10240 2、安装increase-memory-limitnpm包，使用该包增加运行内存： // 全局安装increase-memory-limit npm install -g increase-memory-limit // 进入工程目录，执行： increase-memory-limit 注意： increase-memory-limit命令会操作node_modules里面对应文件， 这个方法可能会导致，git提交需要预先检查的命令冲突，导致报错，解决方法是删除node_modules文件夹，重新安装一个就好 参考资料：https://blog.csdn.net/liub37/article/details/82866763 powered by Gitbook文件最后修改时间： 2020-01-02 11:09:19 "},"doc/npm/003-package.json文件详解.html":{"url":"doc/npm/003-package.json文件详解.html","title":"package.json文件详解","keywords":"","body":" package.json介绍 name version description keywords homepage bugs license 和用户相关的属性: author, contributors files main bin man directories repository scripts config dependencies URLs as Dependencies Git URLs as Dependencies GitHub URLs Local Paths devDependencies peerDependencies bundledDependencies optionalDependencies engines os cpu preferGlobal private publishConfig DEFAULT VALUES 本文参考链接 package.json介绍 package.json文件描述了一个NPM包的所有相关信息，包括作者、简介、包依赖、构建等信息。格式必须是严格的JSON格式。通常我们在创建一个NPM程序时，可以使用npm init命令，通过交互式的命令，自动生成一个package.json文件，里面包含了常用的一些字段信息，但远不止这么简单。通过完善package.json文件，我们可以让npm命令更好地为我们服务。在终端输入npm init会询问package.json的各种信息，从而确认。如果全部使用默认值，可以直接在终端输入npm init –y快速生成package.json。 name package.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则: name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。 name不能以\"_\"或\".\"开头 不能含有大写字母 name会成为url的一部分，不能含有url非法字符 下面是官网文档的一些建议： 不要使用和node核心模块一样的名称 name中不要含有\"js\"和\"node\"。 It's assumed that it's js, since you're writing a package.json file, and you can specify the engine using the \"engines\" field. (See below.) name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以\"_\"或\".\"开头 name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/ name属性可以有一些前缀如 e.g. @myorg/mypackage在npm-scope(7)的文档中可以看到详细说明 version version必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块 description 一个描述，方便别人了解你的模块作用，搜索的时候也有用。包的描述信息，将会在npm search的返回结果中显示，以帮助用户选择合适的包。 keywords 一个字符串数组，方便别人搜索到本模块.包的关键词信息，是一个字符串数组，同上也将显示在npm search的结果中。 homepage 项目主页url注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 bugs 填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如： bugs: { \"url\": \"http://github.com/ijse/project/issues\", \"email\": \"my@ijser.cn\" } url和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。 license 你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：{ \"license\" : \"BSD-3-Clause\" }你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。 和用户相关的属性: author, contributors \"author\"是一个码农， \"contributors\"是一个码农数组。 \"person\"是一个有一些描述属性的对象，如下 like this: author: { \"name\": \"ijse\", \"email\": \"my@ijse.cn\", \"url\": \"http://www.ijser.cn\" } 也可以按如下格式缩写，npm会帮着转换:\"author: Barney Rubble b@rubble.com (http://barnyrubble.tumblr.com/)\"email和url属性实际上都是可以省略的。描述用户信息的还有一个\"maintainers\"（维护者）属性。 files \"files\"属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）.你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以\".\"开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法.gitignore类似。 main main属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(\"foo\")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。 bin 很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）,如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下： { \"bin\" : { \"myapp\" : \"./cli.js\" } } 模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如： { \"name\": \"my-program\" , \"version\": \"1.2.5\" , \"bin\": \"./path/to/program\" } 作用和如下写法相同: { \"name\": \"my-program\" , \"version\": \"1.2.5\" , \"bin\" : { \"my-program\" : \"./path/to/program\" } } man 制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如: { \"name\" : \"foo\" , \"version\" : \"1.2.3\" , \"description\" : \"A packaged foo fooer for fooing foos\" , \"main\" : \"foo.js\" , \"man\" : \"./man/doc.1\" } 通过man foo命令会得到 ./man/doc.1 文件的内容。如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置： { \"name\" : \"foo\" , \"version\" : \"1.2.3\" , \"description\" : \"A packaged foo fooer for fooing foos\" , \"main\" : \"foo.js\" , \"man\" : [ \"./man/foo.1\", \"./man/bar.1\" ] } 会创建一些文件来作为man foo和man foo-bar命令的结果。man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。 { \"name\" : \"foo\" , \"version\" : \"1.2.3\" , \"description\" : \"A packaged foo fooer for fooing foos\" , \"main\" : \"foo.js\" , \"man\" : [ \"./man/foo.1\", \"./man/foo.2\" ] } 会创建 man foo 和 man 2 foo 两条命令。 directories CommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。下级字段可以是：lib, bin, man, doc, example。 每个都是字符串directories.lib: 告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。directories.bin: 如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。directories.man: 指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。directories.doc: 在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）directories.example: 放一些示例脚本，或许某一天会有用 - -！ repository 指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样： \"repository\" : { \"type\" : \"git\" , \"url\" : \"https://github.com/npm/npm.git\" } \"repository\" : { \"type\" : \"svn\" , \"url\" : \"https://v8.googlecode.com/svn/trunk/\" } 若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成： \"repository\": \"npm/npm\" \"repository\": \"gist:11081aaa281\" \"repository\": \"bitbucket:example/repo\" \"repository\": \"gitlab:another/repo\" scripts scripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见https://docs.npmjs.com/misc/scripts config 用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：http.createServer(...).listen(process.env.npm_package_config_port)可以通过npm config set foo:port 80来修改config。详见 https://docs.npmjs.com/misc/config { \"name\" : \"foo\" , \"config\" : { \"port\" : \"8080\" } } dependencies dependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。dependencies也可以被指定为一个git地址或者一个压缩包地址。不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见 https://docs.npmjs.com/misc/semver version 精确匹配版本 version 必须大于某个版本 =version 大于等于 ~version \"约等于\"，具体规则详见semver文档 ^version \"兼容版本\"具体规则详见semver文档 1.2.x 仅一点二点几的版本 http://... 见下面url作为denpendencies的说明 任何版本 \"\" 空字符，和*相同 version1 - version2 相当于 >=version1 range1 || range2 范围1和范围2满足任意一个都行 git... 见下面git url作为denpendencies的说明 user/repo See 见下面GitHub仓库的说明 tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags path/path/path 见下面本地模块的说明 下面的写法都是可以的: { \"dependencies\" : { \"foo\" : \"1.0.0 - 2.9999.9999\" , \"bar\" : \">=1.0.2 1.0.2 =2.3.1 =2.5.2 URLs as Dependencies 在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。 Git URLs as Dependencies Git url可以像下面一样: git://github.com/user/project.git#commit-ish git+ssh://user@hostname:project.git#commit-ish git+ssh://user@hostname/project.git#commit-ish git+http://user@hostname/project/blah.git#commit-ish git+https://user@hostname/project/blah.git#commit-ish commit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。 GitHub URLs 支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签： { \"name\": \"foo\", \"version\": \"0.0.0\", \"dependencies\": { \"express\": \"visionmedia/express\", \"mocha\": \"visionmedia/mocha#4727d357ea\" } } Local Paths npm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下： ../foo/bar ~/foo/bar ./foo/bar /foo/bar package.json 生成的相对路径如下: { \"name\": \"baz\", \"dependencies\": { \"bar\": \"file:../foo/bar\" } } 这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。 devDependencies 如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。例如: { \"name\": \"ethopia-waza\", \"description\": \"a delightfully fruity coffee varietal\", \"version\": \"1.2.3\", \"devDependencies\": { \"coffee-script\": \"~1.6.3\" }, \"scripts\": { \"prepublish\": \"coffee -o lib/ -c src/waza.coffee\" }, \"main\": \"lib/waza.js\" } prepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。 peerDependencies 有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require(\"grunt\")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies： { \"name\": \"tea-latte\", \"version\": \"1.3.5\", \"peerDependencies\": { \"tea\": \"2.x\" } } 上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的：├── tea-latte@1.3.5└── tea@2.2.0这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。 bundledDependencies 上面的单词多个d，写成bundleDependencies也可以。指定发布的时候会被一起打包的模块。 optionalDependencies 如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如： try { var foo = require('foo') var fooVersion = require('foo/package.json').version } catch (er) { foo = null } if ( notGoodFooVersion(fooVersion) ) { foo = null } // .. then later in your program .. if (foo) { foo.doFooThings() } optionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。 engines 你可以指定项目运行的node版本范围，如下：{ \"engines\" : { \"node\" : \">=0.10.3 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。也可以指定一些npm版本可以正确的安装你的模块，例如：{ \"engines\" : { \"npm\" : \"~1.0.20\" } }要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。 os 可以指定你的模块只能在哪个操作系统上跑：\"os\" : [ \"darwin\", \"linux\" ]也可以指定黑名单而不是白名单：\"os\" : [ \"!win32\" ]服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞... cpu 限制模块只能在某某cpu架构下运行\"cpu\" : [ \"x64\", \"ia32\" ]同样可以设置黑名单:\"cpu\" : [ \"!arm\", \"!mips\" ]cpu架构通过 process.arch 判断 preferGlobal 如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。 private 如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。 publishConfig 这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。 DEFAULT VALUES npm设置了一些默认参数，如：\"scripts\": {\"start\": \"node server.js\"}如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。\"scripts\":{\"preinstall\": \"node-gyp rebuild\"}如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本\"contributors\": [...]若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释 本文参考链接 http://www.cnblogs.com/tzyy/p/5193811.htmlhttp://ju.outofmemory.cn/entry/130809http://www.nodepeixun.com/a/nodejiaocheng/20170218/158.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/npm/004-NPM常用的包.html":{"url":"doc/npm/004-NPM常用的包.html","title":"NPM常用的包","keywords":"","body":" 1. git-open:直接在终端打开git网站 2. http-server:启动本地服务 3. 多个CSS类名合并 [TOC] 1. git-open:直接在终端打开git网站 https://www.npmjs.com/package/git-open 可以直接在终端中使用命令打开项目在github上的网站 安装、使用命令： // 全局安装 npm i -g git-open // 使用 git open 2. http-server:启动本地服务 https://www.npmjs.com/package/http-server 可以在前端打包的项目中运行此命令后启动一个服务，然后在浏览器中查看打包的页面效果 安装、使用命令： // 安装 npm install http-server -g // 使用 http-server http-server [path] [options] 3. 多个CSS类名合并 https://www.npmjs.com/package/classnames 可以根据不同的条件拼接成不同的字符串，主要用于有多个样式类时，根据不同的类显示不同的样式类。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/001-Chrome浏览器开发者工具使用.html":{"url":"doc/other/001-Chrome浏览器开发者工具使用.html","title":"Chrome浏览器开发者工具使用","keywords":"","body":" 1. 打开chrome的开发者工具 2. Console部分的使用 2.1 直接使用标签的ID名字即可调出该标签的dom 2.1 页面跳转后，输出的console记录保留 3. 利用开发者工具截取页面 3.1 截取整个页面：Capture full size screenshot 3.2 截取页面中的一些元素 [TOC] 1. 打开chrome的开发者工具 网页右键 -> 最下面的'检查'，就能调出开发者工具 直接按Option + Command + J（Mac）或者Ctrl + Shift + J（Windows / Linux）。 Chrome菜单-> View -> Developer - > Developer Tools, 或者Option + Command + I（Mac）以及Ctrl + Shift + I（Windows / Linux）。 http://javascript.ruanyifeng.com/introduction/intro.html#toc10 2. Console部分的使用 2.1 直接使用标签的ID名字即可调出该标签的dom 如123，可直接输入app即可查看该标签的dom 2.1 页面跳转后，输出的console记录保留 点击右边齿轮图标，然后选择preserve log 然后在切换页面后，所有输出的log记录都会保留。 3. 利用开发者工具截取页面 3.1 截取整个页面：Capture full size screenshot 打开 Chrome 浏览器，进入需要截图的网站页面 等待页面加载完毕后，通过下面方法打开开发者工具：在页面任何地方点击鼠标右键，在弹出菜单中选择“检查（Inspect）”选项。或者使用快捷键组合：Alt + Command + I (Mac) 或 Ctrl + Shift + I (Windows) 使用快捷键组合来打开命令行（command palette）：Command + Shift + P (Mac) 或 Ctrl + Shift + P (Windows) 在命令行中输入“Screen”，这时自动补齐功能会显示出一些包含 \"Screen\" 关键字的命令。移动方向键到“Capture full size screenshot”并回车（或直接用鼠标点击这个选项） 参考资料：https://weibo.com/ttarticle/p/show?id=2309404241869646237445 3.2 截取页面中的一些元素 进入需要截图的网站页面，打开开发者工具（方法和上面两步相同） 点击开发者工具左上角的“选取元素”按钮，在网页中点击要截图的元素 由于 HTML 父子元素的嵌套，可能选中的是需要截图元素的子元素。这时，需要在开发者工具中对所选取的元素进行调整：由于选取的是子元素，所以只需要在“选取元素”按钮，旁边的\"Elements Tab\"里边按照嵌套关系，找到合适的父元素就可以了。这时，点击选中该父元素。 打开命令行，进行截图命令（方法和上面第四步类似）。不过需要注意这时在包含 \"Screen\" 关键字的命令中选取“Capture node screenshot” powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/002-Chrome浏览器有用的插件.html":{"url":"doc/other/002-Chrome浏览器有用的插件.html","title":"Chrome浏览器有用的插件","keywords":"","body":" 1. github网站实现树状文件列表 octotree 2. Postman API接口测试插件 3. LastPass浏览器账号密码管理插件 4. Tampermonkey油猴插件 5. 恢复关闭的标签页 SimpleUndoClose 6. 多标签页管理TooManyTabs for Chrome 7.多标签页管理Tabs Outliner 8. 页面去除广告 9. Qlearly 空白页管理tab标签和书签 10. 截取整个网页 [TOC] 1. github网站实现树状文件列表 octotree Octotree这款插件就如同名字一样，在页面左端提供了一个树状的文件列表（类似Windows资源管理器的左栏），从而让所有文件的位置一目了然，并可以快速点击查看。 开源地址： https://github.com/buunguyen/octotree 在Google中搜索Octotree 就能找到， 同时还有一个码云版的GitCodeTree如果用码云可以安装这个。 github的其他插件： https://www.ithome.com/html/soft/310078.htm 2. Postman API接口测试插件 3. LastPass浏览器账号密码管理插件 LastPass: Free Password Manager 中文官网：https://www.lastpass.com/zh 插件安装好后，点击插件登陆，当第一次登陆网站输入账号密码结束后，插件会提示你是否保存账号，如果保存，那么下次在登录网站后就会自动田填充账号密码。 教程：https://blog.csdn.net/u012318074/article/details/77972074 4. Tampermonkey油猴插件 它既可以让你看各大视频网站的 VIP 付费视频，阻止浏览器的各种弹窗，也可以让你直接在浏览器就可以下载百度云盘的大号文件，不再需要跳往百度云盘客户端才能下载，最重要的是它可以让你百度云盘不再限速，也可以直接加速播放视频等等。...... 安装：chrome应用商店中搜索Tampermonkey， 点击安装。 Tampermonkey 使用方法， 进入相关网站后，插件就会自动运行，然后在网页中会有相应按钮。 插件网站：https://greasyfork.org/zh-CN 使用教程： https://zhuanlan.zhihu.com/p/34967781 http://www.pc6.com/infoview/Article_115189.html 5. 恢复关闭的标签页 SimpleUndoClose 安装：chrome应用商店中搜索SimpleUndoClose， 点击安装。 使用：点击插件图标，就会显示关闭的标签页列表，选择要恢复的页面即可。 6. 多标签页管理TooManyTabs for Chrome 安装：chrome应用商店中搜索TooManyTabs for Chrome， 点击安装。 使用：点击图标，选择对应的标签页可。 点击每个图标右上角的黄色箭头，可以把这个标签放在缓存中，暂时关闭，在点击一下即可恢复。 使用教程：http://www.cnplugins.com/office/toomanytabs-for-chrome/ 缺点：只会显示当前窗口中的标签页 7.多标签页管理Tabs Outliner 安装：chrome应用商店中搜索Tabs Outliner， 点击安装。 使用：点击图标，会弹出一个新窗口，里面会显示浏览器打开的所有tabs。 8. 页面去除广告 安装：chrome应用商店中搜索广告终结者， 点击安装。 广告终结者 其他去广告的插件：https://www.jianshu.com/p/ecfd133ee48e AdGuard 广告拦截器 9. Qlearly 空白页管理tab标签和书签 Qlearly - Tab and Bookmark Manager 方便的管理当前打开的tab标签页面，可以一键保存打开的tab页面，还可以管理特殊的标签。 10. 截取整个网页 Chrome浏览器自带截取整个页面的工具： 打开开发者工具(Mac：cmd + option + I，Windows：F12) 打开命令面板： Mac：shift + cmd + P, windows:Ctrl + Shift + P 输入截图命令：输入capture,会看到三个命令， capture full size screenshot:截图整个网页图片 capture node screenshot：截取当前节点的图片 capture area screenshot: 截取鼠标选择的区域 但是自带的工具有的页面不能截取全部页面。 Full Page Screen Capture Full Page Screen Capture插件可以解决截取全部页面图片的问题。安装好后，只需要点击就可截取网页全部内容，然后选择保存图片或者保存文PDF格式。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/003-gitbook入门教程.html":{"url":"doc/other/003-gitbook入门教程.html","title":"gitbook入门教程","keywords":"","body":" 前期准备 创建一本书 注册gitbook账号 创建一本新书 前期准备 使用gitbook需要你会Git、Markdown、github。 创建一本书 注册gitbook账号 进入官网：https://www.gitbook.com/ ，选择使用github账号登陆。 ![](http://p1ibqa9uh.bkt.clouddn.com/18-1-11/14299485.jpg)注册图片 第一次会需要github网站的认证，还需要到邮箱中点击确认。 创建一本新书 登陆之后点击右上角的 + new按钮，在创建新书页面选择github，第一次需要点击右边的install github integration。 ![](http://p1ibqa9uh.bkt.clouddn.com/18-1-11/78857353.jpg)图片 此时会跳转到github页面去安装这个插件，可以选择所有仓库货某个仓库，然后点击install安装,输入github密码后完成安装。 ![](http://p1ibqa9uh.bkt.clouddn.com/18-1-11/26589194.jpg)图片 此时回到github页面刷新，选择github后，右边会出现title标题、description描述选择仓库等选项，然后点击create book按钮。注意title不能使用中文（后期可以修改成中文）。 ![](http://p1ibqa9uh.bkt.clouddn.com/18-1-11/88871190.jpg)图片 稍等一会gitbook就会完成，此时从新打开gitbook网页，然后点击刚创建的书，然后点击edit按钮，然后点击add an article按钮， 随便创建一个文件，然后点击右上角的publish按钮，此时回到github项目中，可以看见会出现一个新的文件SUMMARY.md文件，这个文件就是目录文件。 参考链接 http://blog.csdn.net/hk2291976/article/details/51173850http://www.ituring.com.cn/article/127744https://www.jianshu.com/p/7476afdd9248 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/004-常用正则表达式.html":{"url":"doc/other/004-常用正则表达式.html","title":"常用正则表达式","keywords":"","body":"验证帐号是否合法验证规则：字母、数字、下划线组成，字母开头，4-16位。 re = /^[a-zA-z]\\w{3,15}$/; 验证手机号码验证规则：11位数字，以1开头。re = /^1\\d{10}$/ 验证电话号码验证规则：区号+号码，区号以0开头，3位或4位,号码由7位或8位数字组成区号与号码之间可以无连接符，也可以“-”连接,如01088888888,010-88888888,0955-7777777re = /^0\\d{2,3}-?\\d{7,8}$/; 验证邮箱验证规则：姑且把邮箱地址分成“第一部分@第二部分”这样第一部分：由字母、数字、下划线、短线“-”、点号“.”组成，第二部分：为一个域名，域名由字母、数字、短线“-”、域名后缀组成，而域名后缀一般为.xxx或.xxx.xx，一区的域名后缀一般为2-4位，如cn,com,net，现在域名有的也会大于4位 re = /^(\\w-.)+@(\\w-?)+(.\\w{2,})+$/ 不能输入汉字：^\\u4e00-\\u9fa5{0,}$只能输入汉字：^[\\u4e00-\\u9fa5]{0,}$ 只有字母、数字和下划线且不能以下划线开头和结尾的正则表达式：^(?!)(?!.*?$)[a-zA-Z0-9]+$只有字母和数字的： ^[a-zA-Z0-9]+$至少一个汉字、数字、字母、下划线: \"[a-zA-Z0-9\\u4e00-\\u9fa5]+\"至少一个汉字的正则表达式：\"^[\\u4e00-\\u9fa5]\"最多10个汉字: ValidationExpression=\"^[\\u4e00-\\u9fa5]{0,10}\"只含有汉字、数字、字母、下划线不能以下划线开头和结尾：^(?!)(?!.?$)[a-zA-Z0-9\\u4e00-\\u9fa5]+$解释：^ 与字符串开始的地方匹配(?!)　　不能以开头(?!.?$)　　不能以结尾[a-zA-Z0-9_\\u4e00-\\u9fa5]+　　至少一个汉字、数字、字母、下划线$　　与字符串结束的地方匹配 email正则表达式：两种方式都可以(1) \\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)(2) ^[_A-Za-z0-9-]+(\\.[_A-Za-z0-9-]+)@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)*((\\.[A-Za-z]{2,}){1}$) /内容/i 构成一个不区分大小写的正则表达式;^ 匹配开始$ 匹配结束表示0个或多个前面的字符.[a-z0-9] 匹配0个或多个英文字母或者数字[-_]? 匹配0个或1“-”，因为“-”不能连续出现[a-z0-9]+ 匹配1个或多个英文字母或者数字，因为“-”不能做为结尾[.] 将特殊字符(.)当成普通字符[a-z]{2,3} 匹配2个至3个英文字母，一般为com或者net等. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/005-HTTP方法详解.html":{"url":"doc/other/005-HTTP方法详解.html","title":"HTTP方法详解","keywords":"","body":" 名词解释 1. OPTIONS 2. GET 3. HEAD 4. POST 5. PUT 6. DELETE 7. TRACE 按照RFC2616的排序，HTTP的方法包括：OPTIONS，GET，HEAD，POST，PUT，DELETE，TRACE。 名词解释 安全性：客户端可以发起请求，并知道它不会改变资源的状态。 幂等性：保证客户端重复发起某个请求的效果与一次请求的效果一致。 1. OPTIONS 使用该方法来获取资源支持的HTTP方法列表，或者ping服务器。显然，它就是一个纯粹的信息读取的操作，不改变资源的状态，同时保证幂等性。 请求：只有header没有body。 响应：默认只有header，但是也可以在body中添加内容，比如描述性文字 安全：是 幂等：是 2. GET 该方法用以获取资源的表述。简单的资源信息读取，不对资源状态造成影响，保证幂等性。 请求：只有header，没有body。 响应：对应请求URI的资源表述，通常带有body。响应header中的Content-Type，Content-Length，Content-Language，Last-Modified，ETag等应该和响应body的表述一致。 安全：是 幂等：是 3. HEAD 使用该方法可以获取与GET响应相同的header，但是响应中没有任何body。简单的资源信息读取，不对资源状态造成影响，保证幂等性。 请求：只有header，没有body。 响应：只有header，没有body。服务器不能添加body。 安全：是 幂等：是 4. POST 让资源在服务器上执行一系列操作，如创建新资源、更新资源、变更资源等。是一个资源写的操作，改变了资源的状态，同事HTTP标准设定POST方法为非幂等，也就是说不需要在实现服务端响应方法的时候，我们不需要保证幂等，这也就避免了很多冗余信息(我们会在DELETE中看到)。 请求：一个资源的表述。 响应：一个资源的表述，或是一个重定向指令。如果body中存在表述，则其URI和请求URI不一致，包含一个带有改资源URI的Content-Location头。 安全：否 幂等：否 5. PUT 完整地更新或替换一个现有资源，也可以用客户端制定的URI来创建一个新资源。和POST方法一样，PUT方法也改变了资源的状态，所以是非安全的。但是有一点和POST不同，它是幂等的，这是为什么呢？想想setter函数吧，重复调用，只要参数是一样的，表述就是不变的。 请求：一个资源的表述。请求的body可以与客户端后续收到的GET请求一样,当然，也可以不一样。在某些情况下，服务器也可要求客户端只提供资源的可变部分。 响应：更新的状态。可在响应中包含被更新资源的完整表述，但是客户端不能假设响应中包含完整状态，除非响应有一个Content-Location头。如果服务器没有包含这个头，客户端必须提交一个无条件GET请求来获取更新后的表述，带有Last-Modified和/或ETag头。 安全：否 幂等：是 6. DELETE 使用该方法来删除资源。对于客户端而言，资源在成功响应后，就不复存在了。和POST方法一样，DELETE方法也改变了资源的状态，所以是非安全的。但是有一点和POST不同，它是幂等的，也就是说，就算是服务器在前一个请求中已经删除了资源，它也必须返回200.这就意味着，我们在实现服务端的该方法是，需要跟踪已经删除的资源，否则就会返回404的。 请求：只有header，没有body。 响应：成功或失败。body中可以包含操作的状态。 安全：否 幂等：是 7. TRACE 回显服务器接收到的header。支持该方法的服务器可能存在XST安全隐患。 安全： 幂等： 请求：header与body。 响应：body中包含整个请求消息。 参考链接： http://www.tuicool.com/articles/3eaUJbu powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/006-Markdown常用语法与编辑器支持情况.html":{"url":"doc/other/006-Markdown常用语法与编辑器支持情况.html","title":"Markdown常用语法与编辑器支持情况","keywords":"","body":" 脚注语法 支持的编辑器： bitbucket、www.zybuluo.com 表格 支持的情况：bitbucket、github、https://www.zybuluo.com、VSCODE、 html语法的支持 HTML的表格 支持的编辑器： github、码云、www.zybuluo.com 目录 [TOC] 脚注语法 需要脚注的地方： 这是一个注脚[^footnote]的样例。 这是第二个注脚[^footnote2]的样例。 md文档最下面写明脚注： [^footnote]: 这是一个 *注脚* 的 **文本**。 [^footnote2]: 这是另一个 *注脚* 的 **文本**。 支持的编辑器： bitbucket、www.zybuluo.com 不支持的网站：https://github.com ， 码云网站wiki不行。 表格 语法： -------:为右对齐。 :------为左对齐。 :------:为居中对齐。 -------为使用默认居中对齐。 | 项目 | 价格 | 数量 | | -------- | -----: | :----: | | 计算机 | \\$1600 | 5 | | 手机 | \\$12 | 12 | | 管线 | \\$1 | 234 | 效果： 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 支持的情况：bitbucket、github、https://www.zybuluo.com、VSCODE、 html语法的支持 HTML的表格 值班人员 星期一 星期二 星期三 李强 张明 王平 支持的编辑器： github、码云、www.zybuluo.com powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/007-VS2010编译器设置.html":{"url":"doc/other/007-VS2010编译器设置.html","title":"VS2010编译器设置","keywords":"","body":" 字体设置 显示行号 vs2010 瘦身--ipch文件夹和sdf文件配置 字体设置 https://jingyan.baidu.com/article/4ae03de31cd98b3eff9e6bfd.html 工具 -> 选项 -> 环境 -> 字体和颜色 显示行号 https://jingyan.baidu.com/article/a378c96085a247b3282830e9.html 工具 -> 选项 -> 文本编辑器-> 所有语言 -> 显示：行号 vs2010 瘦身--ipch文件夹和sdf文件配置 http://blog.csdn.net/yizhou2010/article/details/52743578 将ipch文件夹和sdf文件放置在固定的目录下，定期清理。设置如下：工具（Tools）->选项（Options）->文本编辑器（Text Editor）-> C/C++ -> 高级（Advanced），在”回退位置（Fallback Location）”的属性组中，将”始终使用回退位置（Always Use Fallback Location）”设置为 true，将”回退位置已在使用时，不警告（Do Not Warn If Fallback Location Used）” 设置为 true ，然后删除解决方案目录下的 sdf 文件和 ipch 目录，再次打开解决方案，发现这些烦人的东西已经不见了。 那么那些文件放置到那里了呢？看 “回退位置（Fallback Location）” 属性说明：这是存储浏览信息数据库和 IntelliSense 文件的第二个位置，如果不指定则放置到临时目录中；到临时目录一看，里面有一个 VC++ 的目录，都在那个目录里面呢。可以在 “回退位置（Fallback Location）” 属性中，设置一个固定的路径来存储这些文件，比如D:\\VS2010Temp，这样也比较好管理这些庞大的臃肿的文件，可以定期清理掉它们，释放出硬盘空间！ powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/008-VS2010开发控制台程序遇到的问题.html":{"url":"doc/other/008-VS2010开发控制台程序遇到的问题.html","title":"VS2010开发控制台程序遇到的问题","keywords":"","body":" fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include \"stdafx.h vs2012 error c4996: 'fopen': This function or variable may be unsafe [TOC] fatal error C1010: 在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include \"stdafx.h 1) 在解决方案资源管理器中，右击相应的.cpp文件，点击“属性”2) 在左侧配置属性中，点开“C/C++”，单击“预编译头”3) 更改右侧第一行的“创建/使用预编译头”，把选项从“使用预编译头（/Yu）”改成“不使用预编译头”4) 注：每一个报错的.cpp都要如此更改 vs2012 error c4996: 'fopen': This function or variable may be unsafe 错误信息: 1>------ 已启动生成: 项目: 20130925, 配置: Debug Win32 ------ 1> stdafx.cpp 1>d:\\code\\20130925\\20130925\\stdafx.cpp(18): error C4996: 'fopen': This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. 1> d:\\vs2012\\vc\\include\\stdio.h(218) : 参见“fopen”的声明 1> 20130925.cpp 1> 正在生成代码... ========== 生成: 成功 0 个，失败 1 个，最新 0 个，跳过 0 个 ========== 解决方法：项目 =》属性 =》c/c++ =》预处理器=》点击预处理器定义，编辑，加入_CRT_SECURE_NO_WARNINGS，即可。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/009-阻止定向广告.html":{"url":"doc/other/009-阻止定向广告.html","title":"阻止定向广告","keywords":"","body":" 使用Chrome浏览器并登陆账号了 百度搜索关闭定向广告 必应搜索引擎关闭定向广告 使用Chrome浏览器并登陆账号了 https://support.google.com/ads/answer/2662922?hl=zh-Hans 在这里页面里面 -> 如果你已经登陆自己的Google账户 -> 广告设置 -> 广告个性化 - 关闭 百度搜索关闭定向广告 打开百度 -> 最下面的 '使用百度前必读' -> 隐私保护声明 -> 大约中间位置'个性化配置' -> 选择停用 必应搜索引擎关闭定向广告 打开必应搜索 -> 页面最下面'隐私声明和Cookie' -> 在’如何访问和控制你的个人数据‘里面选择 '选择退出页面' -> 此浏览器中基于兴趣的广告 关闭 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/010-英文字母缩写的含义.html":{"url":"doc/other/010-英文字母缩写的含义.html","title":"英文字母缩写的含义","keywords":"","body":" ORM ORM（Object Relational Mapping）：对象关系映射ORM框架：对象-关系映射（Object/Relation Mapping，简称ORM），是随着面向对象的软件开发方法发展而产生的。面向对象的开发方法是当今企业级应用开发环境中的主流开发方法，关系数据库是企业级应用环境中永久存放数据的主流数据存储系统。对象和关系数据是业务实体的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在关联和继承关系，而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，对象-关系映射(ORM)系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。ORM方法论基于三个核心原则： 简单性：以最基本的形式建模数据。 传达性：数据库结构被任何人都能理解的语言文档化。 精确性：基于数据模型创建正确标准化了的结构。 http://blog.csdn.net/titilover/article/details/6911756http://www.cnblogs.com/wisdo/p/4279091.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/other/011-VUE开发遇见的问题.html":{"url":"doc/other/011-VUE开发遇见的问题.html","title":"VUE开发遇见的问题","keywords":"","body":" VUE组件模板中只能有一个根元素：Component template should contain exactly one root element VUE组件模板中只能有一个根元素：Component template should contain exactly one root element 报错的信息： (Emitted value instead of an instance of Error) Error compiling template: 找回密码 - Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. @ ./src/views/view-reset/ViewReset.vue 11:0-371 @ ./src/router/index.js 错误的原因是一个VUE组件的模板中只能有一个根元素，不能出现多个元素，正确的写法： 我是头部导航栏 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/work/001-工作常用代码片段.html":{"url":"doc/work/001-工作常用代码片段.html","title":"工作常用代码片段","keywords":"","body":" 工作常用代码片段 1. 一个get请求 [TOC] 工作常用代码片段 1. 一个get请求 // actionTypes.js 文件 // 获取图谱数据 export const GET_CY_DATA_SCOPE_BATTLE_MAP = 'SAVE_GRAPH_DATA_INDUSTRY_MAP' // actionCreator.js文件 import { createActions, createAction } from 'framework' import { GET_CY_DATA_SCOPE_BATTLE_MAP } from './actionTypes' const actionCreator = createActions({ getGraphData: { url: '/api/pmsView', method: 'GET', actionType: GET_CY_DATA_SCOPE_BATTLE_MAP }, }) export default actionCreator // 组件文件 getCyData = () => { const { getGraphData } = this.props getGraphData({ params: { start: 0, end: 0, } }) .then(res => { if (res.statusCode === 200) { console.log('res: ', res) } }) } powered by Gitbook文件最后修改时间： 2019-12-17 09:50:31 "},"doc/work/002-开发注意事项.html":{"url":"doc/work/002-开发注意事项.html","title":"开发注意事项","keywords":"","body":" 开发注意事项 1. 代码规范相关 1.1 react propTypes属性书写顺序 1.2 组件使用类还是函数 1.3 一个组件代码行数不超过300行 1.4 JSX中HTML中不要是用内联样式 1.5 component文件里面不允许出现js文件，只能有一个.jsx文件 [TOC] 开发注意事项 1. 代码规范相关 1.1 react propTypes属性书写顺序 有.isRequired的在下面，没有isRequired的在上面，例如： Component.propTypes = { getWorkProcessList: PropTypes.func, projectName: PropTypes.string, currWorkProcessTableInfo: PropTypes.object, importProcessDefinition: PropTypes.func.isRequired, getAlertGroupList: PropTypes.func.isRequired, getWorkGroupList: PropTypes.func.isRequired, } WorkflowDefinitionTablePanel.defaultProps = { projectName: '', getWorkProcessList: noop, currWorkProcessTableInfo: {} } 1.2 组件使用类还是函数 当一个组件不需要state，不需要生命周期时使用函数试组件，否则使用类 1.3 一个组件代码行数不超过300行 1.4 JSX中HTML中不要是用内联样式 1.5 component文件里面不允许出现js文件，只能有一个.jsx文件 powered by Gitbook文件最后修改时间： 2019-12-18 10:27:46 "},"doc/work/003-类和模块.html":{"url":"doc/work/003-类和模块.html","title":"类和模块","keywords":"","body":" 类和模块 1. 类和原型 [TOC] 类和模块 每个JS对象都是一个属性集合，相互之间没有任何联系。JS中可以定义对象的类，让每个对象共享某些属性， 类和原型 类和构造函数 JS中Java式的类继承 类的扩充 类和类型 JS中面向对象技术 子类 ECMAScript5中的类 模块 1. 类和原型 // inherit()返回了一个继承自原型对象p的属性的新对象 // 这里使用ECMAScript 5中的Object.create()函数(如果存在的话) // 如果不存在Object.create()，则退化使用其他方法 function inherit(p){ if(p == null)throw TypeError(); // p是一个对象，但不能是null if(Object.create) // 如果Object.create()存在 return Object.create(p); // 直接使用它 var t = typeof p; // 否则进行进一步检测 if(t !== \"object\" && t !== \"function\")throw TypeError(); function f(){}; // 定义一个空构造函数 f.prototype = p; //将其原型属性设置为p return new f(); //使用f()创建p的继承对象 } // 这个工厂方法返回一个新的\"范围对象\" function range(from, to){ // 使用inherit()函数来创建对象，这个对象继承自在下面定义的原型对象 // 原型对象作为函数的一个属性存储，并定义所有\"范围对象\"所共享的方法(行为) var r = inherit(range.methods); // 存储新的\"范围对象\"的起始位置和结束位置(状态) // 这两个属性是不可继承的，每个对象都拥有唯一的属性 r.from = from; r.to = to; // 返回这个新创建的对象 return r; } // 原型对象定义方法，这些方法为每个范围对象所继承 range.methods = { // 如果x在范围内，则返回true；否则返回false, 这个方法可以比较数字范围，也可以比较字符串和日期范围 includes: function(x){ return this.from true: 2 在这个范围内 r.foreach(console.log); // 输出 1 2 3 console.log(r); // 输出(1...3) powered by Gitbook文件最后修改时间： 2019-12-22 16:13:15 "},"doc/work/004-项目常用的配置.html":{"url":"doc/work/004-项目常用的配置.html","title":"项目常用的配置","keywords":"","body":" 项目常用的配置 1. iconfont图标的更新 [TOC] 项目常用的配置 1. iconfont图标的更新 1、从iconfont网站把项目下载下来，然后解压 2、把.eot、.svg、.ttf、.woff、.woff2字体文件复制到项目的字体文件夹中src/css/fonts 3、在下载的文件中，打开iconfont.css文件，从 // 大约18行，开始，一直到文件底部复制 .caiman-chakan:before { content: \"\\e689\"; } 把选中的文件放到src/css/common/plugins/_font-caiman.scss对应位置，一般会有标记，替换就好了 powered by Gitbook文件最后修改时间： 2019-12-25 15:41:34 "},"doc/angular/001-angularJS资料.html":{"url":"doc/angular/001-angularJS资料.html","title":"angularJS资料","keywords":"","body":" angular4 工作 angular2下arcgis开发 angular2相关资料 Bootstrap JavaScript JavaScript视频教程 TypeScript HTML CSS 菜鸟教程 http://www.runoob.com/ 手册网 http://www.shouce.ren/ w3school http://www.w3school.com.cn/ return home 目录结构 [TOC] angular4 angular-CLI中一些问题 网页编程中HTML,CSS中遇到的问题 工作 angularJS开发遇见的问题 web前端生产环境打包部署 Mac下angular开发环境安装 工作开发参考这个是工作中开发的参考文档 angular2开发知识点API 网关地址 配置，服务注册使用，模块组件注册使用，CSS样式条件绑定，阻止点击事件冒泡 angular2网页前端执行流程 html常用正则表达式 angular2中引入插件jQuery, easyui， ngx-img: 图片上传插件 TS_JS中一些知识点 jas前端样式规范 前端编程规范 码云前端文档 angular2下arcgis开发 arcgis开发记录 aangular下arcgis开发遇见的问题 angular2相关资料 NPM使用介绍 NPM安装包常见问题 package.json文件详解 angularJS官方文档https://angular.cn/https://angular.cn/docs/ts/latest/ 这个里面包含： 快速起步 开发指南 API 参考 (v2.4.5) 大漠穷秋angular2示例有视频教程 http://git.oschina.net/mumu-osc/NiceFish Angular2优质学习资源收集 https://my.oschina.net/mumu/blog/831790 编辑器： 下载地址： https://code.visualstudio.com帮助文档：https://code.visualstudio.com/docs AngularJS执行流程详解 http://www.cnblogs.com/shytong/p/5011411.html Webpack入门 http://www.cnblogs.com/kagol/archive/2016/01/23/5152734.html rxjs官方文档中文翻译(observable可观察对象) https://www.gitbook.com/book/buctwbzs/rxjs/details Promise 对象 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise Bootstrap http://www.bootcss.com/ 全局 CSS 样式：http://v3.bootcss.com/css/ JavaScript javascript一些问题立即执行函数 JavaScript语法 怎么轻松学习JavaScript this 的值到底是什么？ 什么是 JS 原型链？ JS 的 new 到底是干什么的？ JavaScript 教程(菜鸟教程)： http://www.runoob.com/js/js-tutorial.html JavaScript 教程(手册网)： http://www.shouce.ren/api/view/a/823 AngularJS教程、实例、参考手册(手册网) http://www.shouce.ren/api/view/a/3079 廖雪峰 JavaScript教程(手册网) http://www.shouce.ren/api/view/a/13858 JavaScript 语言参考(微软文档)： https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspxJavaScript 语言参考， JavaScript 基础， 高级 JavaScript， JavaScript 参考， JavaScript 参考手册(w3school)：http://www.w3school.com.cn/jsref/index.asp AngularJS 参考手册(w3school)： http://www.w3cschool.cn/angularjs/angularjs-reference.html JavaScript： https://developer.mozilla.org/zh-CN/docs/learn/JavaScript JavaScript 指南： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide本指南分为以下章节： 介绍， 语法与数据类型， 控制流与错误处理， 循环与迭代， 函数， 表达式和运算符， 数字和日期， 文本格式化索引集合， 键值集合， 处理对象， 对象模型的细节， 迭代器与生成器， 元 (meta) 编程 JavaScript视频教程 JavaScript深入浅出http://www.imooc.com/learn/277 JavaScript基础教程 http://www.jikexueyuan.com/course/179.html TypeScript入门http://www.imooc.com/learn/763 TypeScript TypeScript官方文档： https://www.tslang.cn/docs/tutorial.html ECMAScript 6 入门 http://es6.ruanyifeng.com/ REPL在线编译器，可以在线将 ES6 代码转为 ES5 代码http://babeljs.io/ 30分钟掌握ES6/ES2015核心内容 : http://www.jianshu.com/p/ebfeb687eb70 HTML CSS CSS 资源大全中文版 JavaScript 资源大全中文版 JavaScript深入系列、JavaScript专题系列、ES6系列、React系列 菜鸟教程 http://www.runoob.com/ HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 网页的行为 AngularJS 教程 ： http://www.runoob.com/angularjs/angularjs-tutorial.html AngularJS2 教程http://www.runoob.com/angularjs2/angularjs2-tutorial.html HTML 教程- (HTML5 标准)： http://www.runoob.com/html/html-tutorial.html CSS 教程： http://www.runoob.com/css/css-tutorial.html 手册网 http://www.shouce.ren/ 参考手册速查 http://www.shouce.ren/api/index CSS参考手册： http://www.shouce.ren/docs/css/ HTML 教程： http://www.shouce.ren/api/view/a/7 HTML快速参考手册： http://www.shouce.ren/api/html/kuaisu/ w3school http://www.w3school.com.cn/ HTML 参考手册：http://www.w3school.com.cn/tags/index.asp CSS 参考手册：http://www.w3school.com.cn/cssref/index.asp Web API 接口： https://developer.mozilla.org/zh-CN/docs/Web/API CSS参考手册： http://css.doyoe.com/ powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/002-angularJS开发遇见的问题.html":{"url":"doc/angular/002-angularJS开发遇见的问题.html","title":"angularJS开发遇见的问题","keywords":"","body":" 1、开发环境下 npm install 编译进行一半就停止 2、 WEBPACK_EXTERNAL_MODULE_XX is not defined 3、Angular2管理外部类型定义和处理“Duplicate identifier” TypeScript错误 4、Module build failed: TypeError: Cannot read property 'exclude' of undefined 5、Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime 6、Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 6.x 7、DI错误 8. error：cannot find defined file ‘jquery’ 9. Error: No NgModule metadata found for '[object Object]' 10. TypeError: Cannot read property 'split' of undefined 11. 模板语法绑定错误 12. 浏览器不识别大写地址，如big-Data， 13. Refused to display 'URL' in a frame because it set 'X-Frame-Options' to 'sameorigin' 13. cnpm安装报错：Install fail! Error: EACCES: permission denied, 14. ng serve:Error: Cannot find module 'color-convert' [TOC] 1、开发环境下 npm install 编译进行一半就停止 问题分析：npm install 包没有安装完全， 解决方法 删除项目目录下面的 node_modules 文件夹，运行命令：npm install，npm start，多试几次。 更换npm安装源： # 安装npm 镜像源管理包 ~ npm install nrm -g # 下面命令会列出npm镜像源 ~ nrm ls # 选择淘宝的镜像源 ~ nrm use taobao 然后从复方法一的步骤，尝试10次后就不要再尝试了，说明这个方法不管用。 从同事那里把已经成功的 node_modules 文件夹 复制过来，放到工程目录下面，然后运行命令：# 如果操作系统不同，就需要运行下面的命令来从新绑定系统 ~ npm rebuild node-sass # 启动命令 ~ npm start 2、 WEBPACK_EXTERNAL_MODULE_XX is not defined 解决方法：https://stackoverflow.com/questions/39103483/uncaught-referenceerror-webpack-external-module-xx-is-not-defined/39105605#39105605The solution was to set libraryTarget: 'amd' in the webpack.config.js file like so: output: { filename: 'dist/[name].bundle.js', libraryTarget: 'amd' }, 3、Angular2管理外部类型定义和处理“Duplicate identifier” TypeScript错误 https://segmentfault.com/a/1190000007560996 4、Module build failed: TypeError: Cannot read property 'exclude' of undefined 这个错误是由于awesome-typescript-loader package导致的，解决方法：编辑文件~/node_modules/awesome-typescript-loader/dist/instance.js:https://github.com/s-panferov/awesome-typescript-loader/issues/293大约是142行，替换applyDefaults 函数体内容： function applyDefaults(configFilePath, compilerConfig, loaderConfig) { _.defaults(compilerConfig.options, { sourceMap: true, verbose: false, skipDefaultLibCheck: true, suppressOutputPathCheck: true }); if (loaderConfig.transpileOnly) { compilerConfig.options.isolatedModules = true; } _.defaults(compilerConfig.options, { sourceRoot: compilerConfig.options.sourceMap ? process.cwd() : undefined }); _.defaults(loaderConfig, { sourceMap: true, verbose: false, }); delete compilerConfig.options.outDir; delete compilerConfig.options.inlineSourceMap; delete compilerConfig.options.outFile; delete compilerConfig.options.out; delete compilerConfig.options.noEmit; } 保存后，从新运行命令 npm start即可解决问题。 5、Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime 根据链接：https://github.com/sass/node-sass/releases/tag/v3.13.1可知道是node版本太高了，卸载node后，下载低版本的node即可解决问题。 6、Node Sass could not find a binding for your current environment: OS X 64-bit with Node.js 6.x 根据错误提示,终端运行npm rebuild node-sass即可解决这个问题。 7、DI错误 这个错误由于使用了服务， 但是这个服务没有引入到模块中，找到服务，并把服务引入到模块中就好。 8. error：cannot find defined file ‘jquery’ 运行npm start时报错，错误信息： @types\\fullcalendar\\index.d.ts cannot find type definition file for 'jquery', Module ''*'' has no exported member 'Duration' Module ''*'' has no exported member 'Moment' 解决方案： 在tsconfig.json 文件中 添加下面语句： \"typeRoots\": [ \"node_modules/@types\" ], 9. Error: No NgModule metadata found for '[object Object]' 错误原因 在添加新模块的时候，模块类名 前面没有加default关键字，如： export class UserDetailModule { } 解决方法 在模块类名前面加上关键字default： export default class UserDetailModule { } 10. TypeError: Cannot read property 'split' of undefined 错误原因： 使用split方法的元素是个undefined; 解决方法 在使用split方法前，先判断元素是否为空。 11. 模板语法绑定错误 错误代码Html文件 {{value.text}} ts文件 public value: any; 正确写法： {{value?.text}} 或者 {{value.text}} ？.是angular提供的安全导航操作符，用来保护出现在属性路径中的null和undefined值 12. 浏览器不识别大写地址，如big-Data， 如在浏览器中输入http://localhost:3000/#/big-Data， Google浏览器会先把big-data,然后去匹配路径，导致angular路由 无法匹配转到了默认路径上， 所以最好不要有大写字母存在。 13. Refused to display 'URL' in a frame because it set 'X-Frame-Options' to 'sameorigin' 触发原因：页面的返回头被设置 X-Frame-Options SAMEORIGIN ，只能被同源的iframe 引用。跨域名的iframe 没法显示了。 这个在angular中， 本地开发中webpack中配置代理， 服务器中 Nginx中配置代理即可解决问题。 13. cnpm安装报错：Install fail! Error: EACCES: permission denied, 使用速度命令安装：sudo cnpm i 14. ng serve:Error: Cannot find module 'color-convert' 使用npm命令安装这个缺少的包：sudo cnpm i color-convert powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/003-arcgis开发记录.html":{"url":"doc/angular/003-arcgis开发记录.html","title":"arcgis开发记录","keywords":"","body":" arcgis JavaScript API安装 1. arcgisAPI下载地址：https://developers.arcgis.com/downloads/ 2. 4.4版本API：本地配置 3. 3.18版本修改方法 angular2中加载arcgis JS API * arcgis加载图层 并显示图层上点的信息* 使用图层上默认的参数，来显示图层上点的信息 更好的方案： 使用 arcgis 地图的 点击事件，来个性化弹窗 添加图层的时候可以调用方法，把所有点的 信息全部得到 arcgis地图坐标系。 没毛病 目录 [TOC] arcgis JavaScript API安装 1. arcgisAPI下载地址：https://developers.arcgis.com/downloads/ 打开网站后选择‘ArcGIS API for JavaScript’，如果不要最新版则点击后面的‘All versions’，选择一个自己需要的版本。 4.4版本的下载地址 2. 4.4版本API：本地配置 下载好后，把解压后的文件中 library目录拷贝到 angular2的src目录下(与index.html同级)， 打开文件library/4.4/dojo/dojo.js baseUrl:\"http://localhost:3000/library/4.4/dojo\",hasCache:{\"config-deferredInstrumentation\":0,\"config-selectorEngine\":\"acme\", 搜索内容 https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo 把这个字符串替换成 http://localhost:3000/library/4.4/dojo保存后退出。 打开文件library/4.4/init.js 搜索内容 https://[HOSTNAME_AND_PATH_TO_JSAPI]dojo 把这个字符串替换成 http://localhost:3000/library/4.4/dojo保存后退出。 3. 3.18版本修改方法 打开文件library/4.4/dojo/dojo.js baseUrl:((location.protocol === 'http:' || location.protocol === 'https:') ? location.protocol : 'http:') + '//' + \"localhost:3000/library/3.18/dojo\",hasCache:{\"config-selectorEngine\":\"acme\", 搜索内容 [HOSTNAME_AND_PATH_TO_JSAPI] 把这个字符串替换成 localhost:3000/library/4.4/dojo保存后退出。注意：一定不要加http:// 打开文件library/4.4/init.js 搜索内容 [HOSTNAME_AND_PATH_TO_JSAPI] 把这个字符串替换成 localhost:3000/library/4.4/dojo保存后退出。注意：一定不要加http:// 测试API是否成功 启动服务后，在浏览器中输入网址： http://localhost:3000/library/4.4/init.js如果有返货内容则说明部署成功。 angular2中加载arcgis JS API angular2里面需要先安装 arcgis 的包 # 介绍： https://www.npmjs.com/package/angular2-esri-loader npm install angular2-esri-loader esri-loader 在组件中加载 arcgis的 API， 加载好后就可以在其他方法中直接使用了： private loadEsriModules() { //来自：https://github.com/StefanNieuwenhuis/awesome-mapping-app this.esriLoader.load({ // url: 'https://js.arcgis.com/4.4/' }).then(() => { this.esriLoader.loadModules([ 'esri/Map', 'esri/layers/MapImageLayer', //地图 图层服务 'esri/views/MapView', //2D地图 'esri/views/SceneView', //3D地图 //https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#source \"esri/layers/FeatureLayer\", //提取图层服务 \"esri/widgets/Home\", //在视图中出现一个回到原点的按钮Home \"esri/widgets/BasemapGallery\", \"esri/widgets/Expand\", \"esri/widgets/Search\",//地点搜索 \"esri/widgets/ScaleBar\",//比例尺 \"esri/core/watchUtils\", //鹰眼图 \"dojo/dom\", //鹰眼图 ]).then(([Map, MapImageLayer, MapView, SceneView, FeatureLayer, Home, BasemapGallery, Expand, Search, ScaleBar, watchUtils, dom]) => { this.esriMap = Map; this.esriMapImageLayer = MapImageLayer; this.esriMapView = MapView; this.esriSceneView = SceneView; this.esriFeatureLayer = FeatureLayer; this.esriHome = Home; this.esriBasemapGallery = BasemapGallery; this.esriExpand = Expand; this.esriSearch = Search; this.esriScaleBar = ScaleBar; this.esriwatchUtils = watchUtils; this.esridom = dom; this.arcGisLoadFinish = true; }) }) } arcgis加载图层 并显示图层上点的信息 参考链接：https://developers.arcgis.com/javascript/latest/sample-code/featurelayerview-query/index.html 使用图层上默认的参数，来显示图层上点的信息 addMapLayre() { this.view.map.removeAll(); let popupTemplate = { title: 'Cities', content: \" 城市: {CITY_NAME}\" + \" LABEL_FLAG: {LABEL_FLAG}\" + \" OBJECTID: {OBJECTID}\" + \" POP: {POP}\" + \" POP_CLASS: {POP_CLASS}\" + \" POP_RANK: {POP_RANK}\" }; for (let e of this.layerBtnListsSelect) { if (e.data && e.data.url) { //https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#properties-summary let layer = new this.esriFeatureLayer({ outFields: [\"*\"], //把每个点的所有属性都查询出来。 popupTemplate: popupTemplate, //弹窗模板 url: e.data.url //图层服务地址 }); this.view.map.add(layer); // adds the layer to the map //下面注销掉的代码可以查看全部点的信息 // this.view.whenLayerView(layer).then(function (lyrView) { // lyrView.watch(\"updating\", function (val) { // if (!val) { // wait for the layer view to finish updating // lyrView.queryFeatures().then(function (results) { // console.log(results); // prints all the client-side graphics to the console // }); // } // }); // }); } } } 使用这个方法好处 ：简单，方便。坏处： 1. 要根据不同的图层来制作不同的弹窗模板。 2. 弹窗样式固定。 更好的方案： 使用 arcgis 地图的 点击事件，来个性化弹窗 参考链接：https://geonet.esri.com/message/609517#comment-609517 https://developers.arcgis.com/javascript/latest/api-reference/esri-views-View.html#on let _view = this.view; this.view.on(\"click\", function (event) { _view.hitTest(event.screenPoint).then(function (response) { var graphics = response.results; graphics.forEach(function (graphic) { console.log(graphic); }); }); }); 在这里使用view 的 on事件，当点击地图上一个点的时候，如果这个点事图层上的点，则会出发这个事件， 如果不是，则没有有反应。一个例子： https://developers.arcgis.com/javascript/latest/sample-code/view-hittest/index.html 添加图层的时候可以调用方法，把所有点的 信息全部得到 https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html#querying // returns all the graphics from the layer view // lyr: 创建的图层 new FeatureLayer({...}) view.whenLayerView(lyr).then(function(lyrView){ lyrView.watch(\"updating\", function(val){ if(!val){ // wait for the layer view to finish updating lyrView.queryFeatures().then(function(results){ console.log(results); // prints all the client-side graphics to the console }); } }); }); arcgis地图坐标系。 参考链接： https://developers.arcgis.com/javascript/3/jsapi/screenpoint-amd.htmlhttps://developers.arcgis.com/javascript/latest/api-reference/esri-Viewpoint.html 没毛病 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/004-angular2开发知识点.html":{"url":"doc/angular/004-angular2开发知识点.html","title":"angular2开发知识点","keywords":"","body":" 一、API 网关地址 配置 二、服务注册使用 三、模块组件注册使用 四、html中style类动态绑定 1. 单个类的绑定：[class.special]=\"isSpecial\" 2. 多个类的绑定：[ngClass]=\"{'selected':status === '','saveable': this.canSave,}\" 3. 单个内联样式绑定：[style.color]=\"isSpecial ? 'red': 'green'\" 4. 多个内联样式绑定：[ngStyle]=\"currentStyles\" angular2 第三方插件的使用 1. 安装插件： 2. 模块中引入prime 3. 在组件中使用插件 angular中阻止点击事件冒泡 目录 [TOC] 一、API 网关地址 配置 cloudlink-front-framework/config/webpack.dev.js # line 13 ~ 19 /** * Webpack Constants */ const ENV = process.env.ENV = process.env.NODE_ENV = 'development'; const HOST = process.env.HOST || 'localhost'; const PORT = process.env.PORT || 3000; const HMR = helpers.hasProcessFlag('hot'); # line 150 ~ 171 devServer: { port: METADATA.port, host: METADATA.host, historyApiFallback: { index: '/index.html' }, watchOptions: { aggregateTimeout: 300, poll: 1000 }, proxy: { '/cloudlink/v1/**': { target: 'http://192.168.100.90:8050', // target: 'http://192.168.120.110:8050', // target: 'http://192.168.20.221:8901', //赵杨 ip // target: 'http://192.168.100.212:8050', secure: false, pathRewrite: { '^/cloudlink/v1': '' } } } }, 二、服务注册使用 如上图所示，先有一个模型跟服务，需要在enterprise-auth/enterprise-authed-approve里面使用：模型使用： # enterprise-admin/enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 只需要在这个文件中写如下代码即可： import {EnterpriseAdminModel} from \"../shared/enterprise-admin.model\"; 服务的使用： 注意： 如果服务里面又引入服务，那么在使用这个服务时，也要导入引入的服务。 # 服务的依赖注入： https://angular.cn/docs/ts/latest/guide/dependency-injection.html # 方法一： 直接在组件中引入使用 # enterprise-admin/enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 在文件中写入如下代码： import {EnterpriseAdminService} from \"../shared/enterprise-admin.service\"; # 导入服务文件 @Component({ selector: \"jas-enterprise-authed-approve\", templateUrl: \"./enterprise-authed-approve.component.html\", styleUrls: [\"./enterprise-authed-approve.component.css\"], providers:[EnterpriseAdminService] # 在这里写上服务名字 }) ------------------------------------------------------------------------------------------ # 方法二： 在组件的所在的模块中注册服务后，在组件中直接使用 # enterprise-auth/enterprise-auth.module.ts # 在文件中写入如下代码： import { EnterpriseAdminService } from './shared/enterprise-admin.service'; @NgModule({ imports: [ ], declarations: [ ], providers:[EnterpriseAdminService ] # 引入声明 }) # enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 在文件中写入如下代码： import {EnterpriseAdminService} from \"../shared/enterprise-admin.service\"; # 引入使用 ------------------------------------------------------------------------------------------ # 方法三：在组件的所在的模块中为服务申明一个名字，在子模块中直接用这个名字调用 # enterprise-auth/enterprise-auth.module.ts # 在文件中写入如下代码： mport { EnterpriseAdminService } from './shared/enterprise-admin.service'; @NgModule({ providers:[ {provide:'view',useClass:EnterpriseAdminService} # 引入声明 ] }) # enterprise-auth/enterprise-authed-approve/enterprise-authed-approve.component.ts # 在构造函数中直接引用： constructor(@Inject('view') private viewService, 三、模块组件注册使用 如上图所示，模块charts需要在enterprise-admin下注册使用： # 模块的注册使用 # src/app/jasframework/enterprise-admin/charts/charts.module.ts import {Charts} from './charts.component'; import {ChartsRoutes} from './charts.routing' import {NgModule} from '@angular/core'; import {CommonModule} from '@angular/common'; @NgModule({ imports: [CommonModule, ChartsRoutes], declarations: [Charts], bootstrap: [Charts] }) export default class ChartsModule { } # src/app/jasframework/enterprise-admin/charts/charts.routing.ts import {Routes, RouterModule} from '@angular/router'; import {Charts} from './charts.component'; const routes:Routes = [ { path: '', component: Charts, children: [ ] }, ]; export const ChartsRoutes = RouterModule.forChild(routes); # src/app/jasframework/enterprise-admin/charts/charts.component.ts import {Component, OnInit} from '@angular/core'; @Component({ selector: 'charts', templateUrl: 'charts.component.html', providers: [ ] }) export class Charts implements OnInit { constructor() { } ngOnInit() { } } # src/app/jasframework/enterprise-admin/charts/charts.component.html hello charts # 注册模块使之生效 # 只需要在enterprise-admin的路由文件中注册这个路径就可以了 # src/app/jasframework/enterprise-admin/enterprise-admin.routing.ts const routes: Routes = [ { path: '', component: EnterpriseAdminComponent, children:[{ path: 'charts', # 这里是路径 loadChildren: ()=>System.import('./charts/charts.module.ts'), # 指导去哪里找这个模块 }] }, ]; 模块比组件多了xx.module.ts与xx.routing.ts两个文件。如果删除这2个文件，那么就是组件。 组件的加载使用： # 还是以charts为例，代码在上面，少了xx.module.ts与xx.routing.ts两个文件。 # 注册组件使之生效 # 需要在enterprise-admin的路由文件中注册这个路径，在模块中也需要声明 # src/app/jasframework/enterprise-admin/enterprise-admin.routing.ts import {Charts} from './charts/charts.component'; # 引入这个组件 const routes: Routes = [ { path: '', component: EnterpriseAdminComponent, children:[{ path: 'charts', # 这里是路径 component: Charts, # 指明组件 }] }, ]; # src/app/jasframework/enterprise-admin/enterprise-admin.module.ts import {Charts} from './charts/charts.component'; # 引入这个组件 @NgModule({ imports: [ CommonModule,EnterpriseAdminRoutes ], declarations: [ EnterpriseAdminComponent, Charts ], # 在这里写入Charts,这里是声明 bootstrap: [ EnterpriseAdminComponent ] }) 四、html中style类动态绑定 1. 单个类的绑定：[class.special]=\"isSpecial\" 单个style类绑定介绍：https://angular.cn/guide/template-syntax#css-类绑定由class前缀，一个点 (.)和 CSS 类的名字组成， 其中后两部分是可选的。形如：[class.class-name]。 // 不使用style类绑定的代码： Bad curly special // 当badCurly 有值的时候，会清除所有样式类 Bad curly // 使用style绑定 The class binding is special 当模板表达式的求值结果是真值时，Angular 会添加这个类，反之则移除它。 2. 多个类的绑定：[ngClass]=\"{'selected':status === '','saveable': this.canSave,}\" 参考链接：https://angular.cn/guide/template-syntax#ngclass-指令用ngClass绑定到一个key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是true，这个类就会被加上，否则就会被移除。 // component.ts currentClasses: {}; setCurrentClasses() { // CSS classes: added/removed per current state of component properties this.currentClasses = { 'saveable': this.canSave, 'modified': !this.isUnchanged, 'special': this.isSpecial }; } // component.thml This div is initially saveable, unchanged, and special 3. 单个内联样式绑定：[style.color]=\"isSpecial ? 'red': 'green'\" https://angular.cn/guide/template-syntax#样式绑定单个内联样式绑定由style前缀，一个点 (.)和 CSS 样式的属性名组成。 形如：[style.style-property]。 Red Save 有些样式绑定中的样式带有单位。在这里，以根据条件用 “em” 和 “%” 来设置字体大小的单位。 Big Small 4. 多个内联样式绑定：[ngStyle]=\"currentStyles\" https://angular.cn/guide/template-syntax#ngstyle-指令NgStyle需要绑定到一个 key:value 控制对象。 对象的每个 key 是样式名，它的 value 是能用于这个样式的任何值。下面的列子会根据另外三个属性的状态把组件的currentStyles属性设置为一个定义了三个样式的对象： // src/app/app.component.ts currentStyles: {}; setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px' }; } // src/app/app.component.html This div is initially italic, normal weight, and extra large (24px). 你既可以在初始化时调用setCurrentStyles()，也可以在所依赖的属性变化时调用。 angular2 第三方插件的使用 以 使用primeNG插件为例:https://www.primefaces.org/primeng/#/setup 1. 安装插件： npm install primeng --save 2. 模块中引入prime # src/app/advanced-research/advanced-research.module.ts import { DropdownModule } from 'primeng/primeng'; @NgModule({ imports: [ DropdownModule, ], providers: [], declarations: [] }) export default class advancedResearchModule { } 3. 在组件中使用插件 angular中阻止点击事件冒泡 在点击事件中调用下面方法，或者在点击事件的父元素中调用方法 // component.ts 文件中 // 阻止事件冒泡 public stopBubble(e) { // 如果提供了事件对象，则这是一个非IE浏览器 if (e && e.stopPropagation) { // 因此它支持W3C的stopPropagation()方法 e.stopPropagation(); } else { // 否则，我们需要使用IE的方式来取消事件冒泡 window.event.cancelBubble = true; } } // component.html文件中 {{subItem.name}} powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/005-angular2网页前端执行流程.html":{"url":"doc/angular/005-angular2网页前端执行流程.html","title":"angular2网页前端执行流程","keywords":"","body":" 示例代码版本： http://192.168.102.9/jas-paas/cloudlink-front-framework/tree/045f4811da782c107eca72f9bdea39ebaa086a7d 命令行运行命令启动服务 示例代码版本： http://192.168.102.9/jas-paas/cloudlink-front-framework/tree/045f4811da782c107eca72f9bdea39ebaa086a7d 命令行运行命令启动服务 在开发环境下，打开项目目录，运行命令npm start, 这个命令会进入package.json文件中： # package.json \"scripts\": { \"start\": \"npm run server:dev\", # 这个就是 npm start 命令执行的脚本，这个脚本指向了下面的脚本 \"server:dev\": \"webpack-dev-server --config config/webpack.dev.js --progress --profile --watch --content-base src/\", # 这里最终是执行了webpack的打包 } webpack的执行顺序：``` angular2官方网站关于webpack的介绍文档 https://angular.cn/docs/ts/latest/guide/webpack.html 首先进入./webpack.config.js文件里面， case 'dev': case 'development': default: module.exports = require('./config/webpack.dev')({env: 'development'}); # 开发环境，进入这个文件路径 config/webpack.dev.js 在这个文件中还有打包好多输入文件路径以及规则，还有启动后的网址端口，链接的API地址 const commonConfig = require('./webpack.common.js'); # 这个文件引入了打包的文件入口 const ENV = process.env.ENV = process.env.NODE_ENV = 'development'; const HOST = process.env.HOST || 'localhost'; # 访问地址 const PORT = process.env.PORT || 3000; # 访问端口号 开发环境下的API链接设置 proxy: { '/cloudlink/v1/**': { target: 'http://192.168.100.90:8050',: false, pathRewrite: { '^/cloudlink/v1': '' } } } config/webpack.common.js 在这里，有打包文件的入口以及一些规则，想要知道什么意思看angular2官方网站关于webpack的介绍。 entry: { 'polyfills': './src/polyfills.browser.ts', 'vendor': './src/vendor.browser.ts', 'main': './src/main.browser.ts' # 这里就是程序的入口 }, ---------- ---------- ---------- * 浏览器输入地址： http://localhost:3000/ * 入口： index.html 文件路径： cloudlink-front-framework/src/index.html line: 27 这里是应用标签。程序入口 文件路径： cloudlink-front-framework/src/app/app.module.ts line: 15 import { App } from './app.component'; # 这里加载组件，包括模板（网页html） line: 49 routing # 加载路由 文件路径： cloudlink-front-framework/src/app/app.component.ts line:25 template: # 这里是路由文件里面的内容，执行到这里去找路由 , 文件路径： cloudlink-front-framework/src/app/app.routing.ts line:5 { path: '', redirectTo: 'cloudlink', pathMatch: 'full' }, 由于什么也没输入，所以默认进入这个空的 这里给默认的添加了一个路径 ‘cloudlink’ 此时进入下个组件中 { path: 'demo', redirectTo: 'demo/dashboard' }, { path: '**', redirectTo: 'cloudlink/dashboard' } 文件路径： cloudlink-front-framework/src/app/core/home/home.module.ts import { routing } from './home.routing'; # 加载自己的路由 import { NgaModule } from '../../theme/nga.module'; # 加载菜单模块 import { HomeComponent } from './home.component'; # 加载组件，这里有执行，有网页， 文件路径： cloudlink-front-framework/src/app/core/home/home.component.ts line:31 template: ` # 自定义标签 这里是垂直导航菜单 # src/app/theme/components/baSidebar/baSidebar.component.ts # line：8 ： selector: 'ba-sidebar', # src/app/theme/components/baSidebar/baSidebar.html # line： 11 ： # 自定义标签，这里负责列表垂直菜单选项 # src/app/theme/components/menuItem/menuItem.component.ts # line: 6: selector: 'menuItem', # src/app/theme/components/menuItem/menuItem.component.html # 在这里从后台API查询后，列出菜单。 #自定义标签 这里是网页顶部header菜单，如退出按钮菜单 # src/app/theme/components/baPageTop/baPageTop.component.ts # line:8 : selector: 'ba-page-top', # 这里加载路由 ` 文件路径： src/app/core/home/home.routing.ts line:6 const routes: Routes = [ { path: 'login', loadChildren: () => System.import('../login/login.module') # 这里是登录 }, { path: 'register', loadChildren: () => System.import('../register/register.module') }, { path: 'cloudlink', # 匹配这里 component: HomeComponent, children: [ { path: '', redirectTo: 'dashboard', pathMatch: 'full' }, # 这里匹配空，并且加上了‘dashboard’ { path: 'jas', loadChildren: () => System.import('../../jasframework/jas/jas.module.ts'), canLoad: [AuthGuard] }, { path: 'dashboard', loadChildren: () => System.import('../dashboard/dashboard.module'), canLoad: [AuthGuard] }, ```文件路径： src/app/core/dashboard/dashboard.module.ts文件路径： src/app/core/dashboard/dashboard.component.ts文件路径： src/app/core/dashboard/dashboard.html这里没有什么，正常显示。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/006-angular2中引入插件.html":{"url":"doc/angular/006-angular2中引入插件.html","title":"angular2中引入插件","keywords":"","body":" angular中引入jQuery 1. 安装jQuery插件 2. 在index.html中引用jquery 3. 在组件app.component.ts中添加jQuery功能 4. 参考链接 angular2中引入 easyui 1. 参考链接 2. 引入easyUI 引入ngx-img: 图片上传插件 1. 安装使用 2. 直接把源码模块复制到自己的项目中去 [TOC] angular中引入jQuery 1. 安装jQuery插件 ~ npm i jquery cloudlink-front-framework@0.1.0 /Users/yulilong/work/cloudlink-front-framework ├── UNMET PEER DEPENDENCY @angular/common@2.4.6 ├── UNMET PEER DEPENDENCY @angular/compiler@2.4.6 ├── UNMET PEER DEPENDENCY @angular/compiler-cli@>=2.1.x ├── UNMET PEER DEPENDENCY @angular/core@2.4.6 ├── UNMET PEER DEPENDENCY @angular/forms@2.4.6 ├── jquery@2.2.4 └── UNMET PEER DEPENDENCY rxjs@5.0.0-beta.12 2. 在index.html中引用jquery src/index.html # 在这里引入jQuery \"> 3. 在组件app.component.ts中添加jQuery功能 src/app/jasframework/enterprise-admin/app-enterprise/enterprise-list/enterprise-list-show-view/enterprise-list-show-view.component.ts import { EnterpriseAppInfo } from './../../shared/app-enterprise.model'; declare var $:any; @Component({ selector: 'enterprise-list-show', templateUrl: './enterprise-list-show-view.component.html', styleUrls: ['./enterprise-list-show-view.component.css'], }) export class EnterpriseListShowViewComponent implements OnInit { ngOnInit() { $(\".title11\").html(\"这是JQUERY插件设置\"); } } 首先需要使用declare生命我们的jQuery，使之成为一个可用的变量，然后，我们需要导入OnInit模块并实现，我们编写的jquery代码就在这里，问中展示了我们向id为title的标签替换内容，HTML页面是这样的: src/app/jasframework/enterprise-admin/app-enterprise/enterprise-list/enterprise-list-show-view/enterprise-list-show-view.component.html 4. 参考链接 http://www.jb51.net/article/105123.htm angular2中引入 easyui 1. 参考链接 angular中引入easyUI教程： http://jeasyui.com/download/a07.phpangular中使用easyUI教程： http://www.jeasyui.com/demo-angular/main/index.php?sort=descEasyUI for Angular 简评： http://www.zisuzz.com/topic/29/easyui-for-angular-简评 2. 引入easyUI 下载easyUIangular组件： http://jeasyui.com/download/downloads/angular-easyui-0.7.zip 解压后把components文件复制到用的文件中。 把themes文件放到asset文件夹下， 在index文件中引入样式： 或者直接在组件样式(app.component.css )中引入： @import 'easyui/themes/material/easyui.css'; @import 'easyui/themes/angular.css'; @import 'easyui/themes/icon.css'; 引入ngx-img: 图片上传插件 npm网站地址：https://www.npmjs.com/package/ngx-img源码地址： https://github.com/harryy2510/ngx-imgdemo展示地址：https://harryy2510.github.io/ngx-img/home 1. 安装使用 // 安装 npm install --save ngx-img // 如果是在根模块中引入 import { NgxImgModule } from 'ngx-img'; @NgModule({ declarations: [AppComponent, ...], imports: [NgxImgModule.forRoot(), ...], bootstrap: [AppComponent] }) export class AppModule { } // 不在根模块，在其他模块引入 import { NgxImgModule } from 'ngx-img'; @NgModule({ declarations: [OtherComponent, ...], imports: [NgxImgModule, ...], }) export class OtherModule { } // 使用方法看demo ：https://harryy2510.github.io/ngx-img/home 2. 直接把源码模块复制到自己的项目中去 如果第一种方法报错，那么说明使用npm安装使用不适用你（本人就是失败），那么可以去github源码上把这个模块复制到自己的项目下。https://github.com/harryy2510/ngx-img/blob/master/src/module/ngx-img.module.ts目前项目源码是上面链接的模块，git clone 项目后，把这个模块复制到自己项目中，引入模块，写上示例代码，然后运行。此时会报错，以为缺少一个包cropperjs，使用npm install cropperjs --save安装后，即可成功使用。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/007-angular-CLI中一些问题.html":{"url":"doc/angular/007-angular-CLI中一些问题.html","title":"angular-CLI中一些问题","keywords":"","body":" 将ng设置成使用cnpm npm install 生成的package-lock.json是什么文件？有什么用？ 更换npm的源地址 [TOC] 将ng设置成使用cnpm ng set --global packageManager=cnpm http://www.jianshu.com/p/fea407503beb?mType=Group npm install 生成的package-lock.json是什么文件？有什么用？ package-lock.json is automatically generated for any operations where npm modifies either the node_modules tree, or package.json. It describes the exact tree that was generated, such that subsequent installs are able to generate identical trees, regardless of intermediate dependency updates. 大概意思好像是：package-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。 这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。 对比之下，大概是想做类似 Yarn 的功能。 详细内容，请自行查阅官方文档：https://docs.npmjs.com/files/package-lock.json 链接：https://www.zhihu.com/question/62331583/answer/197691747 更换npm的源地址 npm本来的源地址： npm config get registry https://registry.npmjs.org/ 更换npm的源地址: // 淘宝源 npm config set registry https://registry.npm.taobao.org // 自己本来的源 npm config set registry https://registry.npmjs.org/ 参考链接：http://blog.csdn.net/v2810769/article/details/52585662 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/008-angular下arcgis开发遇见的问题.html":{"url":"doc/angular/008-angular下arcgis开发遇见的问题.html","title":"angular下arcgis开发遇见的问题","keywords":"","body":" 地图加载后不完全： arcgis自己的样式没有加载上 运行后，页面没有地图，地图服务报500错误 angular中，arcgis JA API 3.18版本中，画线没有提示信息了 地图中出现白线，样式出错导致的（arcgis3.18版本API） 目录 [TOC] 地图加载后不完全： arcgis自己的样式没有加载上 如上图所示，arcgis地图加载不完全，经过排查，是由于没有加载arcgis自己的CSS样式，把CSS加载上就好了。 运行后，页面没有地图，地图服务报500错误 运行网页后，页面没有地图，打开 console后看见如下信息： dojo.io.script error Error {__zone_symbol__error: Error at Error.g (http://192.168.100.92/polyfills.6fc95ed753dec1452ced.bundle.js:3:13200) at…, …} __zone_symbol__message : \"Error handling service request : Could not find a service with the name 'MapServer/ChinaOnlineStreetColor' in the configured clusters. Service may be stopped or ArcGIS Server may not be running.\" 经查找，这个是地图服务发生错误，导致不能读取地图了， angular中，arcgis JA API 3.18版本中，画线没有提示信息了 这个是由于 bootstrap样式中 .tooltipCSS 样式类中 opacity属性冲突了，导致了arcgis自己的样式失效了。 可在全局样式中添加如下属性： /*arcgis 组件3.18版本中在地图中画线时 提示语句出现：覆盖掉bootstrap中的样式才能出现。如果以后不用arcgis了，可以删除这个样式*/ .arcgis-version-three-map .tooltip { opacity: 1; /*透明度*/ } 地图中出现白线，样式出错导致的（arcgis3.18版本API） 如上图所示在地图中出现了一条白线，经过查找，在显示地图的块中，对DIV块进行了宽高的拉伸,arcgis地图显示的DIV块可使用arcgis自己的类样式来拉伸： /*arcgis地图大小，通过arcgis自己的css类来实现*/ html, body, div.map { width: 100%; height: 100%; padding: 0; margin: 0 auto; overflow: hidden; } 同时把自己写的地图拉伸样式去掉就可以了 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/009-angular编程规范.html":{"url":"doc/angular/009-angular编程规范.html","title":"angular编程规范","keywords":"","body":" 一、单一职责 1. 单一法则 2. 简单函数 二、命名 1. 总体命名指导原则 2. 使用点和横杠来分隔文件名 3. 符号名与文件名 4. 服务名 5. 指令选择器 6. 为组件添加自定义前缀 7. 为指令添加自定义前缀 8. 管道名 9. 单元测试文件名 10. 端到端测试文件名 11. Angular NgModule 命名 三、编程约定 1. 类 2. 常量 3. 接口 4. 属性和方法 5. 导入语句中的空行 四、应用程序结构与 Angular 模块 1. LIFT 2. 定位 3. 识别 4. 扁平 5. T-DRY （尝试不重复自己） 6. 总体结构指导原则 7. 按特性组织的目录结构 8. 应用的根模块 9. 特性模块 10. 共享特性模块 11. 核心特性模块 12. 防止多次导入CoreModule 13. 惰性加载的目录 14. 永远不要直接导入惰性加载的目录 五、组件 1. 组件选择器命名 2. 把组件当做元素 3. 把模板和样式提取到它们自己的文件 4. 内联输入和输出属性装饰器 5. 避免为输入和输出属性指定别名 6. 成员顺序 7. 把逻辑放到服务里 8. 不要给输出属性加前缀 9. 把表现层逻辑放到组件类里 六、指令 1. 使用指令来加强已有元素 2. HostListener 和 HostBinding 装饰器 vs. 组件元数据 host 七、服务 1. 服务总是单例的 2. 单一职责 3. 提供一个服务 4. 使用 @Injectable() 类装饰器 八、数据服务 1. 通过服务与Web服务器交互 九、生命周期钩子 1. 实现生命周期钩子接口 目录 [TOC] 一、单一职责 1. 单一法则 坚持每个文件只定义一样东西（例如服务或组件）, 考虑把文件大小限制在 400 行代码以内。 这么做的理由： 单组件文件非常容易阅读、维护，并能防止在版本控制系统里与团队冲突。 单组件文件可以防止一些隐蔽的程序缺陷，当把多个组件合写在同一个文件中时，可能造成共享变量、创建意外的闭包，或者与依赖之间产生意外耦合等情况。 单独的组件通常是该文件默认的导出，可以用路由器实现按需加载。 最关键的是，可以增强代码可重用性和阅读性，减少出错的可能性。 2. 简单函数 坚持定义简单函数，考虑限制在 75 行之内。 这么做的理由： 简单函数更易于测试，特别是当它们只做一件事，只为一个目的服务时。 简单函数促进代码重用。 简单函数更易于阅读。 简单函数更易于维护。 简单函数可避免易在大函数中产生的隐蔽性错误，例如与外界共享变量、创建意外的闭包或与依赖之间产生意外耦合等。 二、命名 命名约定对可维护性和可读性非常重要。本指南为文件名和符号名推荐了一套命名约定。 1. 总体命名指导原则 坚持所有符号使用一致的命名规则。 坚持遵循同一个模式来描述符号的特性和类型。推荐的模式为feature.type.ts。 这么做的理由： 命名约定提供了一致的方式来查找内容，让我们一眼就能锁定。 项目的一致性是至关重要的。团队内的一致性也很重要。整个公司的一致性会提供惊人的效率。 命名约定帮助我们更快得找到不在手头的代码，更容易理解它。 目录名和文件名应该清楚的传递它们的意图。 例如，app/heroes/hero-list.component.ts包含了一个用来管理英雄列表的组件。 2. 使用点和横杠来分隔文件名 坚持在描述性名字中，用横杠来分隔单词。 坚持使用点来分隔描述性名字和类型。 坚持遵循先描述组件特性，再描述它的类型的模式，对所有组件使用一致的类型命名规则。推荐的模式为feature.type.ts。 坚持使用惯用的后缀来描述类型，包括.service、.component、*.pipe、.module、.directive。 必要时可以创建更多类型名，但必须注意，不要创建太多。 这么做的理由： 类型名字提供一致的方式来快速的识别文件中有什么。 利用编辑器或者 IDE 的模糊搜索功能，可以很容易地找到特定文件。 像.service这样的没有简写过的类型名字，描述清楚，毫不含糊。 像.srv, .svc, 和 .serv这样的简写可能令人困惑。 为自动化任务提供模式匹配。 3. 符号名与文件名 坚持为所有东西使用一致的命名约定，以它们所代表的东西命名。 坚持使用大写驼峰命名法来命名类。符号名匹配它所在的文件名。 坚持在符号名后面追加约定的类型后缀（例如Component、Directive、Module、Pipe、Service）。 坚持在符号名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。 坚持在文件名后面追加约定的类型后缀（例如.component.ts、.directive.ts、.module.ts、.pipe.ts、.service.ts）。 这么做的理由： 遵循一致的约定可以快速识别和引用不同类型的资产。 # app.component.ts @Component({ ... }) export class AppComponent { } # hero-list.component.ts @Component({ ... }) export class HeroListComponent { } # validation.directive.ts @Directive({ ... }) export class ValidationDirective { } # app.module.ts @NgModule({ ... }) export class AppModule # init-caps.pipe.ts @Pipe({ name: 'initCaps' }) export class InitCapsPipe implements PipeTransform { } # user-profile.service.ts @Injectable() export class UserProfileService { } 4. 服务名 坚持使用一致的规则命名服务，以它们的特性来命名。 坚持为服务的类名加上Service后缀。 例如，获取数据或英雄列表的服务应该命名为DataService或HeroService。 这么做的理由： 提供一致的方式来快速识别和引用服务。 # hero-data.service.ts @Injectable() export class HeroDataService { } # credit.service.ts @Injectable() export class CreditService { } 5. 指令选择器 坚持使用小驼峰命名法来命名指令的选择器。 这么做的理由： 保持指令中定义的属性名与绑定的视图 HTML 属性名字一致。 Angular HTML 解析器是大小写敏感的，它识别小写驼峰写法。 6. 为组件添加自定义前缀 坚持使用带连字符的小写元素选择器值（例如admin-users）。 坚持为组件选择器添加自定义前缀。 例如，toh前缀表示 Tour of Heroes（英雄指南），而前缀`admin表示管理特性区。 坚持使用前缀来识别特性区或者应用程序本身。 这么做的理由： 防止与其它应用中的组件和原生 HTML 元素发生命名冲突。 更容易在其它应用中推广和共享组件。 组件在 DOM 中更容易被区分出来。 # app/users/users.component.ts @Component({ selector: 'admin-users' # 这里为users添加一个前缀 admin }) export class UsersComponent {} 7. 为指令添加自定义前缀 坚持为指令的选择器添加自定义前缀（例如前缀toh来自Tour of Heroes）。 坚持用小驼峰形式拼写非元素选择器，除非该选择器用于匹配原生 HTML 属性。 这么做的理由： 防止名字冲突。 指令更加容易被识别。 @Directive({ selector: '[tohValidate]' # 为 Validate 添加一个前缀toh }) export class ValidateDirective {} 8. 管道名 坚持为所有管道使用一致的命名约定，用它们的特性来命名。 这么做的理由： 提供一致方式快速识别和引用管道。 9. 单元测试文件名 坚持测试规格文件名与被测试组件文件名相同。 坚持测试规格文件名添加.spec后缀。 这么做的理由： 提供一致的方式来快速识别测试。 提供一个与 karma 或者其它测试运行器相配的命名模式。 10. 端到端测试文件名 坚持端到端测试规格文件和它们所测试的特性同名，添加.e2e-spec后缀。 这么做的理由： 提供一致的方式快速识别端到端测试文件。 提供一个与测试运行器和构建自动化匹配的模式。 app.e2e-spec.ts heroes.e2e-spec.ts 11. Angular NgModule 命名 坚持为符号名添加Module后缀. 坚持为文件名添加.module.ts扩展名。 坚持用特性名和所在目录命名模块。 坚持为 RoutingModule 类名添加RoutingModule后缀。 坚持为 RoutingModule 的文件名添加-routing.module.ts后缀。 这么做的理由： 提供一致的方式来快速标识和引用模块。 大驼峰命名法是一种命名约定，用来标识可用构造函数实例化的对象。 很容易就能看出这个模块是同名特性的根模块。 RoutingModule是一种专门用来配置 Angular 路由器的模块。 “类名和文件名保持一致”的约定使这些模块易于发现和验证。 ```app.module.ts @NgModule({ ... }) export class AppModule { } heroes.module.ts @NgModule({ ... }) export class HeroesModule { } villains.module.ts @NgModule({ ... }) export class VillainsModule { } app-routing.module.ts @NgModule({ ... }) export class AppRoutingModule { } heroes-routing.module.ts @NgModule({ ... }) export class HeroesRoutingModule { } -------------- ## **三、编程约定** * 坚持一致的编程、命名和空格的约定。 ### **1. 类** * 坚持使用大写驼峰命名法来命名类。 ***这么做的理由：*** * 遵循类命名传统约定。 * 类可以被实例化和构造实例。根据约定，用大写驼峰命名法来标识可构造的东西。 export class ExceptionService { constructor() { } } ### **2. 常量** * 坚持用const声明变量，除非它们的值在应用的生命周期内会发生变化。 * 考虑 把常量名拼写为小驼峰格式。 * 坚持容许现存的const常量沿用大写蛇形命名法。 ***这么做的理由：*** * 告诉读者这个值是不可变的。 * TypeScript 会要求在声明时立即初始化，并阻止再次赋值，以确保达成我们的意图。 * 小驼峰变量名 (heroRoutes) 比传统的大写蛇形命名法 (HERO_ROUTES) 更容易阅读和理解。 * 把常量命名为大写蛇形命名法的传统源于现代 IDE 出现之前， 以便阅读时可以快速发现那些const定义。 TypeScript 本身就能够防止意外赋值。 * 传统的大写蛇形命名法仍然很流行、很普遍，特别是在第三方模块中。 修改它们没多大价值，还会有破坏现有代码和文档的风险。 export const mockHeroes = ['Sam', 'Jill']; // prefer export const heroesUrl = 'api/heroes'; // prefer export const VILLAINS_URL = 'api/villains'; // tolerate ### **3. 接口** * 坚持使用大写驼峰命名法来命名接口。 * 考虑不要在接口名字前面加I前缀。 * 考虑用类代替接口。 ***这么做的理由：*** * [TypeScript 指导原则](https://github.com/Microsoft/TypeScript/wiki/Coding-guidelines)不建议使用 “I” 前缀。 * 单独一个类的代码量小于类+接口。 * 类可以作为接口使用（只是用implements代替extends而已）。 * 在 Angular 依赖注入系统中，接口类可以作为服务提供商的查找令牌。 app/shared/hero-collector.service.ts import { Injectable } from '@angular/core'; import { Hero } from './hero.model'; @Injectable() export class HeroCollectorService { hero: Hero; constructor() { } } ### **4. 属性和方法** * 坚持使用小写驼峰命名法来命名属性和方法。 * 避免为私有属性和方法添加下划线前缀。 ***这么做的理由：*** * 遵循传统属性和方法的命名约定。 * JavaScript 不支持真正的私有属性和方法。 * TypeScript 工具让识别私有或公有属性和方法变得很简单。 app/shared/toast.service.ts import { Injectable } from '@angular/core'; @Injectable() export class ToastService { message: string; private toastCount: number; hide() { this.toastCount--; this.log(); } show() { this.toastCount++; this.log(); } private log() { console.log(this.message); } } ### **5. 导入语句中的空行** * 坚持在第三方导入和应用导入之间留一个空行。 * 考虑按模块名字的字母顺排列导入行。 * 考虑在解构表达式中按字母顺序排列导入的东西。 ***这么做的理由：*** * 空行可以让阅读和定位本地导入更加容易。 * 按字母顺序排列可以让阅读和定位本地导入更加容易。 app/heroes/shared/hero.service.ts import { Injectable } from '@angular/core'; import { Http } from '@angular/http'; import { Hero } from './hero.model'; import { ExceptionService, SpinnerService, ToastService } from '../../core'; -------------- ## **四、应用程序结构与 Angular 模块** * 准备一个近期实施方案和一个长期的愿景。从零开始，但要考虑应用程序接下来的路往哪儿走。 * 所有应用程序的源代码都放到名叫src的目录里。 所有特性区都在自己的文件夹中，带有它们自己的 Angular 模块。 * 所有内容都遵循每个文件一个特性的原则。每个组件、服务和管道都在自己的文件里。 所有第三方程序包保存到其它目录里，而不是src目录。 你不会修改它们，所以不希望它们弄乱我们的应用程序。 使用本指南介绍的文件命名约定。 ### **1. LIFT** * 坚持组织应用的结构，达到这些目的：快速定位 (Locate) 代码、一眼识别 (Identify) 代码、 尽量保持扁平结构 (Flattest) 和尝试 (Try) 遵循DRY (Do Not Repeat Yourself, 不重复自己) 原则。 * 坚持四项基本原则定义文件结构，上面的原则是按重要顺序排列的。 ***这么做的理由：*** * LIFT提供了一致的结构，它具有扩展性强、模块化的特性。因为容易快速锁定代码，提高了开发者的效率。 另外，检查应用结构是否合理的方法是问问自己：我们能快速打开与此特性有关的所有文件并开始工作吗？ ### **2. 定位** * 坚持直观、简单和快速地定位代码。 ***这么做的理由：*** * 要想高效的工作，就必须能迅速找到文件，特别是当不知道（或不记得）文件名时。 把相关的文件一起放在一个直观的位置可以节省时间。 富有描述性的目录结构会让你和后面的维护者眼前一亮。 ### **3. 识别** * 坚持命名文件到这个程度：看到名字立刻知道它包含了什么，代表了什么。 * 坚持文件名要具有说明性，确保文件中只包含一个组件。 * 避免创建包含多个组件、服务或者混合体的文件。 ***这么做的理由：*** * 花费更少的时间来查找和琢磨代码，就会变得更有效率。 较长的文件名远胜于较短却容易混淆的缩写名。 ### **4. 扁平** * 坚持尽可能保持扁平的目录结构。 * 考虑当同一目录下达到 7 个或更多个文件时创建子目录。 * 考虑配置 IDE，以隐藏无关的文件，例如生成出来的.js文件和.js.map文件等。 ***这么做的理由：*** * 没人想要在超过七层的目录中查找文件。扁平的结构有利于搜索。 * 另一方面，心理学家们相信， 当关注的事物超过 9 个时，人类就会开始感到吃力。 所以，当一个文件夹中的文件有 10 个或更多个文件时，可能就是创建子目录的时候了。 * 还是根据你自己的舒适度而定吧。 除非创建新文件夹能有显著的价值，否则尽量使用扁平结构。 ### **5. T-DRY （尝试不重复自己）** * 坚持 DRY（Don't Repeat Yourself，不重复自己）。 * 避免过度 DRY，以致牺牲了阅读性。 ***这么做的理由：*** * 虽然 DRY 很重要，但如果要以牺牲 LIFT 的其它原则为代价，那就不值得了。 这也就是为什么它被称为 T-DRY。 例如，把组件命名为hero-view.component.html是多余的，因为带有.html扩展名的文件显然就是一个视图 (view)。 但如果它不那么显著，或不符合常规，就把它写出来。 ### **6. 总体结构指导原则** * 坚持从零开始，但要考虑应用程序接下来的路往哪儿走。 * 坚持有一个近期实施方案和一个长期的愿景。 * 坚持把所有源代码都放到名为src的目录里。 * 坚持如果组件具有多个伴隨文件 (.ts、.html、.css和.spec)，就为它创建一个文件夹。 ***这么做的理由：*** * 在早期阶段能够帮助保持应用的结构小巧且易于维护，这样当应用增长时就容易进化了。 * 组件通常有四个文件 (*.html、 *.css、 *.ts 和 *.spec.ts)，它们很容易把一个目录弄乱。 * 把组件放在专用目录中的方式广受欢迎，对于小型应用，还可以保持组件扁平化（而不是放在专用目录中）。 这样会把四个文件放在现有目录中，也会减少目录的嵌套。无论你如何选择，请保持一致。 ### **7. 按特性组织的目录结构** * 坚持根据特性区命名目录。 * 坚持为每个特性区创建一个 Angular 模块。 ***这么做的理由：*** * LIFT 原则中包含了所有这些。 * 遵循 LIFT 原则精心组织内容，避免应用变得杂乱无章。 * 当有很多文件时（例如 10 个以上），在专用目录型结构中定位它们会比在扁平结构中更容易。 * Angular 模块使惰性加载可路由的特性变得更容易。 * Angular 模块隔离、测试和复用特性更容易。 ### **8. 应用的根模块** * 坚持在应用的根目录创建一个 Angular 模块（例如/src/app）。 * 考虑把根模块命名为app.module.ts。 ***这么做的理由：*** * 每个应用都至少需要一个根 Angular 模块。 * 能让定位和识别根模块变得更容易。 app/app.module.ts import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { AppComponent } from './app.component'; import { HeroesComponent } from './heroes/heroes.component'; @NgModule({ imports: [ BrowserModule, ], declarations: [ AppComponent, HeroesComponent ], exports: [ AppComponent ], entryComponents: [ AppComponent ] }) export class AppModule {} ### **9. 特性模块** * 为应用中每个明显的特性创建一个 Angular 模块。 * 坚持把特性模块放在与特性区同名的目录中（例如app/heroes）。 * 坚持特性模块的文件名应该能反映出特性区的名字和目录（例如app/heroes/heroes.module.ts）。 * 坚持特性模块的符号名应该能反映出特性区、目录和文件名（例如在app/heroes/heroes.module.ts中定义HeroesModule）。 ***这么做的理由：*** * 特性模块可以对其它模块暴露或隐藏自己的实现。 * 特性模块标记出组成该特性分区的相关组件集合。 * 方便路由到特性模块 —— 无论是用主动加载还是惰性加载的方式。 * 特性模块在特定的功能和其它应用特性之间定义了清晰的边界。 * 特性模块帮助澄清开发职责，以便于把这些职责指派给不同的项目组。 * 特性模块易于隔离，以便测试。 ### **10. 共享特性模块** * 坚持在shared目录中创建名叫SharedModule的特性模块（例如在app/shared/shared.module.ts中定义SharedModule）。 * 坚持在共享模块中声明那些可能被特性模块引用的可复用组件、指令和管道。 * 考虑把可能在整个应用中到处引用的模块命名为SharedModule. * 避免 在共享模块中提供服务。服务通常是单例的，应该在整个应用或一个特定的特性模块中只有一份。 * 坚持在SharedModule中导入所有模块都需要的资产（例如CommonModule和FormsModule）。 * 坚持在SharedModule中声明所有组件、指令和管道。 * 坚持从SharedModule中导出其它特性模块所需的全部符号。 * 避免在SharedModule中指定应用级的单例服务提供商。如果是刻意要得到多个服务单例也行，不过还是要小心。 ***这么做的理由：*** * SharedModule中包含的组件、指令和管道可能需要来自其它公共模块的特性（例如来自CommonModule中的ngFor指令）。 * SharedModule的存在，能让常用的组件、指令和管道在很多其它模块的组件模板中都自动可用。 * 惰性加载的特性模块如果导入了这个共享模块，会创建一份自己的服务副本，这可能会导致意料之外的后果。 * 为何？对于单例服务，你不希望每个模块都有自己的实例。 而如果SharedModule提供了一个服务，那就有可能发生这种情况。 ### **11. 核心特性模块** * 考虑把那些数量庞大、辅助性的、只用一次的类收集到核心模块中，让特性模块的结构更清晰简明。 * 坚持把那些“只用一次”的类收集到CoreModule中，并对外隐藏它们的实现细节。简化的AppModule会导入CoreModule，并且把它作为整个* 应用的总指挥。 * 坚持在core目录下创建一个名叫CoreModule的特性模块（例如在app/core/core.module.ts中定义CoreModule）。 * 坚持把要共享给整个应用的单例服务放进CoreModule中（例如ExceptionService和LoggerService）。 * 坚持导入CoreModule中的资产所需要的全部模块（例如CommonModule和FormsModule）。 * 坚持把应用级、只用一次的组件收集到CoreModule中。 只在应用启动时从AppModule中导入它一次，以后再也不要导入它（例如NavComponent和SpinnerComponent）。 ***这么做的理由：*** * CoreModule提供了一个或多个单例服务。Angular使用应用的根注入器注册这些服务提供商，让每个服务的这个单例对象对所有需要它们的组件都是可用的，而不用管该组件是通过主动加载还是惰性加载的方式加载的。 * CoreModule将包含一些单例服务。而如果是由惰性加载模块来导入这些服务，它就会得到一个新实例，而不是所期望的全应用级单例。 * 真实世界中的应用会有很多只用一次的组件（例如加载动画、消息浮层、模态框等），它们只会在AppComponent的模板中出现。 不会在其它地方导入它们，所以没有共享的价值。 然而它们又太大了，放在根目录中就会显得乱七八糟的。 ### **12. 防止多次导入CoreModule** * 应该只有AppModule才允许导入CoreModule。 * 坚持防范多次导入CoreModule，并通过添加守卫逻辑来尽快失败。 ***这么做的理由：*** * 守卫可以阻止对CoreModule的多次导入。 * 守卫会禁止创建单例服务的多个实例。 ### **13. 惰性加载的目录** * 某些边界清晰的应用特性或工作流可以做成惰性加载或按需加载的，而不用总是随着应用启动。 * 坚持把惰性加载特性下的内容放进惰性加载目录中。 典型的惰性加载目录包含路由组件及其子组件以及与它们有关的那些资产和模块。 ***这么做的理由：*** 这种目录让标识和隔离这些特性内容变得更轻松。 ### **14. 永远不要直接导入惰性加载的目录** * 避免让兄弟模块和父模块直接导入惰性加载特性中的模块。 ***这么做的理由：*** 直接导入并使用此模块会立即加载它，而原本的设计意图是按需加载它。 ----------------- ## **五、组件** ### **1. 组件选择器命名** * 坚持使用中线 (dashed) 命名法或烤串 (kebab) 命名法来命名组件中的元素选择器。 ***这么做的理由：*** * 保持元素命名与自定义元素命名规范一致。 app/heroes/shared/hero-button/hero-button.component.ts @Component({ selector: 'toh-hero-button', templateUrl: './hero-button.component.html' }) export class HeroButtonComponent {} ### **2. 把组件当做元素** * 坚持给组件一个元素选择器，而不是属性或类选择器。 ***这么做的理由：*** * 组件有很多包含 HTML 以及可选 Angular 模板语法的模板。 它们显示内容。开发人员会把组件像原生HTML元素和WebComponents一样放进页面中。 * 查看组件模板的 HTML 时，更容易识别一个符号是组件还是指令。 不好的用法： hero-button.component.ts @Component({ selector: '[tohHeroButton]', templateUrl: './hero-button.component.html' }) export class HeroButtonComponent {} app.component.html 好的做法： hero-button.component.ts @Component({ selector: 'toh-hero-button', templateUrl: './hero-button.component.html' }) export class HeroButtonComponent {} app.component.html ### **3. 把模板和样式提取到它们自己的文件** * 坚持当超过 3 行时，把模板和样式提取到一个单独的文件。 * 坚持把模板文件命名为[component-name].component.html，其中，[component-name] 是组件名。 * 坚持把样式文件命名为[component-name].component.css，其中，[component-name] 是组件名。 * 坚持指定相对于模块的 URL ，给它加上./前缀。 ***这么做的理由：*** * 巨大的、内联的模板和样式表会遮盖组件的意图和实现方式，削弱可读性和可维护性。 * 在多数编辑器中，编写内联的模板和样式表时都无法使用语法提示和代码片段功能。 Angular的TypeScript语言服务（即将到来）可以帮助那些编辑器在编写HTML模板时克服这一缺陷，但对CSS样式没有帮助。 * 当你移动组件文件时，相对于组件的URL不需要修改，因为这些文件始终会在一起。 * ./前缀是相对URL的标准语法，不必依赖Angular的特殊处理，如果没有前缀则不行。 ### **4. 内联输入和输出属性装饰器** * 坚持 使用@Input()和@Output()，而非@Directive和@Component装饰器的inputs和outputs属性: * 坚持把@Input()或者@Output()放到所装饰的属性的同一行。 ***这么做的理由：*** * 易于在类里面识别哪些属性是输入属性或输出属性。 * 如果需要重命名与@Input或者@Output关联的属性或事件名，你可以在一个位置修改。 * 依附到指令的元数据声明会比较简短，更易于阅读。 * 把装饰器放到同一行可以精简代码，同时更易于识别输入或输出属性。 不好的写法： app/heroes/shared/hero-button/hero-button.component.ts @Component({ selector: 'toh-hero-button', template: , inputs: [ 'label' ], outputs: [ 'change' ] }) export class HeroButtonComponent { change = new EventEmitter(); label: string; } 好的写法： @Component({ selector: 'toh-hero-button', template: {{label}} }) export class HeroButtonComponent { @Output() change = new EventEmitter(); @Input() label: string; } ### **5. 避免为输入和输出属性指定别名** * 避免除非有重要目的，否则不要为输入和输出指定别名。 ***这么做的理由：*** * 同一个属性有两个名字（一个对内一个对外）很容易导致混淆。 * 如果指令名也同时用作输入属性，而且指令名无法准确描述这个属性的用途时，应该使用别名。 ### **6. 成员顺序** * 坚持把属性成员放在前面，方法成员放在后面。 * 坚持先放公共成员，再放私有成员，并按照字母顺序排列。 ***这么做的理由：*** * 把类的成员按照统一的顺序排列，易于阅读，能立即识别出组件的哪个成员服务于何种目的。 ### **7. 把逻辑放到服务里** * 坚持在组件中只包含与视图相关的逻辑。所有其它逻辑都应该放到服务中。 * 坚持把可重用的逻辑放到服务中，保持组件简单，聚焦于它们预期目的。 ***这么做的理由：*** * 当逻辑被放置到服务里，并以函数的形式暴露时，可以被多个组件重复使用。 * 在单元测试时，服务里的逻辑更容易被隔离。当组件中调用逻辑时，也很容易被模拟。 * 从组件移除依赖并隐藏实施细节。 * 保持组件苗条、精简和聚焦。 ### **8. 不要给输出属性加前缀** * 坚持命名事件时，不要带前缀on。 * 坚持把事件处理器方法命名为on前缀之后紧跟着事件名。 ***这么做的理由：*** * 与内置事件命名一致，例如按钮点击。 * Angular 允许另一种备选语法 `on-*`。如果事件的名字本身带有前缀on，那么绑定的表达式可能是on-onEvent。 不好的写法： app/heroes/hero.component.ts @Component({ selector: 'toh-hero', template: ... }) export class HeroComponent { @Output() onSavedTheDay = new EventEmitter(); } 好的写法： export class HeroComponent { @Output() savedTheDay = new EventEmitter(); } ### **9. 把表现层逻辑放到组件类里** * 坚持把表现层逻辑放进组件类中，而不要放在模板里。 ***这么做的理由：*** * 逻辑应该只出现在一个地方（组件类里）而不应分散在两个地方。 * 将组件的表现层逻辑放到组件类而非模板里，可以增强测试性、维护性和重复使用性。 不好的写法： @Component({ selector: 'toh-hero-list', template: Our list of heroes: Total powers: {{totalPowers}} Average power: {{totalPowers / heroes.length}} # 这里 }) export class HeroListComponent { heroes: Hero[]; totalPowers: number; } 好的写法： @Component({ selector: 'toh-hero-list', template: Our list of heroes: Total powers: {{totalPowers}} Average power: {{avgPower}} }) export class HeroListComponent { heroes: Hero[]; totalPowers: number; get avgPower() { return this.totalPowers / this.heroes.length; } ---------------- ## **六、指令** ### **1. 使用指令来加强已有元素** * 坚持当你需要有表现层逻辑，但没有模板时，使用属性型指令。 ***这么做的理由：*** * 属性型指令没有模板。 * 一个元素可以使用多个属性型指令。 ### **2. HostListener 和 HostBinding 装饰器 vs. 组件元数据 host** * 考虑优先使用@HostListener和@HostBinding，而不是@Directive和@Component装饰器的host属性。 * 坚持让你的选择保持一致。 ***这么做的理由：*** * 对于关联到@HostBinding的属性或关联到@HostListener的方法，要修改时，只需在指令类中的一个地方修改。 如果使用元数据属性host，你就得在组件类中修改属性声明的同时修改相关的元数据。 * host元数据只是一个便于记忆的名字而已，并不需要额外的 ES 导入。 使用@HostListener和@HostBinding: app/shared/validator.directive.ts import { Directive, HostBinding, HostListener } from '@angular/core'; @Directive({ selector: '[tohValidator]' }) export class ValidatorDirective { @HostBinding('attr.role') role = 'button'; @HostListener('mouseenter') onMouseEnter() { // do work } } 使用host元数据： import { Directive } from '@angular/core'; @Directive({ selector: '[tohValidator2]', host: { 'attr.role': 'button', '(mouseenter)': 'onMouseEnter()' } }) export class Validator2Directive { role = 'button'; onMouseEnter() { // do work } } ------------- ## **七、服务** ### **1. 服务总是单例的** * 坚持在同一个注入器内，把服务当做单例使用。用它们来共享数据和功能。 ***这么做的理由：*** * 服务是在特性范围或应用内共享方法的理想载体。 * 服务是共享状态性内存数据的理想载体。 app/heroes/shared/hero.service.ts export class HeroService { constructor(private http: Http) { } getHeroes() { return this.http.get('api/heroes') .map((response: Response) => response.json().data); } } ### **2. 单一职责** * 坚持创建单一职责的服务，用职责封装在它的上下文中。 * 坚持当服务成长到超出单一用途时，创建一个新服务。 ***这么做的理由：*** * 当服务有多个职责时，它很难被测试。 * 当某个服务有多个职责时，每个注入它的组件或服务都会承担这些职责的全部开销。 ### **3. 提供一个服务** * 坚持将服务提供到共享范围内的顶级组件的 Angular 注入器。 ***这么做的理由：*** * Angular 注入器是层次化的。 * 在顶层组件提供服务时，该服务实例在所有子组件中可见并共享。 * 服务是共享方法或状态的理想载体。 * 当不同的两个组件需要一个服务的不同的实例时，上面的方法这就不理想了。在这种情况下，对于需要崭新和单独服务实例的组件，最好在组件级提供服务。 ### **4. 使用 @Injectable() 类装饰器** * 坚持当使用类型作为令牌来注入服务的依赖时，使用@Injectable()类装饰器，而非@Inject()参数装饰器。 ***这么做的理由：*** * Angular 的 DI 机制会根据服务的构造函数参数的声明类型来解析服务的所有依赖。 * 当服务只接受类型令牌相关的依赖时，比起在每个构造函数参数上使用@Inject()，@Injectable()的语法简洁多了。 不好的写法： app/heroes/shared/hero-arena.service.ts export class HeroArena { constructor( @Inject(HeroService) private heroService: HeroService, @Inject(Http) private http: Http) {} } 好的写法： @Injectable() export class HeroArena { constructor( private heroService: HeroService, private http: Http) {} } ---------- ## **八、数据服务** ### **1. 通过服务与Web服务器交互** * 坚持把数据操作和与数据交互的逻辑重构到服务里。 * 坚持让数据服务来负责 XHR 调用、本地储存、内存储存或者其它数据操作。 ***这么做的理由：*** * 组件的职责是为视图展示或收集信息。它不应该关心如何获取数据，它只需要知道向谁请求数据。把如何获取数据的逻辑移动到数据服务里，简化了组件，让其聚焦于视图。 * 在测试使用数据服务的组件时，可以让数据调用更容易被测试（模拟或者真实）。 * 数据管理的详情，比如头信息、方法、缓存、错误处理和重试逻辑，不是组件和其它的数据消费者应该关心的事情。 * 数据服务应该封装这些细节。这样，在服务内部修改细节，就不会影响到它的消费者。并且更容易通过实现一个模拟服务来对消费者进行测试。 --------- ## **九、生命周期钩子** 使用生命周期钩子来介入到 Angular 暴露的重要事件里。 ### **1. 实现生命周期钩子接口** * 坚持实现生命周期钩子接口。 ***这么做的理由：*** * 如果使用强类型的方法签名，编译器和编辑器可以帮你揪出拼写错误。 不好的写法： app/heroes/shared/hero-button/hero-button.component.ts @Component({ selector: 'toh-hero-button', template: OK }) export class HeroButtonComponent { onInit() { // misspelled console.log('The component is initialized'); } } 好的写法： @Component({ selector: 'toh-hero-button', template: OK }) export class HeroButtonComponent implements OnInit { ngOnInit() { console.log('The component is initialized'); } } ``` powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/angular/010-TS_JS中一些知识点.html":{"url":"doc/angular/010-TS_JS中一些知识点.html","title":"TS_JS中一些知识点","keywords":"","body":" es6 javascript对象方法Object.assign() ### 获取屏幕分辨率 ### es6 javascript对象方法Object.assign() 1 基本用法Object.assign方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。 var target = { a: 1 }; var source1 = { b: 2 }; var source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 2 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 var obj1 = {a: {b: 1}}; var obj2 = Object.assign({}, obj1); obj1.a.b = 2; obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 3 常见用途（ 1 ）为对象添加属性（ 2 ）为对象添加方法（ 3 ）克隆对象（ 4 ）合并多个对象（ 5 ）为属性指定默认值 4 详细介绍： http://blog.csdn.net/qq_30100043/article/details/53422657 获取屏幕分辨率 # 可直接在JS代码中用 screen.height ：屏幕高度。 screen.width ：屏幕宽度。 screen.availHeight ：屏幕可用高度。即屏幕高度减去上下任务栏后的高度，可表示为软件最大化时的高度。 screen.availWidth ：屏幕可用宽度。即屏幕宽度减去左右任务栏后的宽度，可表示为软件最大化时的宽度。 # 任务栏高/宽度 ：可通过屏幕高/宽度 减去 屏幕可用高/宽度得出。如：任务栏高度 = screen.height - screen.availHeight 。 window.outerHeight ：浏览器高度。 window.outerWidth ：浏览器宽度。 window.innerHeight ：浏览器内页面可用高度；此高度包含了水平滚动条的高度(若存在)。可表示为浏览器当前高度去除浏览器边框、工具条后的高度。 window.innerWidth ：浏览器内页面可用宽度；此宽度包含了垂直滚动条的宽度(若存在)。可表示为浏览器当前宽度去除浏览器边框后的宽度。 # 工具栏高/宽度 ：包含了地址栏、书签栏、浏览器边框等范围。如：高度，可通过浏览器高度 - 页面可用高度得出，即：window.outerHeight - window.innerHeight。 # 详细介绍： http://www.cnblogs.com/polk6/p/5051935.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/001-ruby中语法知识.html":{"url":"doc/ruby/001-ruby中语法知识.html","title":"ruby中语法知识","keywords":"","body":" return home 参考链接 知识点 类方法的定义 ruby中的布尔值 return home 参考链接 理解Ruby中的作用域 Ruby 中的类与对象 Ruby学习之元编程　　Kernel#evel(), Object#instance_evel()、Module#class_evel() 知识点 ruby中include和extend以及模块中ClassMethods Ruby require,load,include,extend的显著区别 Ruby中的 Object、Class、Module之间关系　　Class与Module的区别 method查看方法是哪个类定义的 methods查看对象有哪些方法 source_locationc查看方法定义处 method = method('_run_validate_callbacks') p method p method.source_location # # [\"/home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.0.1/lib/active_support/callbacks.rb\", 749 检查一个变量是否已经定义可以用defined?，如果未定义会返回字符串\"nil\"，否则返回该变量的定义类型。如下面的例子: irb(main):007:0> a = 1 => 1 irb(main):008:0> defined? a => \"local-variable\" irb(main):009:0> defined? b => nil irb(main):010:0> defined? nil => \"nil\" irb(main):011:0> defined? String => \"constant\" irb(main):012:0> defined? 1 => \"expression\" p caller 可以查看是谁调用了你 ruby的class http://blog.csdn.net/lyx2007825/article/details/10089115class Array class 对象中存在实例变量 (instance variables) ，可以通过方法 instance_variables 进行查看当前对象中的 实例变量 class MyClass def my_method @v = 1 end end obj = MyClass.new obj.class # => MyClass obj.instance_variables # => [] obj.my_method obj.instance_variables # => [:@v] .class的使用因为类也是一种对象，因此所有对象的特性也是类具有的特性。比如，(Class) 有自己的类，这个类就是——Class，举个例子，假如一个字符串可以通过 str#class 获得它的类 String ，那么 String 作为一个对象也可以通过 String#class 获知它自己的类。比如下面的代码: \"hello\".class # => String String.class # => Class Class.class # => Class 类方法的定义 class HelloWorld def greet end end # 1.在class ruby 中super和super()的区别http://blog.csdn.net/autumn20080101/article/details/8146310 ``` 我们经常要在子类的initialize方法中调用super和super()。 从语法上说super和super()是有微妙区别的。 super不带括号表示调用父类的同名函数，并将本函数的所有参数传入父类的同名函数； super()带括号则表示调用父类的同名函数，但是不传入任何参数； class SParent def initialize *args args.each {|arg| puts arg} endend class SChild def initialize a, b, c super endend a, b, c = *%W[a b c]SChild.new a, b, c # puts a, b, c if superSChild.new a, b, c # puts nothing if super() 可以看出当SChild的initialize中调用super()时，代码是不会打印任何信息的。这是因为super()没有向SParent的initialize方法传任何参数。 * **ruby 类方法中 self.class.方法名** 子类中方法调用父类中同名的 类方法 class AA def self.te p 'I an AA' end end class BB \"I an AA\" * **完美理解ruby中的yield的概念** 看到axgle 兄解释ruby中的yield的概念，形象的理解为“占位”的作用。 但是对yield还可以带着参数的概念总觉得有点不够形象， def foo yield [1,2,3] end foo {|v| p v} 以我看来更像是，比喻成一个纯虚函数更好理解，其中，在方法后跟块后，不过就是对yield的声明化了而已。 不过对于初步理解yield还是有很好帮助，算是完美解释了。大学里常常发生占位置的现象：头天晚上拿一本书放在课座上，表示位置已经被占了;第二天才来到这个座位上，翻开书正式上课.在这个现象中，“书本”充当了“占位符”的作用。在Ruby语言中，yield是占位符:先在前面的某部分代码中用yield把位置占着，然后才在后面的某个代码块(block)里真正实现它,从而完成对号入座的过程.定义finddef find(dir) Dir.entries(dir).each {|f| yield f} #获得dir目录下的文件名列表;对每个文件名,用yield来处理(至于怎么处理，还不知道，占个位置先^_^)end 使用findfind(\".\") do |f| #block开始 puts f #用输出文件名这个语句，真正实现了yield的处理(也可以用任何其他语句)end #block结束 由此可见，yield属于定义层，属于宣告层，也就是在心里说一句:\"这个位置不错，我先用书本占了再说!\"; 而block属于使用层，实现层,也就是最终你坐在了你先前占的位置上，从而真正的实现了对号入座的过程. * **empty、nil、blank三者之间的区别** http://www.cnblogs.com/lmei/p/3262816.html 这三个方法在ROR中经常用到，都是用来判断是否为空的。 区别是： ruby的方法：.nil?、.empty? rails的方法 ：.blank? 用法的区别： .nil? : 判断对象是否存在。.empty? : 是对象已经存在，判断是否为空字段。.blank? : 相当于同时满足 .nil? 和 .empty? 。注： Rails API中的解释是如果对象是：false, empty, 空白字符都是blank。比如说： \"\", \" \", nil, [], 和{}都算是blank。也就是说，object.blank? 相当于 object.nil? || object.empty?.nil? 和 empty? 的简单例子 true.blank? #=> false false.blank? #=> true \"true\".blank? #=> false \"\".blank? #=> true \"\\n\".blank? #=> true '\\n'.blank? #=> false 'true'.blank? #=> false ''.blank? #=> true 1.blank? #=> false [].blank? #=> true [1].blank? #=> false * alias设置别名 alias 别名 原名 #直接使用方法名 alias :别名 :原名 #使用符号名 除了为方法设置别名外，在重定义以存在的方法时，为了能用别名调用原来的方法，也需要用alias ``` ruby中的布尔值 ruby中布尔值是一个特殊对象。它由两个类型组成TrueClass和FalseClass，可以在irb里试一下 true.class，这两个类型生成两个特殊的对象： true 和 false。 所有ruby中的对象都可以转成布尔值，nil是false，其他全部是true，当然false还是false。 在irb里试：puts \"true\" if nil，则不会打出 true，而是返回nil。 0并不象想象中的那样是false，而是true. 可以在irb里试一下: puts \"true\" if 0 . 这会打印出true，说明0就是true，因为它是一个对象，ruby没有数字型的说法，而是一个对象。 在使用的时候，如果掌握不了这种灵活的用法，那么就注意几点就行了：1.使用同类型比较，返回的布尔值肯定是对的。比如： 0==\"0\" ，这是false。 0==0 就是true。2.不要直接取对象的布尔值。比如： 0 是true, \"0\" 也是 true， 而 0!=0 是false，如果判断非0一定要直接写 obj != 0 ，不能象c那样写。即使是判断nil，也用 obj.nil?，这样代码比较清晰。3.使用if ，弃用unless。如果你有时候会弄晕，那么为了保证安全，只用if ，即使是检查nil也不用unless。特别是你在多种语言间转来转去的时候。http://www.th7.cn/Program/c/201609/952039.shtml powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/002-include和extend以及模块中ClassMethods.html":{"url":"doc/ruby/002-include和extend以及模块中ClassMethods.html","title":"include和extend以及模块中ClassMethods","keywords":"","body":"http://developer.51cto.com/art/200907/132919.htm从模块引入方法、变量，使得编程变得简单，扩展性愈强，比以往的类的继承更灵活。这样的引入，仿佛将一个方法块，复制了一份放到了你所引用的类或者模块里面。你完全可以将多个互不相干的类中相同的方法拿出来写到一个模块中，这样可以使得代码精简，符合Ruby的设计初衷，而且，使得你的程序更有条理。 Ruby on Rails常见用法 通常引用模块有以下3种情况： 1.在类定义中引入模块，使模块中的方法成为类的实例方法 这种情况是最常见的 直接 include 即可 2.在类定义中引入模块，使模块中的方法成为类的类方法 这种情况也是比较常见的 直接 extend 即可 3.在类定义中引入模块，既希望引入实例方法，也希望引入类方法 这个时候需要使用 include, 但是在模块中对类方法的定义有不同，定义出现在self.included块中 def self.included(c) ... end 中 Ruby on Rails实例讲解 Code #!ruby #基类 module Base #显示 def show puts \"You came here!\" end end class Car extend Base #扩展了类方法，我们可以通过Car.show调用 end class Bus include Base #扩展了实例方法，可以通过Bus.new.show调用 end 但是我们经常有这样的需要，希望基类足够强大，既可以扩展实例方法，也可以扩展类方法，Ruby on Rails同样提供了解决方案。 #!ruby Code #基类 module Base def show puts \"You came here!\" end #扩展类方法 def self.included(base) def base.call puts \"I'm strong!\" end base.extend(ClassMethods) end #类方法 # extend ActiveSupport::Concern # if not add this line,then module ClassMethods is Invalid module ClassMethods def hello puts \"Hello baby!\" end end end class Bus include Base end 此时Bus已经具备了实例方法show,类方法：call 、hello,访问方式 肯定也有人提出此类疑问，使用extend能够实现此功能不？ 答案是：暂未找到，如您找到请明示，多谢！ 我也曾经做过以下实验，结果没有成功，在此也张贴出来，希望能给您带来一些启示。 #!ruby Code #基类 module Base def show puts \"You came here!\" end #扩展实例方法 def self.extended(base) base.extend(InstanceMethods) end module InstanceMethods def love puts 'We are instances,loving each other!' end end end class Car extend Base end 但是这样，实例方法扩展失败，依然扩展了类方法 #!ruby Car.show Car.love #类方法 Car.new.love #undefined method 'love' powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/003-require,load,include,extend的显著区别.html":{"url":"doc/ruby/003-require,load,include,extend的显著区别.html","title":"require,load,include,extend的显著区别","keywords":"","body":" require，load用于包含文件；include，extend则用于包含模块。 include,require,load的显著区别 引用单个和目录下所有rb的方法 include和extend require，load用于包含文件；include，extend则用于包含模块。 include,require,load的显著区别 http://www.cnblogs.com/mover/p/3686176.html require和load不同，它只加载文件一次，即在第一次执行到require时载入，以后碰到require同一文件时自动忽略，已经被加载的文件保存在$”中。 require还可以用来加载二进制格式的库。Require可以使用绝对路径或相对路径，如果使用了相对路径，那么系统会在$:变量包含的目录中搜寻。 Require和load的另一个不同是当包含文件是Ruby代码时，require可以不加后缀名。Require将当前所有加载的文件保存在$\"变量中。 在Irb里用load比用require 好，load允许我们多次加载同一个文件，这样如果我们发现一个BUG后编辑文件，可以将它重新加载到Irb的会话中。 总结： require, load,include都是Kernel模块中的方法，他们的区别如下： require，load用于包含文件，include则用于包含的模块。 require加载一次，load可加载多次。 require加载Ruby代码文件时可以不加后缀名，load加载代码文件时必须加后缀名。 require一般情况下用于加载库文件，而load用于加载配置文件。 load例子： #!ruby 4.times do |i| File.open(\"temp.rb\",\"w\") do |f| f.puts \"def test\" f.puts \"#{i}\" f.puts \"end\" end load \"temp.rb\" puts test end 执行结果为： 0 1 2 3 引用单个和目录下所有rb的方法 http://blog.csdn.net/xuleilx/article/details/21830395除引用系统rb外，require中不能用相对路径。同一目录下的文件，如/usr/local/ruby/foo.rb与/usr/local/ruby/bar.rb两个文件。如果直接在foo.rb中： require 'bar' 执行时会报找不到bar.rb错误。这是因为运行: /home/oldsong~ ruby /usr/local/ruby/foo.rb 时会在ruby安装的lib目录和/home/oldsong/目录下查找bar.rb。而不会去rb文件的目录/usr/local/ruby/下查找。1、引用一个文件引用当前rb同目录下的file_to_require.rb require File.join(__FILE_, '../file_to_require')。 require File.expand_path('../file_to_require', __FILE__) require File.dirname(__FILE__) + '/file_to_require' 其中，File.expandpath是Rails常用的做法。 _FILE为常量，表示当前文件的绝对路径，如/home/oldsong/test.rb还可以： $LOAD_PATH.unshift(File.dirname(__FILE__)) # 先把目录加入LOAD_PATH变量中，然后可直接引用文件名 require 'bar' 2、引用一个目录下所有文件例：引用当前rb相同目录下lib/文件下所有*.rb文件。 # 方法一 Dir[File.dirname(__FILE__) + '/lib/*.rb'].each {|file| require file } # 方法二 # 一个gem # https://rubygems.org/gems/require_all include和extend http://blog.csdn.net/rocky_j2ee/article/details/3754781include主要用来将一个模块插入（mix）到一个类或者其它模块。extend 用来在一个对象（object，或者说是instance）中引入一个模块，这个类从而也具备了这个模块的方法。通常引用模块有以下3种情况：1.在类定义中引入模块，使模块中的方法成为类的实例方法这种情况是最常见的直接 include 即可 2.在类定义中引入模块，使模块中的方法成为类的类方法这种情况也是比较常见的直接 extend 即可 3.在类定义中引入模块，既希望引入实例方法，也希望引入类方法这个时候需要使用 include,但是在模块中对类方法的定义有不同，定义出现在 方法def self.included(c) ... end 中 完整的示例如下： #!ruby module Ma MA_VALUE = 1 def ma_1 puts \"it is ma_1\" end end module Mb MB_VALUE = 1 def self.included(c) def c.mb_2 puts \"it is mb_2\" end end def mb_1 puts \"it is mb_1\" end end class Ca include Ma end class Cb extend Ma include Mb end c1 = Ca.new c1.ma_1 c2 = Cb.new c2.mb_1 Cb.ma_1 Cb.mb_2 puts Ma::MA_VALUE puts Ca::MA_VALUE puts Mb::MB_VALUE puts Cb::MB_VALUE powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/004-Object、Class、Module之间关系.html":{"url":"doc/ruby/004-Object、Class、Module之间关系.html","title":"Object、Class、Module之间关系","keywords":"","body":" 从继承关系来说，是Class -- Module -- Object，即Object是继承树的顶层，紧接着是Module，然后是Class。 module 与Class 区别 从继承关系来说，是Class --> Module --> Object，即Object是继承树的顶层，紧接着是Module，然后是Class。 irb的输出结果： 2.3.0 :008 > puts Object.superclass BasicObject => nil 2.3.0 :009 > puts Module.superclass Object => nil 2.3.0 :010 > puts Class.superclass Module => nil 2.3.0 :011 > puts Object.public_methods - Kernel.public_methods new allocate superclass => nil 从上面的输出可以看出，Object中自己定义的方法只有\"superclass\" , \"allocate\"和\"new\"这三个方法，其余的方法，比如\"class\", \"to_s\", \"object_id\"等等都是在Kernel中实现的。 ruby中： 在Ruby中使用Class来标识所有的数据类型，所有的变量和常量都是Object的子类 Kernel是Module，Object的实现中包含了Kernel ![WX20170330-164838.png](https://bitbucket.org/repo/oE6yEX/images/825673219-WX20170330-164838.png) https://www.zhihu.com/question/19922190/answer/13359458 module 与Class 区别 一句话概括，就是： class可以实例化, module不可以, 别的都一样.关于继承的一点区别:class是使用作为继承的关键字，只支持单继承.module是使用include来做实例继承（实例化的时候动态功能插入），extend做类继承（可以理解为static继承）. module的应用场景: 作为namespace，里面放一般的const或者自己的class 作为工具模块，放通用方法，别的类里面直接include或者extend以后使用，也可以看成动态扩展业务类 可以作为抽象类，module里面提供默认实现，业务类include或者extend以后覆盖 作为接口来用，一个可用的接口库，module-interface http://jingpin.jikexueyuan.com/article/58139.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/005-rails中常见问题.html":{"url":"doc/ruby/005-rails中常见问题.html","title":"rails中常见问题","keywords":"","body":" N+1问题: N+1问题是数据库访问中最常见的一个性能问题，首先介绍一下什么是N+1问题：举个例子，我们数据库中有两张表，一个是Customers，一个是Orders。Orders中含有一个外键customer_id，指向了Customers的主键id。想要得到所有Customer以及其分别对应的Order，一种写法是：SELECT * FROM Customers;对于每一个Customer；SELECT * FROM Orders WHERE Orders.customer_id = #{customer.id}这样我们实际对数据库做了N+1次查询：选择所有Customer一次得到N个Customer，对于N个Customer分别选择其对应的Order一共N次。所以，一共执行了N+1次查询，这就是N+1问题 N+1问题的一般解决方法:使用Left Join一次性取出所有数据：SELECT * FROM Customers LEFT JOIN Orders on Customers.id = Orders.customer_id这样虽然取出的数据相对多一些，但是只需要一次执行 Rails中的N+1问题:因为Rails使用ActiveRecord访问数据库。所以，它的N+1问题暴露的不是那么明显。假设有如下代码，查找 10 条客户记录并打印这些客户的邮编： #!ruby clients = Client.limit(10) clients.each do |client| puts client.address.postcode end 上面的代码第一眼看起来不错，但实际上存在查询总次数较高的问题。这段代码总共需要执行 1（查找 10 条客户记录）+ 10（每条客户记录都需要加载地址）= 11 次查询。 Rails中 N + 1 查询问题的解决办法:Active Record 允许我们提前指明需要加载的所有关联，这是通过在调用 Model.find 时指明 includes 方法实现的。通过指明 includes 方法，Active Record 会使用尽可能少的查询来加载所有已指明的关联。回到之前 N + 1 查询问题的例子，我们重写其中的 Client.limit(10) 来使用及早加载： #!ruby clients = Client.includes(:address).limit(10) clients.each do |client| puts client.address.postcode end 上面的代码只执行 2 次查询，而不是之前的 11 次查询： #!mysql SELECT * FROM clients LIMIT 10 SELECT addresses.* FROM addresses WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10)) 参考资料：http://www.cnblogs.com/15ho/p/6625673.htmlhttp://guides.rubyonrails.org/active_record_querying.html#eager-loading-associationshttp://guides.ruby-china.org/active_record_querying.html#%E5%8F%8A%E6%97%A9%E5%8A%A0%E8%BD%BD%E5%85%B3%E8%81%94 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/006-ruby比较常用的gems包.html":{"url":"doc/ruby/006-ruby比较常用的gems包.html","title":"ruby比较常用的gems包","keywords":"","body":" hashie https://rubygems.org/gems/hashie这个可以把hash数据当成对象使用 .点方法直接调用。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/007-ruby_gems命令.html":{"url":"doc/ruby/007-ruby_gems命令.html","title":"ruby_gems命令","keywords":"","body":" 显示gem的帮助和版本 gem –h/--help #显示gem的帮助 gem –v /--version #显示gem的版本号 列出远程库的所有可用软件 gem query --remote # 短命令: gem q -r 查找远程主机上的特定软件 gem query --remote --name-matches doom # 短命令: gem q -rn doom # 你将看到一个匹配doom的详细列表。 gem list –remote --d #用子命令list列出远程安装的gems 安装一个远程软件 gem install --remote progressbar # 短命令: gem i -r progressbar –y # 远程安装progressbar到你的主机，-y的意思是无条件的安装依赖包 gem install rails –remote #从远程服务器安装rails包，其中rails可以被替换成任何一个gem list –remote –d中显示的软件包 安装软件的特定版本 gem ins -r progressbar-0.0.3 # 安装progressbar的0.0.3版本 gem ins -r progressbar --version '> 0.0.1' # 将安装progressbar的大于0.0.1的最新版本 查看一个已安装的软件 gem specification progressbar # 短命令: gem spec progressbar # 你会看到关于已安装的包progressbar的详细信息。 卸载一个软件 gem uninstall progressbar 卸载了progressbar 查看某个已安装的软件 gem query --local --name-matches doom # 短命令: 'gem q -ln doom' 构建gem包 gem build package.gemspec #运用bulid子命令构建gem包 http://www.jb51.net/article/65136.htm gem引用本地开发的gem包 gem \"azure-armrest\", :path => \"../azure-armrest/\" #相对路径或者全路径 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/008-国内RubyGems镜像.html":{"url":"doc/ruby/008-国内RubyGems镜像.html","title":"国内RubyGems镜像","keywords":"","body":" 概述 # 淘宝镜像 ## ruby-china镜像 ## 概述 对于电脑或服务器没有代理的需要设置ruby gems镜像，如果有代理，但是安装速度慢，也可以设置此镜像来加快安装速度。 淘宝镜像 https://ruby.taobao.org/之前都是使用淘宝镜像2016-12-27发现淘宝的ruby gem 镜像已经重定向到ruby-china了，所以不多做介绍了。 ruby-china镜像 http://gems.ruby-china.org/ 如何使用？ # 请尽可能用比较新的 RubyGems 版本，建议 2.6.x 以上。 $ gem update --system # 这里请翻墙一下 $ gem -v 2.6.3 $ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ $ gem sources -l https://gems.ruby-china.org # 确保只有 gems.ruby-china.org 如果你使用 Gemfile 和 Bundle (例如：Rails 项目) # 你可以用 Bundler 的 Gem 源代码镜像命令。 $ bundle config mirror.https://rubygems.org https://gems.ruby-china.org # 这样你不用改你的 Gemfile 的 source。 source 'https://rubygems.org/' gem 'rails', '4.2.5' ... powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/009-Ruby中任务构建工具rake的入门学习教程.html":{"url":"doc/ruby/009-Ruby中任务构建工具rake的入门学习教程.html","title":"Ruby中任务构建工具rake的入门学习教程","keywords":"","body":"http://www.jb51.net/article/81476.htm Rake简介 Rake的意思是Ruby Make,一个用ruby开发的代码构建工具. 但是,为什么Ruby需要Rake? 按理说Ruby代码无需编译,应该不需要Rake才对呀?原来,Rake另有妙用,即把Rake当做一个任务管理工具来使用...这样做有两个好处: 1.以任务的方式创建和运行脚本 当然,你可以用脚本来创建每一个你希望自动运行的任务.但是,对于大型的应用来说,你几乎总是需要为数据库迁移(比如Rails中db:migrate任务)、清空缓存、或者代码维护等等编写脚本.对于每一项任务,你可能都需要写若干脚本,这会让你的管理变得复杂.那么,把它们用任务的方式整理到一起,会让管理变得轻松很多. 2.追踪和管理任务之间的依赖 Rake还提供了轻松管理任务之间依赖的方式.比如,\"migrate\"任务和\"schema:dump\"任务都依赖于 \"connect_to_database\"任务,那么在\"migrate\"任务调用之前,\"connect_to_database\"任务都会被执行. 下面入正题吧,即如何用Rake编写一个任务脚本.. 顺序执行 在Rake中定义任务后，可以指定任务的执行顺序，例如，每天早晨起床后的例行公事: 1. 关闭闹钟 2. 梳洗打扮 3. 泡杯咖啡 4. 遛狗 上面的几项事物，在Rakefile中这样描述 task :turn_off_alarm do puts \"Turned off alarm. Would have liked 5 more minutes, though.\" end task :groom_myself do puts \"Brushed teeth.\" puts \"Showered.\" puts \"Shaved.\" end task :make_coffee do cups = ENV[\"COFFEE_CUPS\"] || 2 puts \"Made #{cups} cups of coffee. Shakes are gone.\" end task :walk_dog do puts \"Dog walked.\" end task :ready_for_the_day => [:turn_off_alarm, :groom_myself, :make_coffee, :walk_dog] do puts \"Ready for the day!\" end 通过rake ready_for_the_day来执行任务，然后你就可以看到，所有的task都在按照你预定的顺序在执行。 Turned off alarm. Would have liked 5 more minutes, though. Brushed teeth. Showered. Shaved. Made 5 cups of coffee. Shakes are gone. Dog walked. Ready for the day! 此外还可以用过rake make_coffee COFFEE_CUPS=5这样在命令中给变量赋值。 命名空间 上面那样定义任务没有问题，但如果你需要另外定义些事物，比如工作相关的，交通相关的，这时候所有的任务混杂到一起显然就不合适了，毕竟上面那些任务只是我们起床的例行事物，与其它无关。 通过namespace可以帮助我们定义出Rails中类似rake db:migrate的任务，描画出事物间清晰的边界，将上面的任务包括在namespace的一个代码块中，如下 namespace :morning do task :turn_of_alarm .... end 这一次我们的调用命令就需要稍微做出些许变化，rake COFFEE_CUPS=3 morning:ready_for_the_day。 是不是跟rails中的rake任务调用方式很像呢？ 默认Task 有了上面那些设置，如果我们忘记或者不想写详细的任务名称，直接执行rake会有什么效果呢，结果是rake aborted!,任务被中断的报错。既然有这样的可能性，我们就需要消除这些隐患，通过设置default默认任务就可以做到，如下: task :default => 'morning:turn_off_alarm' 当你直接执行rake命令时，会执行默认操作，帮我们关闭闹钟。 描述你的Task 当任务渐渐变多以后，管理问题就暴露出来了，除了命名空间以外，我们还需要文档类的支持，帮助我们梳理任务并显示的告诉我们每个任务的目的和功能，这时你可以试一试用desc描述任务。 ... desc \"Make coffee\" task :make_coffee do cups = ENV[\"COFFEE_CUPS\"] || 2 puts \"Made #{cups} cups of coffee. Shakes are gone.\" end ... 上面的描述不仅可以在文档中查看，同时使用rake -T也能清洗的了解到每个任务是做什么的。rake -T的输出结果是按照字母顺序排的序。 rake morning:make_coffee # Make coffee 调取Task Rake还允许在不同任务之间互相调用，例如下面的代码,你想在下午也来杯咖啡，不用重复定义，直接使用上午的泡法，来一杯即可。 namespace :afternoon do task :make_coffee do Rake::Task['morning:make_coffee'].invoke puts \"Ready for the rest of the day!\" end end Rake脚本编写 先来个简单的例子,如下: 假设你是一个火星成员,老版本那些,即如燕儿虎跑之类的,在周末你打算去车车那边打火锅,然后集体PC去.对应这个情况,你需要为自己制定三个任务:搭车找车车、烤鱼和网吧PC.用vim创建创建一个名叫rakefile的文件(备注:Rake会在当前路径下寻找名叫Rakefile、rakefile、RakeFile.rb和rakefile.rb的rake文件),并键入如下代码: desc \"任务1 -- 搭车去车车那里\"#这据说是个苦差,因为太远了 task :busboy do puts \"发现挫男\" end desc \"任务2 -- 烤鱼\" task :bitchfish do puts \"老板,先烤九斤鱼\" end desc \"任务3 -- 网吧PC\" task :pc do puts \"我选中路\" end 打开命令行工具,进入这个文件所在目录,然后运行下面的命令,大致应该类似如下结果: D:\\work>rake busboy (in D:/work) 发现挫男 D:\\work>rake bitchfish (in D:/work) 老板,先烤九斤鱼 D:\\work\\ruby_works\\ruby_book>rake laundry (in D:/work) 我选中路 (备注:文字部分是没啥逻辑的,纯粹娱乐下...) 分析： 相信看完上面那段东东,你已经知道怎么搞了...现在介绍些基础知识,方便加深理解.从上面的代码可以知道,此文件一共定义了3个任务,desc是Rake定义的方法,表示对下面定义任务的描述.这个描述会在使用Rake --tasks(或者Rake -T)命令时输出在屏幕上. D:\\work>rake --tasks (in D:/work) rake bitchfish #任务2 -- 烤鱼 rake busboy #任务1 -- 搭车去车车那里(这据说是个苦差,因为太远了) rake pc 任务3 -- 网吧PC task是Rake最重要的方法.它的方法定义是:task(args, &block).任务体是一个block,本例中只是简单输出你所要做的工作.需要注意的是代码 puts \"发现挫男\" 完全是一个普通的Ruby语句,puts是Ruby中进行输出的一般性方法,可以看出,Rake任务可以完全使用Ruby的能力,这使得它非常强大. go..go..go..go.. 接下来加入依赖关系： 很显然,在我们定义的任务中,\"烤鱼\"是依赖于\"搭车去车车那里\"的(其它地方有没烤鱼吃不知道,反正地点就定在那了).那么,我们需要在我们的任务定义中加入这个依赖关系,修改后的文件如下: desc \"任务1 -- 搭车去车车那里\" task :busboy do puts \"发现挫男\" end desc \"任务2 -- 烤鱼\" task :bitchfish => :busboy do puts \"老板,先烤九斤鱼\" end desc \"任务3 -- 网吧PC\" task :pc do puts \"我选中路\" end 再次运行烤鱼任务,你会得到如下结果: D:\\work>rake bitchfish (in D:/work) 发现挫男 老板,先烤九斤鱼 加入命名空间： 跟任何编程语言类似,当你的rake文件很多时,当你有很多任务的时候,你需要关注它们的命名冲突问题,命名空间(namespace)就是一个自然的解决方案.你可以为上面的三个任务定义一个叫做dan的命名空间. namespace :dan do desc \"任务1 -- 搭车去车车那里\" task :busboy do puts \"发现挫男\" end …… end 再次运行rake --tasks,你会得到如下的结果: D:\\work >rake --tasks (in D:/work) rake dan:bitchfish # 任务2 -- 烤鱼 rake dan:pc # 任务3 -- 网吧PC rake dan:busboy # 任务1 -- 搭车去车车那里 你现在需要使用rake dan:bitchfish才能启动烤鱼这个任务了. (BTW,你可以在你的rakefile中使用多个命名空间,对任务进行分类.) 了解了上面两个知识点后,我们来了解下两个具体实例: 1.在一个任务中调用另外一个任务 当任务众多的时候,你很可能需要在一个任务中调用另外一个任务,假设我们把今天所有要做的工作定义为一个任务:today.在这个任务中,有两个任务需要被调用,一个是烤鱼,一个是网吧PC.当然,由于烤鱼依赖于搭车去车车那里,我们还是需要搭车去车车那里的.在文件的顶部定义一个today的任务: desc \"今天的任务\" task :today do Rake::Task[\"dan:bitchfish\"].invoke Rake::Task[\"dan:pc\"].invoke end namespace :dan do …… end 可以看出,调用其它任务的方式很简单,只需要调用 Rake::Task[\"task_name\"].invoke 方法就可以了.在命令行中启动rake today,可以得到: D:\\work >rake today (in D:/work) 发现挫男 老板,先烤九斤鱼 我选中路 2.默认任务： 可以为Rake增加一个默认任务,这样可以简单地用Rake命令来触发这个默认任务,在上面的rakefile中,我们可以用如下方式把\"today\"任务作为默认任务. task :default => [:today] 然后调用直接在命令行中调用rake,可以得到跟调用rake today同样的输出结果. 这就是我们简单的一个Rake任务定义,下面是完整的修改后的rakefile: task :default => [:today] desc \"今天的任务\" task :today do Rake::Task[\"dan:bitchfish\"].invoke Rake::Task[\"dan:pc\"].invoke end namesoace :dan do desc \"任务1 -- 搭车去车车那里(这据说是个苦差,因为太远了)\" task :busboy do puts \"发现挫男\" end desc \"任务2 -- 烤鱼\" task :bitchfish do puts \"老板,先烤九斤鱼\" end desc \"任务3 -- 网吧PC\" task :pc do puts \"我选中路\" end end 看完上面两个例子,估计rake任务就算全部了解了...其它都是些代码枪花罢了..多耍便是.. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/010-Ruby中的Rake任务详述.html":{"url":"doc/ruby/010-Ruby中的Rake任务详述.html","title":"Ruby中的Rake任务详述","keywords":"","body":"http://wenku.baidu.com/link?url=tLW8V7LpI66Z7jRd_HkqGkXi-qNTZYr11_FZ6b0lt9qf7lHMQtO5eWbQqJ4K87eFcrGZ2IAm-7oG3gzI4-_XZs2gpVdY-pODVFL8sXfCZsq ﻿Rake简介 Rake和Make及Ant Rake的意思是Ruby Make，一个用ruby开发的代码构建工具。Rake的英文意思是耙子，一种很朴实的劳动工具。真的是很贴切，Rake正是一个功能强大、勤勤恳恳的劳动工具。 但是，为什么Ruby需要Rake？ Ruby代码不需要编译，为什么需要Rake？其实，与其说Rake是一个代码构建工具，不如说Rake是一个任务管理工具，通过Rake我们可以得到两个好处： 以任务的方式创建和运行脚本 当然，你可以用脚本来创建每一个你希望自动运行的任务。但是，对于大型的应用来说，你几乎总是需要为数据库迁移（比如Rails中db:migrate任务）、清空缓存、或者代码维护等等编写脚本。对于每一项任务，你可能都需要写若干脚本，这会让你的管理变得复杂。那么，把它们用任务的方式整理到一起，会让管理变得轻松很多。 追踪和管理任务之间的依赖 Rake还提供了轻松管理任务之间依赖的方式。比如，“migrate”任务和“schema：dump”任务都依赖于 “connect_to_database”任务，那么在“migrate”任务调用之前，“connect_to_database”任务都会被执行。 在哪里可以获得Rake？ Rake的主页是在http://rake.rubyforge.org/，在这里你可以获得Rake的简单介绍，API以及一些有用文档的链接。可以在http://rubyforge.org/frs/?group_id=50获得最新版的Rake，在作者写作时，最新版本是0.7.3。 Rake脚本编写 一个简单脚本 Rake的脚本相当简单，下面用一个例子进行说明。假设你是一个勤劳的家庭型程序员，在周末你打算为你的家人做一些贡献。所以你为自己制定了三个任务：买菜、做饭和洗衣服。打开你的文本编辑器，创建一个名叫rakefile的文件（Rake会在当前路径下寻找名叫Rakefile、rakefile、RakeFile.rb和rakefile.rb的rake文件），并输入如下内容： desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end desc \"任务2 -- 做饭\" task :cook do puts \"做一顿香喷喷的饭菜。\" end desc \"任务3 -- 洗衣服\" task :laundry do puts \"把所有衣服扔进洗衣机。\" end 打开命令行工具，进入这个文件所在目录，然后运行下面的命令，大致应该类似如下结果： D:\\work\\ruby_works\\ruby_book>rake purchaseVegetables (in D:/work/ruby_works/ruby_book) 到沃尔玛去买菜。 D:\\work\\ruby_works\\ruby_book>rake cook (in D:/work/ruby_works/ruby_book) 做一顿香喷喷的饭菜。 D:\\work\\ruby_works\\ruby_book>rake laundry (in D:/work/ruby_works/ruby_book) 把所有衣服扔进洗衣机。 分析 很简单，也很易读，对吧。这个文件一共定义了3个任务，desc是Rake定义的方法，表示对下面定义任务的描述。这个描述会在使用Rake --tasks（或者Rake -T，为懒人准备的快捷方式）命令时输出在屏幕上。 D:\\work\\ruby_works\\ruby_book>rake --tasks (in D:/work/ruby_works/ruby_book) rake cook # 任务2 -- 做饭 rake laundry # 任务3 -- 洗衣服 rake purchaseVegetables # 任务1 -- 买菜 下面的语句定义了purchaseVegetables这个任务，task是Rake最重要的方法。它的方法定义是：task(args, &block)。任务体是一个block，本例中只是简单输出你所要做的工作。需要注意的是代码 puts \"到沃尔玛去买菜。\" 完全是一个普通的Ruby语句，puts是Ruby中进行输出的一般性方法，可以看出，Rake任务可以完全使用Ruby的能力，这使得它非常强大。 加入依赖关系 很显然，在我们定义的任务中，做饭是依赖于买菜的（我相信大多数程序员在周末的冰箱里除了可乐没有别的）。那么，我们需要在我们的任务定义中加入这个依赖关系，修改后的文件如下： desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end desc \"任务2 -- 做饭\" task :cook => :purchaseVegetables do puts \"做一顿香喷喷的饭菜。\" end desc \"任务3 -- 洗衣服\" task :laundry do puts \"把所有衣服扔进洗衣机。\" end 再次运行做饭任务，你会得到如下结果： D:\\work\\ruby_works\\ruby_book>rake cook (in D:/work/ruby_works/ruby_book) 到沃尔玛去买菜。 做一顿香喷喷的饭菜。 是的，你当然需要先买菜，谁让你是一个冰箱空空如野的程序员呢。 命名空间 跟任何编程语言类似，当你的rake文件很多时，当你有很多任务的时候，你需要关注它们的命名冲突问题，命名空间（namespace）就是一个自然的解决方案。你可以为上面的三个任务定义一个叫做home的命名空间。 namespace :home do desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end …… end 再次运行rake --tasks，你会得到如下的结果： D:\\work\\ruby_works\\ruby_book >rake --tasks (in D:/work/ruby_works/ruby_book) rake home:cook # 任务2 -- 做饭 rake home:laundry # 任务3 -- 洗衣服 rake home:purchaseVegetables # 任务1 -- 买菜 你现在需要使用rake home:cook才能启动做饭这个任务了。当然，你可以在你的rakefile中使用多个命名空间，对任务进行分类。 在一个任务中调用另外一个任务 当任务众多的时候，你很可能需要在一个任务中调用另外一个任务，假设我们把今天所有要做的工作定义为一个任务：today。在这个任务中，有两个任务需要被调用，一个是做饭，一个是洗衣服。当然，由于做饭依赖于买菜，我们还是需要买菜的（这一步是逃不过去的，呵呵）。在文件的顶部定义一个today的任务： desc \"今天的任务\" task :today do Rake::Task[\"home:cook\"].invoke Rake::Task[\"home:laundry\"].invoke end namespace :home do …… end 可以看出，调用其它任务的方式很简单，只需要调用Rake::Task[\"task_name\"].invoke 方法就可以了。在命令行中启动rake today，可以得到： D:\\work\\ruby_works\\ruby_book >rake today (in D:/work/ruby_works/ruby_book) 到沃尔玛去买菜。 做一顿香喷喷的饭菜。 把所有衣服扔进洗衣机。 默认任务 可以为Rake增加一个默认任务，这样可以简单地用Rake命令来触发这个默认任务，在上面的rakefile中，我们可以用如下方式把“today”任务作为默认任务。 task :default => [:today] 然后调用直接在命令行中调用rake，可以得到跟调用rake today同样的输出结果。 这就是我们简单的一个Rake任务定义，下面是完整的修改后的rakefile： task :default => [:today] desc \"今天的任务\" task :today do Rake::Task[\"home:cook\"].invoke Rake::Task[\"home:laundry\"].invoke end namespace :home do desc \"任务1 -- 买菜\" task :purchaseVegetables do puts \"到沃尔玛去买菜。\" end desc \"任务2 -- 做饭\" task :cook => :purchaseVegetables do puts \"做一顿香喷喷的饭菜。\" end desc \"任务3 -- 洗衣服\" task :laundry do puts \"把所有衣服扔进洗衣机。\" end end Rails中的Rake任务 Rails预定义了大量的Rake任务，在Rails应用的开发过程中，你想必已经在大量使用它们了。在Rails中，所有的Rake任务都放在rails目录的lib/tasks目录下（在作者的环境下是c:\\ruby\\lib\\ruby\\gems\\1.8\\gems\\rails-1.1.4\\lib\\tasks\\），所有的rake任务都以.rake作为后缀名，这些以.rake结尾的文件会被自动加载到你的环境中。你可以到一个已有的Rails工程根目录下键入rake --tasks，可以看到很多的rake任务已经为你整装待发了。 在Rails中，最常使用的Rake任务之一是进行数据库的迁移（migration）。数据库迁移程序允许你使用Ruby脚本来定义数据库模式，而db:migrate就是进行这个工作的rake任务。下面我们来分析这个rake任务。 db:migrate任务 db:migrate任务存放在lib/tasks/databases.rake文件中。这个文件中定义了所有与数据库操作相关的任务，我们仅仅抽出db:migrate的定义： namespace :db do desc \"Migrate the database through scripts in db/migrate. Target specific version with VERSION=x\" task :migrate => :environment do ActiveRecord::Migrator.migrate(\"db/migrate/\", ENV[\"VERSION\"] ? ENV[\"VERSION\"].to_i : nil) Rake::Task[\"db:schema:dump\"].invoke if ActiveRecord::Base.schema_format == :ruby end …… end 分析 首先是命名空间的声明，migrate任务的命名空间是db。这也就是我们用db:migrate来引用它的原因。 下面是一个描述，说明该任务的功能是把定义在db/migrate目录下（相对于你的Rails应用程序的根目录）的迁移脚本迁移到数据库中，如果不指定VERSION的话，默认是最新版本，否则可以恢复到一个指定的版本。 接着是任务的定义，该任务依赖于enviroment任务，这个任务在misc.rake中定义，用来加载Rails的环境，它的定义相当简单： task :environment do require(File.join(RAILS_ROOT, 'config', 'environment')) end 用来加载config/environment.rb文件，该文件会加载Rails工作所需要加载的环境。由于加载了这个环境，所以ActiveRecord对象现在可以使用，下面就是调用ActiveRecord::Migrator.migrate方法对每个db/migrate/下的脚本文件进行迁移。 最后会调用db:schema:dump任务，该任务的主要作用是产生db/schema.rb文件。该文件用来记录不同版本的数据库模式。这个任务的定义就在db:migrate任务下面不远的地方，有兴趣的读者可以自行进行分析。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/011-ruby_on_Rails中的Rake教程.html":{"url":"doc/ruby/011-ruby_on_Rails中的Rake教程.html","title":"ruby_on_Rails中的Rake教程","keywords":"","body":"http://blog.csdn.net/maowenbin/article/details/5539564 原文：http://jasonseifer.com/2010/04/06/rake-tutorial 引言：作为一个rails的开发者，你可能很熟悉使用rake进行你的测试，或者使用rake db:migrate运行你的migrations，但是你真的知道Rake的背后故事吗？你意识到可以自己写一个Rake任务或者一个有用的 lib吗 ？ 下面是我们使用Rake任务的例子： 1、给列表中的用户发送邮件 2、每晚数据的计算和报告 3、过期或重新生成缓存 4、备份数据和svn版本(how's this : subversion repository ) 5、运行数据处理脚本(sort of,how much is called this ) 6、Pouring drinks to get a good buzz on(一句玩笑，是这两位仁兄的风格) 这篇文章中，我们将讨论为什么要创建Rake，和他怎么样帮助我们的rails应用。最好你可以写自己的Rake。 一、历史回顾：make 为了了解Rake的来历，我们先了解一下Rake的爷爷：Make。 让我们回到那个代码块需要编译，解释性语言和iphone还没出现在地球上的时代。 回到那时，我们下载的大型程序，还是一堆源代码和一个shell脚本。这个shell脚本包含了所有需要用来compile/link/build的代 码。你需要运行“install_me.sh”这个脚本，每一行代码将被运行（编译每一行源文件），然后生成一个你能够运行的文件。 对于大多数人这样是不错的，但是对于程序开发人员却是一个不幸。每次你对源代码进行一个小的改动，并进行测试的时候，你需要回到shell脚本，并重新编 译所有的源代码，显然对于大的程序“那是相当的”耗时的。 1977年（作者出生那年，我78年），贝尔实验室的Stuart Feldman创造了“make”。解决了编译时间过长的问题。Make用来编译程序，取得两方面的进步： Stuart Feldman （1）Make可以发现哪个文件在上一次编译后改动过，根据这点，再次运行Make时，仅编译改动过的文件。这个很大程序上减少了重新编译大型程序的时 间。 （2）Make可以进行从属跟踪。你可以告诉编译器，源文件A的编译需要源文件B，源文件B的编译需要源文件C，所以Make在编译A时发现B没有编译， 将会先编译B。 可以这样定义：Make是一个可执行程序。像ls或dir一样。让Make理解如何让编译一个项目，需要创建一个makefile文件，描述所有的源文件 和依赖关系。makefiles有自己的语法，你不用去了解。 这些年Make出现了其他的变体，并且被其他的语言使用。事实上，ruby用户在rake出现前也在使用它。 “但是，ruby并不需要编译，我们用它来干嘛？” 是啊。ruby是一个解释性语言，我们不需要编译它的源代码，所以ruby程序员为什么使用它呢？ 两个重要的原因： （1）创建任务 在大型的应用中，你经常编写脚本，在命令行下运行一些任务。比如清除缓存，维护任务，或者迁移数据库。你可以写一个MakeFile来组织你的任务，而不 是写十个不相干的脚本（或者一个复杂的）。这样你可以简单的运行：“make stupid”。 （2）从属任务跟踪 当你开始写一些维护任务的时候，可能发现有些任务的使用可能有重复。比如，“migrate”任务和“schema:dump”都需要链接数据库，这样我 可以创建一个任务\"connect_to_database\"，使“migrate”和“schema:dump”都依赖 于\"connect_to_database\"，这样下次运行“migrate”时，\"connect_to_database\"会先于 “migrate”运行 二、如何得到Rake 几年前，Jim Weirich 在一个 Java项目上使用了Make，他发现如果在他的Makefile中写一小段ruby代码 将会带来非常大的方便。所以 他创建了Rake。 左：Jim Weirich，中：Jason Seifer，右：Gregg Pollack （后面两位为本文作者） Jim 为Rake创建了任务功能，附属关系跟踪，甚至创建了时间段判断(timestamp recognition)，（在上一次编译的基础上仅编译改动的部分），当然，对于ruby，我们并不需要编译。 我很想知道Jim在代码里做了什么，你也想知道吧。Jim可能从来没想给这个代码写个文档，可能现在他也是被烦透了，写了一个 。呵 呵 三、Rake如何工作 开始我想给这个部分起名为\"How to get wasted with Rake\"。 那么我想喝点酒，该怎么做呢？ 1、去买酒 2、喝酒 3、喝醉 如果我要使用Rake完成这个任务，我会创建一个“Rakefile”文件： task :purchaseAlcohol do puts \" Purchased Vodka \" end task :mixDrink do puts \" Mixed Fuzzy Navel \" end task :getSmashed do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end 这样我可以在这个Rakefile的目录，分别运行这些任务： $ rake purchaseAlcohol Purchased Vodka $ rake mixDrink Mixed Fuzzy Navel $ rake getSmashed Dood , everthing' s blurry, can I halff noth ' r drinnnk? 酷！但是从顺序上看，我可以用任何的顺序运行这个任务。比如喝醉在买酒或者喝酒之前。当然这不符合人的习惯。 四、Rake的顺序 task :purchaseAlcohol do puts \" Purchased Vodka \" end task :mixDrink => :purchaseAlcohol do puts \" Mixed Fuzzy Navel \" end task :getSmashed => :mixDrink do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end 这样，如果想喝酒，就得先去买，如果想喝醉，就得先喝酒。 $ rake purchaseAlcohol Purchased Vodka $ rake mixDrink Purchased Vodka Mixed Fuzzy Navel $ rake getSmashed Purchased Vodka Mixed Fuzzy Navel Dood , everthing' s blurry, can I halff noth ' r drinnnk? 看到了吧，我喝醉和，因为酒已经买了，也被我喝了。(译者：我是喜欢百事的，所以倘若我写，定然拿百事当例子。但是我让我儿子和可口，为什么呢？下面告诉 你。) 现在，你的欲望无法满足了，你想让你的朋友加入进来。就像一个团队的开发，如果你想加入一个新人，你得有合适的规划。你得有文档。那么问题来了。 五、如何给我的Rake添加文档 Rake添加文档非常的方便，使用“desc”就可以了： desc \" This task will purchase your Vodka \" task :purchaseAlcohol do puts \" Purchased Vodka \" end desc \" This task will mix a good cocktail \" task :mixDrink => :purchaseAlcohol do puts \" Mixed Fuzzy Navel \" end desc \" This task will drink one too many \" task :getSmashed => :mixDrink do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end 看到了吧，我的每个任务都添加了desc，这样我们可以输入\"rake -T\"或者\"rake --tasks\": $rake --tasks rake getSmashed # This task will drink one too many rake mixDrink # This task will mix a good cocktail rake purchaseAlcohol # This task will purchase your Vodka 简单乎？呵呵 六、Rake的命名空间 当你开始酗酒，并且开始使用大量的rake任务的时候，你需要一个好方法将他们分类，这时用到了命名空间，如果我在上面的例子使用了命名空间，那么： namespace :alcoholic do desc \" This task will purchase your Vodka \" task :purchaseAlcohol do puts \" Purchased Vodka \" end desc \" This task will mix a good cocktail \" task :mixDrink => :purchaseAlcohol do puts \" Mixed Fuzzy Navel \" end desc \" This task will drink one too many \" task :getSmashed => :mixDrink do puts \" Dood, everthing's blurry, can I halff noth'r drinnnk? \" end end 命名空间允许你将一些任务放到特定的分类中，在一个Rakefile中，你可以加入几个命名空间。运行rake --tasks rake alcoholic:getSmashed # This task will drink one too many rake alcoholic:mixDrink # This task will mix a good cocktail rake alcoholic:purchaseAlcohol # This task will purchase your Vodka 所以如果想运行这个任务，只要输入 rake alcoholic:getSmashed： 七、如何写一个有用的ruby任务 最近，我想用ruby创建几个文件夹： desc \" Create blank directories if they don't already exist \" task(:create_directories ) do # The folders I need to create shared_folders = [\" icons \" ,\" images \" ,\" groups \" ] for folder in shared_folders # Check to see if it exists if File .exists?(folder) puts \" #{ folder} exists \" else puts \" #{ folder} doesn't exist so we're creating \" Dir .mkdir \" #{ folder} \" end end end 当然，还可以在rake中使用更多的 文件工具File Utils ， 或者加入其他的部分。 八、如何为我的rails应用写一个Rake任务 一个rails应用中，已经有了一些rake任务，你可以在你的项目目录里运行：rake --tasks。 为了给你的rails应用添加一个新的任务，你可以打开/lib/tasks目录（已经存在的），添加一个叫 something.rake的文 件，这个任务会被自动的检索到，这些任务会被添加到rake tasks列表中，你可以在根目录里运行他们，现在把我们上面的例子放到这个rails应用中。 utils.rake namespace :utils do desc \" Create blank directories if they don't already exist \" task(:create_directories ) do # The folders I need to create shared_folders = [\" icons \" ,\" images \" ,\" groups \" ] for folder in shared_folders # Check to see if it exists if File .exists?(\" #{ RAILS_ROOT } /public/ #{ folder} \" ) puts \" #{ RAILS_ROOT } /public/ #{ folder} exists \" else puts \" #{ RAILS_ROOT } /public/ #{ folder} doesn't exist so we're creating \" Dir .mkdir \" #{ RAILS_ROOT } /public/ #{ folder} \" end end end end 注意上面的代码，我使用了#{RAILS_ROOT} 来得到rails应用的当前位置，现在运行“rake --tasks”，你可以看到我们的任务已经添加到tasks列表中了。 ... rake tmp:pids :clear # Clears all files in tmp/pids rake tmp:sessions :clear # Clears all files in tmp/sessions rake tmp:sockets :clear # Clears all files in tmp/sockets rake utils:create_directories # Create blank directories if they don't already exist ... 九、如何在任务中调用rails的model 呵呵，这个正是我最多使用rake的地方，写一个rake任务，代替原来需要手工操作的地方，或者一些任务代替经常需要按照计划自动执行（使用 cronjobs ） 的事情。就像我开头说的那样我用rake任务执行下面的擦作： 1、给列表中的用户发送邮件 2、每晚数据的计算和报告 3、过期或重新生成缓存 4、备份数据和svn版本(how's this : subversion repository ) 5、运行数据处理脚本(sort of,how much is called this ) 这个补充了原来的功能，而且相当简单。下面这个任务是检查用户的过期时间，对快过期的用户发送邮件。 utils.rake namespace :utils do desc \" Finds soon to expire subscriptions and emails users \" task(:send_expire_soon_emails => :environment ) do # Find users to email for user in User .members_soon_to_expire puts \" Emailing #{ user.name} \" UserNotifier .deliver_expire_soon_notification(user) end end end 使用你的model只用一步，\"=> :environment\" task(:send_expire_soon_emails => :environment) do 如果在我的开发环境上运行这个任务，我只需要 \"rake utils:send_expire_soon_emails\" ， 如果我想在产品环境下运行这个任务，我需要\"rake RAILS_ENV=production utils:send_expire_soon_emails\" 。 如果你想在每晚都运行这个任务，你需要写一个 cronjob ，像这样： 0 0 * * * cd / var / www/apps/rails_app/ && / usr / local/bin/rake RAILS_ENV =production utils:send_expire_soon_emails 相当的方便。 十、在哪找到一些例子 现在对一个有用的rake任务已经了解很多了，那么我将给你几个资源，我想最好的学习方法是看看别人的代码。 brand new rake tasks 在edge rails 中，这个可以创建和重置你的数据库。 Craig Ambrose写的数据库备份， database backups 。 Adam Greene写了一组任务 set of Rake tasks ，可以将所有的数据备份到amazon S3。他还给了我一个升级版本，你可以在这下载here 。 Jay Fields的任务测试，testing rake tasks 。 a new way of setting the RAILS_ENV and teaches how to use rake to boot you into a Mysql shell （看的时候留意一下他的注释） Rake Bookshelf Books ， 和Martin Fowler的Using the Rake Build Language 教程，这两个都很有用，虽然有点过时。 如果你发现其他更好的文章，发贴子给我们。 译者：恩，这段不用翻译，懂的朋友自然会去看的了。 Still reading? If you are, I wanted to let you know that we're looking for more people to write for RailsEnvy. If you have an idea for a good rails tutorial we want to hear from you! Basically we would work with you to flesh out the tutorial and help polish (acting as an editor). It could definitely be a great way to get your name out there, and start getting some hits (for your blog or company). Email Gregg at RailsEnvy if you're interested. 另：我刚收到jim的邮件，如何更简单的创建我的目录。 # This is needed because the existing version of directory in Rake is slightly broken, but Jim says it'll be fixed in the next version. alias :original_directory :directory def directory (dir) original_directory dir Rake ::Task [dir] end # Do the directory creation namespace :utils do task :create_directories => [ directory(' public/icons ' ), directory(' public/images ' ), directory(' public/groups ' ), ] end 注：图片均来自英文原文(Pics come from the english page) (译者：目前这个内容不是研究的重点，所以会不忙的时候翻译一点点) powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/012-ruby_or_rails_错误解决.html":{"url":"doc/ruby/012-ruby_or_rails_错误解决.html","title":"rubyor_rails错误解决","keywords":"","body":" rails fileutils.rb:250:in `mkdir': Permission denied @ dir_s_mkdir 由于之前安装了miq-Citrix,导致manageiq登陆不上提示token无效 Mac下irb中文乱码 rails fileutils.rb:250:in `mkdir': Permission denied @ dir_s_mkdir http://stackoverflow.com/questions/33754137/rails-server-command-returns-error-mkdir-permission-denied-dir-s-mkdir 这个问题就是rails要创建的文件没有权限，如果你了解这个文件路径，那么可以手动修改这个路径的权限,则问题就解决了。 sudo mkdir tmp sudo chmod 777 tmp 由于之前安装了miq-Citrix,导致manageiq登陆不上提示token无效 删除系统中/var 中的 www 文件夹就好了 Mac下irb中文乱码 错误信息： // 在终端使用irb， 然后使用中文字符串会出现下面问题 irb(main):002:0* str = '\\U+FFE4\\U+FFB8\\U+FFAD\\U+FFE5\\U+FFBD' 解决办法： 经查找在Mac下需要readline 编译ruby版本才可以。 // 先安装readline brew install readline Updating Homebrew... Downloading https://homebrew.bintray.com/bottles/readline-7.0.3_1.high_sierr ######################################################################## 100.0% ==> Pouring readline-7.0.3_1.high_sierra.bottle.tar.gz ==> Caveats This formula is keg-only, which means it was not symlinked into /usr/local, because macOS provides the BSD libedit library, which shadows libreadline. In order to prevent conflicts when programs look for libreadline we are defaulting this GNU Readline installation to keg-only.. For compilers to find this software you may need to set: LDFLAGS: -L/usr/local/opt/readline/lib CPPFLAGS: -I/usr/local/opt/readline/include ==> Summary 🍺 /usr/local/Cellar/readline/7.0.3_1: 46 files, 1.5MB // 卸载ruby版本 // 使用上面的路径来安装新的ruby版本 LDFLAGS: -L/usr/local/opt/readline/lib CPPFLAGS: -I/usr/local/opt/readline/include rvm install ruby版本 // 安装好后重新reload一下环境 rvm reload // 使用刚安装的ruby版本 rvm use ruby版本 参考链接： http://my.tv.sohu.com/us/63263814/28072115.shtml powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/013-ruby面试题.html":{"url":"doc/ruby/013-ruby面试题.html","title":"ruby面试题","keywords":"","body":" ruby 基础 1、each、map、collect的区别 2、Block, lambda, Proc 的区别 ruby中闭包 3、alias 的用法, alias 与 alias_method 的区别 4、Ruby的对象体系 5、 Include, Extend, Load, Require 的使用区别 6、yield、yield self 7、 Ruby中的元编程 7.1 实例变量、方法、类 7.2 send、eval、respond_to? 8、全局变量，实例变量，局部变量，类变量，Symbol 9、ruby的特点 rails active record 创建、查询、修改、删除 关联模型 查询接口 数据库基本操作 其他面试题 ruby 基础 1、each、map、collect的区别 each: 仅遍历数组，并做相应操作，数组本身不发生改变。 map:遍历数组，并做相应操作后，返回新数组(处理)，原数组不变。 collect: 跟map作用一样。 collect! map!: 多了一个作用，改变原数组。 // 终端打开 irb // each a = [ \"a\", \"b\", \"c\", \"d\" ] b = a.each { |x| x + \"!\" } // a == b == [ \"a\", \"b\", \"c\", \"d\" ] // map map! a = [ \"a\", \"b\", \"c\", \"d\" ] b = a.map { |x| x + \"!\" } a // [\"a\", \"b\", \"c\", \"d\"] b // [\"a!\", \"b!\", \"c!\", \"d!\"] c = a.map! { |x| x + \"!\" } a // [\"a!\", \"b!\", \"c!\", \"d!\"] c // [\"a!\", \"b!\", \"c!\", \"d!\"] // collect collect! a = [ \"a\", \"b\", \"c\", \"d\" ] b = a.collect { |x| x + \"!\" } a // [\"a\", \"b\", \"c\", \"d\"] b // [\"a!\", \"b!\", \"c!\", \"d!\"] c = a.collect! { |x| x + \"!\" } a // [\"a!\", \"b!\", \"c!\", \"d!\"] c // [\"a!\", \"b!\", \"c!\", \"d!\"] 2、Block, lambda, Proc 的区别 proc和lambda都是对象，而block不是 block是proc的实例，proc可以重复使用，函数参数只能有一个block，但可以有多个proc # 说明block是proc的一个实例 def what_am_i(&block) block.class end puts what_am_i {} # = lambda会检查参数个数，proc不会。 lam = lambda { |x| puts x } # creates a lambda that takes 1 argument lam.call(2) # prints out 2 lam.call # ArgumentError: wrong number of arguments lam.call(1,2,3) pro = Proc.new { |x| puts x } # creates a proc that takes 1 argument pro.call(2) # 2 pro.call # returns nil pro.call(1,2,3) # 1 lambda和proc对于return处理方式不同 lambda：一个函数调用lambda，lambda里return后返回函数接着执行。 proc: 一个函数调用proc，proc里return后， 函数也会return。 def lambda_test lam = lambda { return } lam.call puts \"Hello world\" end lambda_test def proc_test proc = Proc.new { return } proc.call puts \"Hello world\" end proc_test 参考资料： What Is the Difference Between a Block, a Proc, and a Lambda in Ruby? 浅谈Ruby中的block, proc, lambda, method object的区别 ruby中闭包 在Ruby里，如果该方法返回一个代码块，而该代码块获得了局部变量的引用，则这些局部变量将在方法返回后依然可以访问。 def show(name) count = 1; return proc do |value| puts count +=1; puts name + '我是闭包' + value end end sh = show(\"ruby\") sh.call('213') sh.call('kkk') 参考： Ruby的4种闭包：blocks, Procs, lambdas 和 Methods 3、alias 的用法, alias 与 alias_method 的区别 alias: 给已经存在的方法或变量设置一个别名，在重新定义已存在的方法时，还可以通过别名来调用原来的方法。 alias_method: 和alias类似，但只能给方法起别名，是Module的一个私有实例方法。 class Demo def hello puts \"old_hell0\" end # 给hello方法取别名 # alias old_hello hello alias_method :old_hello, :hello def hello puts \"new_hello\" end end obj = Demo.new obj.hello obj.old_hello 参考： https://www.cnblogs.com/smallbottle/p/3968704.html https://ruby-china.org/topics/27747 4、Ruby的对象体系 +------------+ | BasicObject| +------------+ ^ |superclass | +----+-----+ superclass-----------+ | Object | ^----------| Module | +----+-----+------+ +-+---------+ ^ | ^ |superclass | |Superclass | | | +---------+ +-+-------+ +---> +-+-------+ | 'hello' | class | String | class | Class | | +---------->+ +--------->+ +------> +---------+ +---------+ +----+----+ | ^ | | class | ![](https://img-blog.csdn.net/20160413232121267?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 'hello'.class # String String.class # Class String.superclass # Object Class.class # Class Class.superclass # Module Module.class # Class Module.superclass # Object Object.class # Object Object.superclass # BasicObject BasicObject.class # Class BasicObject.superclass # nil Module是Class的父类，Class和Module的差别是Class是一个增强的Module，它比Module多了一个new，allocate方法，除了这一个区别，当然这个区别特别重要，Class和Module基本是一样的。 参考： https://blog.csdn.net/feigeswjtu/article/details/51040006 5、 Include, Extend, Load, Require 的使用区别 include和extend用于在类中引入模块，区别： include：把模块中的方法作为类的实例方法 extend: 把模块中的方法作为类的类方法 module A def class_type puts \"This class is of type:#{self.class}\" end end class B extend A end class C include A end B.class_type C.new.class_type require、load用于加载库，如.rb文件，区别： require: 加载一个库，并且只加载一次，如果多次加载会返回false。文件不需要扩展名 load: 加载一个库，可多次加载。需要指定文件扩展名。 # 在当前目录中有一个 two.rb文件 require './two'; load './two.rb'; 6、yield、yield self 所有的方法(methods)都会隐式的带一个块(block)参数。 yield用来执行块参数，也可以通过call()方法执行。 yield 相当于是 block.call() 方法的调用，所以参数个数也需要对应, method 定义中 &block 参数必须在最后 def foo1() yield 1,2,3 # 这里的 1 2 3 就是传递的参数 end def foo2(time, &block) yield 1, 2, 3 block.call(5, 6, 7) puts time end foo1 {|x,y,z| puts z} # => 3 foo2('2018') {|x,y,z| puts z} # => 3 7 2018 yield self 在一个对象中，self 表示是一个当前对象的引用。 yield self if block_given? 相当于如果有块参数，那个调用快参数，参数是自己。 def foo(&block) puts self yield self if block_given? yield \"AAAAAAAAA\" end foo {|x| puts x} foo 参考链接：https://www.cnblogs.com/licongyu/p/5522027.html 7、 Ruby中的元编程 Ruby中的元编程，是可以在运行时动态地操作语言结构（如类、模块、实例变量等）的技术。你甚至于可以在不用重启的情况下，在运行时直接键入一段新的Ruby代码，并执行它。 　　Ruby的元编程，也具有“利用代码来编写代码”的作用。例如，常见的attr_accessor等方法就是如此。 7.1 实例变量、方法、类 同一个类的实例可以有不同的实例变量，因为实例变量只有使用的时候才会被建立。 匿名类：对一个具体对象添加方法是，ruby会插入一个新的匿名类来容纳新建的方法，匿名类不可见。 def initialize(*args): 方法可以通过参数不同执行不同的操作 7.2 send、eval、respond_to? send send是Object类的实例方法。第一个参数是方法名，后面是方法的参数 使用send方法，你所想要调用的方法就顺理成章的变成了一个普通的参数。你可以在运行时，直至最后一刻自由决定到底调用哪个方法。 class Rubyist def welcome(*args) \"Welcome \" + args.join(' ') end end obj = Rubyist.new puts(obj.send(:welcome, \"hello\", \"world\")) eval(\"obj.welcome('123')\") eval 用于执行一个用字符串表示的代码,eval方法可以计算多行代码，使得将整个程序代码嵌入到字符串中并执行成为了可能。eval方法很慢，在执行字符串前最好对其预先求值。 str = \"Hello\" puts eval(\"str + ' world'\") # => \"Hello world\" respond_to? 所有的对象都有此方法，使用respond_to?方法，你可以确定对象是否能使用指定的方法。 obj = Object.new if obj.respond_to?(:program) obj.program else puts \"Sorry, the object doesn't understand the 'program' message.\" end 参考资料：http://deathking.github.io/metaprogramming-in-ruby/chapter04.html 参考资料： Ruby中的元编程 8、全局变量，实例变量，局部变量，类变量，Symbol 格式 名称 作用范围 举例 $开头 全局变量 从定义到程序结束 $name @开头 实例变量 self @name @@开头 类变量 内部直接用，外部用类名::变量名 @@name [a-z_]开头 局部变量 定义的类、模块、方法内部，在类、模块、方法间不能共享 name [A-Z] 常量 内部、外部均可，外部访问类名::常量名 NAME :开头 Symbol 内外 :name 参考资料：https://blog.csdn.net/emerald0106/article/details/7358766 9、ruby的特点 解释型执行，方便快捷:Ruby是解释型语言，其程序无需编译即可执行 语法简单、优雅: 完全面向对象: Ruby从一开始就被设计成纯粹的面向对象语言，因此所有东西都是对象，例如整数等基本数据类型。 内置正则式引擎，适合文本处理:Ruby支持功能强大的字符串操作和正则表达式检索功能，可以方便的对字符串进行处理。 自动垃圾收集: 具有垃圾回收（Garbage Collect，GC）功能，能自动回收不再使用的对象。不需要用户对内存进行管理。 跨平台和高度可移植性:Ruby支持多种平台，在Windows， Unix， Linux， MacOS上都可以运行。Ruby程序的可移植性非常好，绝大多数程序可以不加修改的在各种平台上加以运行。 有优雅、完善的异常处理机制: Ruby提供了一整套异常处理机制，可以方便优雅地处理代码处理出错的情况。 缺点： 解释型语言，所以速度较慢 静态检查比较少 rails active record 创建、查询、修改、删除 class Product 上面的代码会创建 Product 模型，对应于数据库中的 products 表。同时，products 表中的字段也映射到 Product 模型实例的属性上。 关联模型 关联原因： 操作两个有关系的表时简化操作。 如果两个表有关联，比如一个作者表，一个图书表，一个作者对应多本书，如果此时删除一个作者前要先把作者对应的书删除，然后在删除作者。但是关联后，只需要在模型中删除作者语句即可，删除书的动作active_record会自动完成。 belongs_to:一对一关系 belongs_to 关联创建两个模型之间一对一的关系，声明所在的模型实例属于另一个模型的实例。 写belongs_to的模型里的一条记录相对于另一个表里有唯一一条记录，叫一对一。 例如有作者和图书两个模型，而且每本书只能指定给一位作者，在图书表中写上： class Book has_one：一对一关系 has_one 关联也建立两个模型之间的一对一关系，但语义和结果有点不一样。这种关联表示模型的实例包含或拥有另一个模型的实例。例如，应用中每个供应商只有一个账户，可以这么定义供应商模型： class Supplier has_one与belongs_to的选择： ​ has_many ：一对多 has_many 关联表示模型的实例有零个或多个另一模型的实例。例如，对应用中的作者和图书模型来说，作者模型可以这样声明： class Author :through: 通过第三张表来关联 has_many :through 这种关联表示一个模型的实例可以借由第三个模型，拥有零个和多个另一模型的实例。例如，在医疗锻炼中，病人要和医生约定练习时间。这中间的关联声明如下： class Physician has_one :through 这种关联表示一个模型通过第三个模型拥有另一模型的实例。例如，每个供应商只有一个账户，而且每个账户都有一个账户历史，那么可以这么定义模型： class Supplier has_and_belongs_to_many 直接建立两个模型之间的多对多关系，不借由第三个模型。例如，应用中有装配体和零件两个模型，每个装配体有多个零件，每个零件又可用于多个装配体，这时可以按照下面的方式定义模型： class Assembly 参考资料： https://ruby-china.github.io/rails-guides/association_basics.html 查询接口 检索对象 find # 检索指定主键对应的对象，没有记录find方法抛出 ActiveRecord::RecordNotFound 异常。 client = Client.find(10) # 查找主键（ID）为 10 的客户 take # 检索一条记录而不考虑排序，没有记录take方法返回 nil，而不抛出异常。 client = Client.take # SELECT * FROM clients LIMIT 1 first # 默认查找按主键排序的第一条记录。如果没有记录，first 方法返回 nil，而不抛出异常 client = Client.first # SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1 last # 默认查找按主键排序的最后一条记录。没有记录last方法返回nil，而不抛出异常。 client = Client.last # SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1 client = Client.last(3) # 返回不超过指定数量的查询结果。 client = Client.order(:first_name).last # 返回按照指定属性排序的最后一条记录。 client = Client.last! # 和 last 方法类似,区别是没有记录会抛出 ActiveRecord::RecordNotFound 异常。 find_by # 查找匹配指定条件的第一条记录。 Client.find_by first_name: 'Lifo' # Client.where(first_name: 'Lifo').take find_each # 批量检索记录，每条记录传入块， User.find_each do |user| NewsMailer.weekly(user).deliver_now end 条件查询 where 方法用于指明限制返回记录所使用的条件，相当于 SQL 语句的 WHERE 部分。条件可以使用字符串、数组或散列指定。 纯字符串条件:容易受到 SQL 注入攻击的风险。 Client.where(\"orders_count = '2'\") # 查找所有 orders_count 字段的值为 2 的客户记录。 数组条件: 后面的参数会替换前面的问号(？) Client.where(\"orders_count = ?\", params[:orders]) Client.where(\"orders_count = ? AND locked = ?\", params[:orders], false) 条件中的占位符 Client.where(\"created_at >= :start_date AND created_at 排序 按 created_at 字段的升序方式取回记录： Client.order(:created_at) 还可以使用 ASC（升序） 或 DESC（降序） 指定排序方式： Client.order(created_at: :desc) Client.order(created_at: :asc) Client.order(orders_count: :asc, created_at: :desc) ​ 数据库基本操作 插入数据 insert into (field1,field2,field3..) values (value1,value2,value3); 查询 select * from ; select select from where =; select form where like '%value%'; // 模糊查询 删除（Delete） delete from where 更新（update) update set = where ; 参考链接：https://blog.csdn.net/yuanmxiang/article/details/51683232 https://www.cnblogs.com/daxueshan/p/6687521.html 其他面试题 https://www.jianshu.com/p/cc9f521d72ee powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/014-RubyMine常用快捷键.html":{"url":"doc/ruby/014-RubyMine常用快捷键.html","title":"RubyMine常用快捷键","keywords":"","body":" 一级必会 二级进阶 三级耍酷 更改快捷键 一级必会 Mac OS 下快捷键 行注释(Comment with Line Comment): cmd + /块注释(Comment with block Comment): alt + cmd + / Ctrl+Alt+L(alt+cmd+l,)：格式化代码(reformat code)Ctrl+D(cmd +d)：复制一行Ctrl+Y(cmd+delete)：删除一行 end, cmd + →, ctl+e: 光标移到行尾 home, cmd + 左移键, ctl+A: 光标移到行尾 alt + space, cmd+Y:快速查看方法定义源码 替换(replace...): cmd + R Edit -> find -> replace... 移动行到上面(move line up) : alt + shit 方向键上 移动行到下面(move line down) : alt + shit 方向键下 移动语句到上面(move statement up) : cmd + shit 方向键上 移动语句到下面(move statement down) : cmd + shit 方向键下 移动光标到下一个单词(move caret to next word)： alt + 方向右键 移动光标到上一个单词(move caret to previous word)： alt + 方向←键 添加书签(toggle bookmark): F3 添加书签(toggle bookmark with mnemonic): alt/option + F3 显示书签(show bookmark): cmd + F3 跳到上一个书签(previous bookmark): cmd + ↑ 跳到下一个书签(previous bookmark): cmd + ↓ 向下选中： shift + ↓ 向上选中： shift + 上 切换大小写(toggle case): shift + cmd + U 编辑窗口拆分： 左上角 -> Window -> Editor Tabs -> Split Horizontally Shift+F10：运行runningCtrl+Alt+R：弹出RakeCtrl+Alt+G：弹出GenerateCtrl+Alt+L：格式化代码Alt+F1：切换视图(Project, Structure, etc.).Alt+F2：弹出预览窗口，可选择浏览器打开网页Alt+Insert：相当于File|New，不过要在class外执行Alt+Enter：快速修复提示，相当于Eclipse的Alt+F1Alt+Home：显示文件夹导航条Ctrl+J：插入动态模板代码，非常方便。Ctrl+Alt+J：用动态模板包围选中代码Ctrl+/，Ctrl+Shift+/：注释，去注释代码Ctrl+Space：代码自动补全，相当于Eclipse的Alt+/。建议修改为Alt+/Ctrl+Q：显示文档DocCtrl+W：动态选择，多次按依次选择 单词-行-段-全Ctrl+D：复制一行Ctrl+Y：删除一行Shift+Alt+N：在Controller,Model,View间跳转Shift+Alt+F10：运行，Dubug 二级进阶 Alt+Home：显示导航条Alt+F1：在不同视图中切换 (Project, Structure, etc.).Ctrl+Tab：在tool窗口和打开的文件窗口中切换Ctrl+F：在当前文件中查找Ctrl+Shift+F：在文件夹中查找Ctrl+Shift+F7：快速显示选中代码的调用Ctrl+Shift+.：在*.html.erb文件中插入Ctrl+N，Ctrl+Shift+N，Ctrl+Shift+Alt+N：通过名字查找类，文件，符号Ctrl+Shift+T：To surround a block of codeCtrl+Alt+D：显示Model关系图，即ER图。View | Show Model Dependency Diagram 三级耍酷 a.界面调整Esc：从任何界面返回到编辑器Shift+Esc：回到编辑器，隐藏所有工具栏Shift+F6：重命名，文件，方法名，类名，变量名等F12：相当于Shift+Esc的回退键，显示最后一次打开的工具栏 b.变量选择Ctrl+Shfit+F7：高亮显示本文件中变量出现的位置F3，Shift+F3：在不同变量之间跳转Esc：取消选择Alt+Left, Alt+Right: 在不同的Tabs中切换Ctrl+点击Tab：弹出路径框，选择后会在新窗口打开。Ctrl+E：弹出最近打开的文件选择框Ctrl+Shift+Up, Ctrl+Shift+Down：把代码住上移和住下移Ctrl+Shift+Backspace：光标移动到上次修改的位置Ctrl++，Ctrl+-：展开或收缩代码Ctrl+Shift++，Ctrl+Shift+-：全部展开或收缩代码Ctrl+~：切换主题，配色等(一般默认会被输入法占用) 更改快捷键 示例：把代码提示快捷键由Alt+Space改为Ctrl+Alt+/ 打开File>>Setting>>Keymap 找到Main menu>>Code>>Complete Code>>Basic，选择右边的“Add Keyboard Shortcut” 在弹出的框里光标放到输入框，同时按下：Ctrl+Alt+/ 成功后应用保存，即可生效. 转载自：http://blog.csdn.net/iam_song/article/details/7863636 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/015-rubymine习惯设置.html":{"url":"doc/ruby/015-rubymine习惯设置.html","title":"rubymine习惯设置","keywords":"","body":" 1. 其他的习惯设置 3. rubymine2016 汉化 4. rubymine 编辑器代码自动缩进设置 5. rubymine 颜色设置 整体风格颜色(主题颜色) 正则表达式颜色 字符串转义 颜色设置 1. 输入行的背景色 2. 代码编辑区背景色 3. 行号字的颜色设置 行号背景色设置 4. 鼠标选择区域前景色(字体颜色) 5. 鼠标选择的背景色 6. 字符串的颜色设置 7. HTML代码 × 8. span企业信息管理dsdsddddd/div 9. 局部变量颜色设置 10. 数字颜色设置 11. 行注释，块注释 颜色修改 12. git 新增行，修改行，删除行 颜色标记修改 13. git diff 弹窗 真实背景色 14. 编辑器 分隔线颜色设置 15. 垂直缩进线颜色设置 *16. 括号匹配颜色 * 17. 鼠标光标颜色 *18. 折叠文本颜色 * 19. 注入语言片段背景色修改 20. 光标定位变量一样的 颜色 21 export class EnterpriseListShowComponent implements OnInit { 22. 实例成员方法名颜色设置： 23. 方法参数颜色设置 Parameter 24.实例变量颜色，接口颜色 25. 搜索结果的颜色背景色设置： 6. 当回车后，按删除键后又回到了上一行，禁止 7. Editor Tabs 编辑器标签页设置，显示正在编辑文件的路径 8.工具栏显示与隐藏 9.关闭rubymine代码自动保存功能 12. 代码折叠设置 14. 编辑器代码自动换行 21. 代码从新格式化格式设置 22. 关闭TypeScript 自动编译 23. 显示/隐藏 编辑器中空格上的白点 24. 显示/隐藏 编辑器 代码块垂直线 25. 显示/隐藏 编辑器 行号 2. 显示/隐藏 编辑器 右边距 编辑器标签的设置，由单行显示变多行(打开的文件名)： 编辑过的文件名标记星号，知道修改了什么文件 目录 [TOC] 1. 其他的习惯设置 RubyMine2016.3自动补全默认第一个选项配置:http://blog.csdn.net/lj_550566181/article/details/53504208 rubymine2016官方文档英文：https://www.jetbrains.com/help/ruby/2016.3/reference.html 3. rubymine2016 汉化 参考链接： http://www.jb51.net/softs/516343.html rubymine2016安装教程下载链接： https://pan.baidu.com/s/1c2ou9w8 密码: kqjhRubyMine 2016汉化包使用方法：解压后，里面有个文件resources_cn.jar,把这个文件复制到/Applications/RubyMine.app/Contents/lib中 如果没有resources_cn.jar,怎按照下面的步骤来制作resources_cn.jar：1、链接: https://pan.baidu.com/s/1pLlWpSn 密码: yptn 下载汉化包2、将/Applications/RubyMine.app/Contents/lib目录下的resources_en.jar文件复制出来，并更名resources_cn.jar3、双击打开resources_cn.jar(注意是打开而不是解压出来)，将下载的汉化包zh_CN目录下的所有文件拖到刚才打开的resources_cn.jar文件内的messages目录中，并保存。4、将resources_cn.jar文件复制回/Applications/RubyMine.app/Contents/lib 4. rubymine 编辑器代码自动缩进设置 preferences(cmd + ,) -> Editor -> Code Style:Indents Dection -> detect and use existing file indents for sditing(检测并使用现有的文件缩进进行编辑) 对号去掉 EditorConfig -> Enable EditorConfig support 对号去掉 根据代码语言进行缩进设置： (TypeScript) Editor -> Code Style -> TypeScript -> Tabs and Indents 5. rubymine 颜色设置 整体风格颜色(主题颜色) preferences(cmd + ,) -> Editor -> Color Scheme -> Scheme： 选择一款喜欢的主题其中 default 主题是窗口是白色的，其他的有黑色的 正则表达式颜色 preferences(cmd + ,) -> Editor -> Color Scheme -> TypeScript -> Regular expression -> foreground 字符串转义 颜色设置 preferences(cmd + ,) -> Editor -> Color Scheme -> TypeScript -> valid string escape -> foreground 1. 输入行的背景色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Caret row 2. 代码编辑区背景色 preferences(cmd + ,) -> Editor -> Colors Scheme -> General -> Text -> Default test -> background 3. 行号字的颜色设置 preferences(cmd + ,) -> Editor -> Colors Scheme -> General -> Code -> Line number 行号背景色设置 preferences(cmd + ,) -> Editor -> Colors Scheme -> General -> Editor -> Gutter background 4. 鼠标选择区域前景色(字体颜色) preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Selection background 5. 鼠标选择的背景色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Selection foreground 6. 字符串的颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> String -> String text -> Foreground这是通用的设置，如果想某种语言字符串颜色特定 以ruby语言为例：preferences(cmd + ,) -> Editor -> Colors & Fonts -> Ruby -> String -> Foreground如果勾选了 Use inherited attributes则会使用上面的设置，在这里也告诉了此处默认的设置位置String -> String text of Language Defaults 7. HTML代码 &times; class= 颜色背景色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Markup -> Attribute ->Foreground 字体颜色， Background 背景色 &times; 颜色背景色设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Markup -> Entity ->Foreground 字体颜色， Background 背景色 颜色背景色设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Markup -> Tag ->Foreground 颜色， Background 背景色 8. 企业信息管理dsdsddddd div span 字体的颜色设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Keyword -> Foreground 没有被任何符号包含(企业信息管理ds)的字体颜色 设置preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Default text -> Foreground 9. 局部变量颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Identifiers -> Local variable -> Foreground其他语言个性化设置(JavaScript)： Editor -> Colors & Fonts -> JavaScript -> Local variable -> Foreground 10. 数字颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Number -> Foreground 11. 行注释，块注释 颜色修改 preferences(cmd + ,) -> Editor -> Colors & Fonts -> Language Defaults -> Comments -> Line comment -> Foreground 12. git 新增行，修改行，删除行 颜色标记修改 2016版的： git 新增行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Gutter -> Added lines -> Background git 删除行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Gutter -> Deleted lines -> Background git 修改行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Gutter -> modified lines -> Background 2017版的： git 新增行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors Scheme -> VCS -> Editor Gutter -> Added lines -> Background git 删除行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors Scheme -> VCS -> Editor Gutter -> Deleted lines -> Background git 修改行标记颜色修改：preferences(cmd + ,) -> Editor -> Colors Scheme -> VCS -> Editor Gutter -> modified lines -> Background 13. git diff 弹窗 真实背景色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Background in readonly file - Background 14. 编辑器 分隔线颜色设置 分隔线颜色设置：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Tear line -> Foreground 选择分隔线颜色设置：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Tear line selection -> Foreground 右边线颜色设置：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Right margin 15. 垂直缩进线颜色设置 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Vertical indent guide -> Background 16. 括号匹配颜色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Matched brace -> Background 17. 鼠标光标颜色 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Editor -> Caret 18. 折叠文本颜色 折叠文本三个点颜色： preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Fold text -> Foreground 折叠文本背景色：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Text -> Fold text -> Background 19. 注入语言片段背景色修改 preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Injected language fragment -> Background 20. 光标定位变量一样的 颜色 光标在变量定义处：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Identifier under caret(write) -> Background 变量一样其他变量的背景色：preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Code -> Identifier under caret -> Background 21 export class EnterpriseListShowComponent implements OnInit { export class keyword 关键字颜色设置 (JavaScript) Editor -> Colors & Fonts -> JavaScript -> Keyword -> Foreground如果勾选了： Use inherited attributes ,则： Language Defaults -> Keyword 类名字颜色设置(JavaScript) Editor -> Colors & Fonts -> JavaScript -> Class -> Foreground如果勾选了： Use inherited attributes : Language Defaults -> Classes -> Class name 22. 实例成员方法名颜色设置： (JavaScript) Editor -> Colors & Fonts -> JavaScript -> Instance member function -> Foreground如果勾选了： Use inherited attributes,则： Language Defaults -> Classes -> Instance method 23. 方法参数颜色设置 Parameter 方法参数颜色设置：(JavaScript) Editor -> Colors & Fonts -> JavaScript -> Parameter:Foreground, 字体颜色Background, 背景色如果勾选了： Use inherited attributes，则: Language Defaults -> Indentifiers -> Parameter 24.实例变量颜色，接口颜色 类实例变量颜色设置：(TypeScript)Editor -> Colors & Fonts -> TypeScript -> Instance member variable -> Foreground如果勾选了： Use inherited attributes，则: JavaScript -> Instance member variable(通用) Editor -> Colors & Fonts -> Language Defaults -> Classes ->Instance field -> Foreground 接口颜色设置：(TypeScript)Editor -> Colors & Fonts -> TypeScript -> Interface -> Foreground如果勾选了： Use inherited attributes，则: Language Defaults -> Classes -> Interface name 25. 搜索结果的颜色背景色设置： preferences(cmd + ,) -> Editor -> Colors & Fonts -> General -> Search Results -> Text search result搜索结果字体颜色： Foreground ，搜索结果背景色： Background 6. 当回车后，按删除键后又回到了上一行，禁止 Smart Keys，这个选择一下：preferences(cmd + ,) -> Editor -> General -> Smart Keys -> Backspace -> Unident: To nearest indent positionCode Style,这里设置一下：Editor -> Code Style:EditorConfig -> Enable EditorConfig support把这里的对号去掉根据编程语言进行相应设置：Editor -> Code Style -> TypeScript -> Tabs and Indents 7. Editor Tabs 编辑器标签页设置，显示正在编辑文件的路径 https://www.jetbrains.com/help/ruby/2016.3/editor-tabs.html?search=editor%20tabs 显示编辑文件的路径：rubymine左上角 -> View -> navigation Bar , 前面打上对号。 8.工具栏显示与隐藏 rubymine左上角 -> View -> Toolbar , 前面打上对号。 9.关闭rubymine代码自动保存功能 https://www.jetbrains.com/help/ruby/2016.3/saving-and-reverting-changes.html在编辑TypeScript代码的时候，由于自动保存导致每写一点代码，服务都会从新编译运行，因此需要关闭自动保存：preferences(cmd + ,) -> Appearance & Behavior -> System Settings -> Synchrogazation(同步):save file on frame deactivation(鼠标光标停止的时候保存文件，好像这么理解), 把这个前面的对号去掉，就可以在编辑时不会自动保存了。Synchronize file on frame or editor tab activation, 这个是否去掉暂时不知道， 12. 代码折叠设置 https://www.jetbrains.com/help/ruby/2016.1/code-folding.html#using_folding_comments preferences(cmd + ,) -> Editor -> General -> Code Folding： -> Show code folding outline: 这个打上对号，就会显示代码折叠的提示线。-> Collapse by default: 这下面是默认折叠的代码块的选项，哪个不想默认折叠把前面的对号去掉就可以了。 14. 编辑器代码自动换行 当代码一行太多的时候，如果不选择软换行，那么就会把编辑区右移，会很费劲，这时可选择软换行，在下一行接着显示这行的内容。preferences(cmd + ,) -> Editor -> General：Soft Wraps -> Use soft wraps in editor , 前面打上对号，就会自动软换行。 21. 代码从新格式化格式设置 冒号后有一个空格，从新格式化设置：preferences(cmd + ,) -> Editor -> Code Style -> TypeScript -> Spaces -> After type reference colon':'打上对号 22. 关闭TypeScript 自动编译 preferences(cmd + ,) -> Languages & Frameworks -> TypeScript:Compiler: Enable TypeScript Compiler 去掉前面的对号，就不会自动编译了。 23. 显示/隐藏 编辑器中空格上的白点 preferences(cmd + ,) -> Editor -> General -> Appearance -> show whitespaces ,点击选中或取消。 24. 显示/隐藏 编辑器 代码块垂直线 preferences(cmd + ,) -> Editor -> General -> Appearance -> Vertical indent guide ,点击选中或取消。 25. 显示/隐藏 编辑器 行号 preferences(cmd + ,) -> Editor -> General -> Appearance -> show line numbers 2. 显示/隐藏 编辑器 右边距 preferences(cmd + ,) -> Editor -> General -> Appearance -> show right margin 编辑器标签的设置，由单行显示变多行(打开的文件名)： preferences(cmd + ,) -> Editor -> General -> Editor Tabs:Tab Appearance -> Show tabs in single row(在单行显示标签), 对号去掉。Tab Closing Policy(选项卡关闭策略) -> Tab limit(选项卡限制) , 里面的数字改大一点 编辑过的文件名标记星号，知道修改了什么文件 preferences(cmd + ,) -> Editor -> General -> Editor Tabs:Tab Appearance -> Mark modified tabs with asterisk (标记修改过的标签为星号)，打上对号。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/ruby/016-haml语法符号的含义.html":{"url":"doc/ruby/016-haml语法符号的含义.html","title":"haml语法符号的含义","keywords":"","body":" haml官网 Haml 参考大全 简明教程 入门 haml中一些符号的作用 %百分号符号是一行的开始，紧接着一个元素的名字，然后后面跟一个可选的修饰语（见下例），比如一个空格，或一行文本等，就会被渲染到这个元素里成为其内容。它会创建一个这样的形式：. {}括号内的Ruby hash是用来指名一个元素的属性。它作为一个ruby hash的字面量，局部变量也可以在其中使用。Hash放在被定义好的标签之后，基本上就和Ruby语法一样，看例子： []方括号跟在一个标签定义之后，包含一个Ruby 对象，被用来为这个标签设置class和id属性。这个class的值被设置为这个对象的类名（两个单词用下划线形式表示，而不是驼峰表示方法）并且id的值被设置为对象的类名加上这个对象的id，也是下划线连接。因为一个对象的id通常是朦胧的实现细节，这是表现model的实例最有用的元素了（这句是不是翻译的太差？）。 /这个斜线字符，放在一个tag定义之后，可以让这个标签自我关闭。 . and #这两个符号是从CSS里借鉴来的。他们被用来表示一个元素的class和id属性 Implicit Div Elements（隐藏DIV）因为Div这个标签经常被用，所以你仅用.and#这两个符号来定义class和id的时候，一个div元素就会被自动的使用。 =等号符号用来插入ruby 代码的值到模板中。 !!!当用haml来表示一个XHTML文档，你可以通过!!!这个符号来自动生成文档类型和XML prolog。 /如果这个斜线写在打头的位置，则会注释这行。放在代码的上方，则注释整个代码： \\反斜杠符号允许字符串前面的第一个符号作为纯文本使用。 |管道符可以允许把输出为一行的内容写成多行。 :冒号是指定一个过滤器。冒号后面是你要使用的那个过滤器的名字。 横杠符号，很有性格，可以使文本变为”silent script”：意思是，代码可以执行，但并不输出任何东西。 BlocksRuby中的块，也不需要明显的去关闭，haml会让它自动关闭。这写都是基于缩进的。千万记住要缩进两个空格。 %百分号符号是一行的开始，紧接着一个元素的名字，然后后面跟一个可选的修饰语（见下例），比如一个空格，或一行文本等，就会被渲染到这个元素里成为其内容。它会创建一个这样的形式：. 式：.。举个例子： %one %two %three Hey there 会被编译为： Hey there 对于任何一个有效的标准元素字符，Haml都会自动的为其生成闭合标签。 {}括号内的Ruby hash是用来指名一个元素的属性。它作为一个ruby hash的字面量，局部变量也可以在其中使用。Hash放在被定义好的标签之后，基本上就和Ruby语法一样，看例子： %head{ :name => \"doc_head\" } %script{ 'type' => \"text/\" + \"javascript\", :src => \"javascripts/script_#{2 + 7}\" } 编译后为： []方括号跟在一个标签定义之后，包含一个Ruby 对象，被用来为这个标签设置class和id属性。这个class的值被设置为这个对象的类名（两个单词用下划线形式表示，而不是驼峰表示方法）并且id的值被设置为对象的类名加上这个对象的id，也是下划线连接。因为一个对象的id通常是朦胧的实现细节，这是表现model的实例最有用的元素了（这句是不是翻译的太差？）。看例子： # file: app/controllers/users_controller.rb def show @user = CrazyUser.find(15) end # file: app/views/users/show.haml %div[@user] %bar[290]/ Hello! 转换为： Hello! 这是基于RailsConf Europe 2006 大会上DHH提出的SimpleHelpful语法 /这个斜线字符，放在一个tag定义之后，可以让这个标签自我关闭。例子： %br/ %meta{'http-equiv' => 'Content-Type', :content => 'text/html'}/ 转换为： 有一些标签（meta, img, link, script, br, and hr tags等）当没有内容的时候会自动关闭。看例子： %br %meta{'http-equiv' => 'Content-Type', :content => 'text/html'} 转换为： . and #这两个符号是从CSS里借鉴来的。他们被用来表示一个元素的class和id属性,看例子： %div#things %span#rice Chicken Fried %p.beans{ :food => 'true' } The magical fruit %h1.class.otherclass#id La La La 转换为： Chicken Fried The magical fruit La La La 注意h1标签。两个点连用，第一个表示class属性，第二个则是用来链接那两个字符的空格。 Implicit Div Elements（隐藏DIV）因为Div这个标签经常被用，所以你仅用.and#这两个符号来定义class和id的时候，一个div元素就会被自动的使用。例如： #collection .item .description What a cool item! 和下面的这个相似： %div{:id => collection} %div{:class => 'item'} %div{:class => 'description'} What a cool item! 都会被转换为： What a cool item! =等号符号用来插入ruby 代码的值到模板中。 %p = ['hi', 'there', 'reader!'].join \" \" = \"yo\" 编译为: hi there reader! yo 你也能使用双等号来更容易的嵌入ruby代码。比如： %p == 1 + 1 = #{1 + 1} 编译为： 1 + 1 = 2 !!!当用haml来表示一个XHTML文档，你可以通过!!!这个符号来自动生成文档类型和XML prolog。比如：``` !!! XML !!! %html %head %title Myspace %body %h1 I am the international space station %p Sign my guestbook 转换为： \">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> Myspace I am the international space station Sign my guestbook 你也可以在！！！后面加版本号。比如： !!! 1.1 转换为： \">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\"> and !!! Strict \">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"> 如果你不想用UTF-8的编码，你也可以指定你想要的编码： !!! XML iso-8859-1 转换为： * **/** 如果这个斜线写在打头的位置，则会注释这行。 放在代码的上方，则注释整个代码： %billabong / This is the billabong element I like billabongs! 转换为： I like billabongs! / %p This doesn't render... %div %h1 Because it's commented out! 转换为： This doesn't render... Because it's commented out! --> * **\\** 反斜杠符号允许字符串前面的第一个符号作为纯文本使用。 %title = @title - MySite 转换为： MyPage - MySite * **|** 管道符可以允许把输出为一行的内容写成多行。 %whoo %hoo I think this might get | pretty long so I should | probably make it | multiline so it doesn't | look awful. | %p This is short. is compiled to: 转换为： I think this might get pretty long so I should probably make it multiline so it doesn't look awful. * **:** 冒号是指定一个过滤器。冒号后面是你要使用的那个过滤器的名字。For example, %p :markdown Textile ======= Hello, *World* 转换为： Textile Hello, World Haml支持的过滤器定义 plain ruby preserve erb sass redcloth textile markdown * **-** 横杠符号，很有性格，可以使文本变为”silent script”：意思是，代码可以执行，但并不输出任何东西。 * **Blocks** Ruby中的块，也不需要明显的去关闭，haml会让它自动关闭。这写都是基于缩进的。千万记住要缩进两个空格。 (42...47).each do |i| %p= i %p See, I can count! 编译为: 42 43 44 45 46 ``` 上面的语法出自： http://blackanger.blog.51cto.com/140924/47642/ haml官网 http://haml.info/ Haml 参考大全 http://blackanger.blog.51cto.com/140924/47642/ 简明教程 http://www.codeweblog.com/%E7%BF%BB%E8%AF%91-haml%E5%AE%98%E7%BD%91%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/ 入门 http://www.2cto.com/kf/201601/485095.html powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/001-manageIQ开发环境安装centos.html":{"url":"doc/manageiq/001-manageIQ开发环境安装centos.html","title":"manageIQ开发环境安装centos","keywords":"","body":" return home 以下所有操作都不能在root用户操作，要用你登陆电脑的用户来操作 ## manqgeiq官方的安装文档 # manageiq自定义安装 # 概述review ## 操作系统安装 ## git安装 ## manageiq依赖安装 ## rvm,ruby,gems,rails,pqadmin3,rubymine,isntall ## clone ManageIQ 代码 ## Installs dependencies, config, prepares database, etc ## Starts the ManageIQ EVM Application in the background ## 开发环境最小配置运行 ## return home 以下所有操作都不能在root用户操作，要用你登陆电脑的用户来操作 manqgeiq官方的安装文档 链接：http://manageiq.org/docs/guides/developer_setup.html你可以看这个官方的安装文档，这里面依赖环境安装是使用dnf管理其来安装的，我个人安装的时候会有点问题，你可以先尝试安装，如果有问题不能解决，那么可以看下面的安装教程。如果按照官方文档安装了，则下面的可以忽略了。 manageiq自定义安装 概述review 这个是文档是从一个空白电脑开始安装，如果你哪一步已经存在，请略过 操作系统安装 manageiq要求是 centos的 linux，所以请安装centos版linux，不会请找运维的同事或者网管安装。 推荐centos7 git安装 一般git linux系统自带，可在终端运行如下命令查看系统是否安装了git： $ git --version 如果出来版本号则说明已经安装了，如果没有安装请看如下教程安装： git安装,配置 这里面描写了git的安装、git命令的别名、以及拉取代码时自动验证用户名密码设置。 manageiq依赖安装 官方文档使用的是dnf包管理器来安装的，但是我安装时发现有的包使用dnf找不到，只好全部用yum来安装了。 Install packagessudo yum -y install memcached sudo yum -y install bzip2 libffi-devel readline-devel sudo yum -y install libxml2-devel libxslt-devel patch sudo yum -y install sqlite-devel sudo yum -y install nodejs sudo yum -y install gcc-c++ sudo yum -y install libcurl-devel rpm -q --whatprovides npm || sudo yum -y install npm sudo yum -y install openssl-devel sudo yum -y install cmake Install the Bower package managersudo npm install -g bower Enable Memcachedsudo systemctl enable memcached sudo systemctl start memcached PostgreSQL version is 9.4+ 的安装 postgres数据库官方推荐使用9.4+的版本，如果系统没有安装那么直接安装这个版本以上的，如果有旧的版本则先卸载在安装新的。 manageiq官方postgres9.4+的安装文档：http://manageiq.org/docs/guides/developer_setup/postgresql_software_collection # 您需要做的第一件事是启用SoftwareCollections.org包存储库。如果你使用CentOS，那么命令如下： $ sudo yum -y install centos-release-scl # 查看postgres是否已经安装了了低版本的，如果已经安装了高版本的，或者没安装在不需卸载，直接安装 $ psql --version $ sudo systemctl stop postgresql-server # 停止psotgres服务 $ sudo systemctl disable postgresql-server # 关掉postgres $ sudo yum -y remove 'postgresql-*' # 卸载postgres 卸载ruby 链接postgres 的gem包 pg，如果没有安装则略过： $ gem uninstall pg Install the PostgreSQL 9.4 collection $ sudo yum -y install \\ rh-postgresql94-postgresql-server \\ rh-postgresql94-postgresql-devel This will install the required files under /opt/rh/rh-postgresql94, so each time you need to use a command like pgsql you will have to use the complete path. Alternatively, you can enable that collection: $ scl enable rh-postgresql94 bash $ source /opt/rh/rh-postgresql94/enable 注意！！！下面这步会把～/.bash_profile 文件里面所有内容清空，使用前请备份注意： # 这条命令可以不用执行，后期经实测不影响manageIQ的使用 $ cat > $HOME/.bash_profile 在$HOME/.bash_profile文件加了这句话后，如果你重新登陆，会导致当前用户图形界面登陆不上。 两种解决方法： 1. 把这句注销调，后期经实测，没有这条语句对于rails开发没有影响，数据库能打开就好。 2. 打开/opt/rh/rh-postgresql94/enable，把如下三条语句注释掉： export XDG_CONFIG_DIRS=\"/etc/opt/rh/rh-postgresql94/xdg:${XDG_CONFIG_DIRS:-/etc/xdg}\" export XDG_DATA_DIRS=\"/opt/rh/rh-postgresql94/root/usr/share${XDG_DATA_DIRS:+:${XDG_DATA_DIRS}}\" export PKG_CONFIG_PATH=\"/opt/rh/rh-postgresql94/root/usr/lib64/pkgconfig${PKG_CONFIG_PATH:+:${PKG_CONFIG_PATH}}\" Create and configure the database By default the database directory used by the software collection is /var/opt/rh/rh-postgresql94/lib/pgsql/data, but the ManageIQ instructions assume it to be /var/lib/pgsql/data. The name of the service is also different. Make sure to take these differences into account when creating and configure the database. For example, to initially create the database you will need to do the following: $ su - root $ scl enable rh-postgresql94 bash $ postgresql-setup initdb To setup authentication you will need to modify the pg_hba.conf file, as described in the instructions, but taking into account the different location: $ PGDATA=/var/opt/rh/rh-postgresql94/lib/pgsql/data $ sudo grep -q '^local\\s' $PGDATA/pg_hba.conf || echo \"local all all trust\" | sudo tee -a $PGDATA/pg_hba.conf $ sudo sed -i.bak 's/\\(^local\\s*\\w*\\s*\\w*\\s*\\)\\(peer$\\)/\\1trust/' $PGDATA/pg_hba.conf To enable and start the server: $ sudo systemctl enable rh-postgresql94-postgresql $ sudo systemctl start rh-postgresql94-postgresql 修改数据库配置文件，允许连接 $ sudo vi /var/opt/rh/rh-postgresql94/lib/pgsql/data/pg_hba.conf 找到下面的内容：# IPv4 local connections: host all all 127.0.0.1/32 ident # IPv6 local connections: host all all ::1/128 ident 把ident修改为 trust 并在下面添加一行： host all all 192.168.0.0/24 trust 保存后重起数据库： $ sudo systemctl restart rh-postgresql94-postgresql 查看数据库的运行：$ lsof -i:5432 And, finally, to create the database user: $ su - postgres -bash-4.2$ scl enable rh-postgresql94 bash bash-4.2$ psql -c \"CREATE ROLE root SUPERUSER LOGIN PASSWORD 'smartvm'\" rvm,ruby,gems,rails,pqadmin3,rubymine,isntall 这里是rails开发的必要插件，具体安装看如下链接： centos7,rvm,ruby,gems,rails,pqadmin3,rubymine,isntall clone ManageIQ 代码 git clone https://github.com/ManageIQ/manageiq Installs dependencies, config, prepares database, etc $ bin/setup Starts the ManageIQ EVM Application in the background 下面的命令是开始启动服务，这个是正常的启动。 # 启动manageIQ服务，网站 $ rails server # 这个是后台处理程序，读取虚拟机信息，读取镜像信息等，如果只是网站则不需要运行这个 $ bundle exec rake evm:start 开发环境最小配置运行 $ MIQ_SPARTAN=minimal rake evm:start $ rails server powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/002-manageIQ开发环境安装Mac.html":{"url":"doc/manageiq/002-manageIQ开发环境安装Mac.html","title":"manageIQ开发环境安装Mac","keywords":"","body":" return home return home manageIQ官方安装文档http://manageiq.org/docs/guides/developer_setupMac 安装在中间 Install Homebrew下面的安装都要brew，如果没有brew需要第一个安装 # https://brew.sh/ $ /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Install Packages brew install git brew install memcached brew install postgresql brew install cmake brew install node Install the Bower package manager npm install -g bower Configure and start PostgreSQL Required PostgreSQL version is 9.4+ # Enable PostgreSQL on boot mkdir -p ~/Library/LaunchAgents ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist # Create the ManageIQ superuser psql -d postgres -c \"CREATE ROLE root SUPERUSER LOGIN PASSWORD 'smartvm'\" Start memcached # Enable Memcached on boot ln -sfv /usr/local/opt/memcached/homebrew.mxcl.memcached.plist ~/Library/LaunchAgents launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。 它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。 Memcached基于一个存储键/值对的hashmap。其守护进程（daemon ）是用C写的， 但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信。 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/003-manageIQ代码结构、框架、执行流程分析.html":{"url":"doc/manageiq/003-manageIQ代码结构、框架、执行流程分析.html","title":"manageIQ代码结构、框架、执行流程分析","keywords":"","body":" 概述（overview） manageiq代码的目录结构 ## rais 程序架构、执行流程 ## manageiq代码执行过程展示 ## 看过上面的介绍后，如果想要了解manageiq的代码可根据如下方法来查找： manageiq登陆过程分析 providers 部分代码启动流程 rails是如何加载的 ## 概述（overview） 由于manageiq是使用rails编写的，所以manageiq的源代码目录结构是标准的rails的目录结构，rails开发语言是ruby，框架是mvc模式的。 manageiq代码的目录结构 首先了解一下标准的rails目录结构，如下图： ManageIQ的代码目录结构:ManageIQ is a Rails application with the following standard layout: 详细介绍请看manageiq的官方文档介绍：http://manageiq.org/docs/guides/architecture/source_code_layout rais 程序架构、执行流程 Rails 采用了“模型-视图-控制器”（简称 MVC）架构模式。这种模式把应用中的数据（例如用户信息）与显示数据的代码分开，这是图形用户界面（Graphical User Interface，简称 GUI）常用的架构方式。 MVC 架构图解：与 Rails 应用交互时，浏览器发出一个请求（request），Web 服务器收到请求之后将其传给 Rails 应用的控制器，决定下一步做什么。某些情况下，控制器会立即渲染视图（view），生成 HTML，然后发送给浏览器。在动态网站中，更常见的是控制器与模型（model）交互。模型是一个 Ruby 对象，表示网站中的一个元素（例如一个用户），并且负责与数据库通信。与模型交互后，控制器再渲染视图，把生成的 HTML 返回给浏览器。 程序执行流程： 图中各步的说明如下： 浏览器向 /users 发送请求； Rails 的路由把 /users 交给 Users 控制器的 index 动作处理； index 动作要求 User 模型读取所有用户（User.all）； User 模型从数据库中读取所有用户； User 模型把所有用户组成的列表返回给控制器； 控制器把所有用户赋值给 @users 变量，然后传入 index 视图； 视图使用嵌入式 Ruby 把页面渲染成 HTML； 控制器把 HTML 送回浏览器。 关于rails的资料请看如下链接：Ruby on Rails 教程Ruby on Rails 指南 manageiq代码执行过程展示 看过上面的介绍后，如果想要了解manageiq的代码可根据如下方法来查找： 浏览器发送一个链接请求， 去config/routes.rb里面， 根据链接来确定这个请求由哪个controller的action来处理， 这里找到了controller。 cotroller调用model来处理请求，然后调用view来对结果进行渲染， 这里找到了model与view。 浏览器接收结果，对结果进行展示， 一次请求结束。 、 根据上面的执行流程，如果想知道manageiq某一个网页的代码，以及修改某一部分，就可以按照上面的过程来查找。 manageiq登陆过程分析 启动服务 在此之前需要先安装好环境，并下载代码，进入代码目录并执行下面命令： rails server 浏览器输入地址：http://localhost:3000 此时浏览器已经向rails服务发送了请求，请求的是默认地址。 去路由中需要默认地址负责处理的controller 路由文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/config/routes.rb 在里面找到默认路由设置代码https://github.com/ManageIQ/manageiq/blob/darga-4/config/routes.rb#L2623 root :to => 'dashboard#login' 从这段代码可以看到处理默认访问的controller是 dashboard里面的login方法，去 controller里面找到dashboard控制器。 controllers/dashboard_controller.rb对请求进行处理 controller文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/dashboard_controller.rb在里面找到login方法：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/dashboard_controller.rb#L347这个方法执行完毕后，如果在方法里面没有指定执行的view，那么则默认去view里面找到同名的文件夹，在里面找到跟这个方法名同名的文件。 views/dashboard/login.html.haml对网页进行渲染 view文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/dashboard/login.html.haml在里面找到登陆按钮的位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/dashboard/login.html.haml#L91 如下图所示： 当在浏览器中输入用户名、密码后点击 login 按钮后，如上图 1、2、3 过程所示，会从新回到 controller里面去验证用户名密码。 controllers/dashboard_controller.rb 的authenticate方法对密码进行验证 代码位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/dashboard_controller.rb#L433 如果验证成功，则会指向一个新的url地址，代码如下：page.redirect_to(validation.url) 登陆过程结束，此时进入到了网站页面。 providers 部分代码启动流程 服务启动后，选择 Compute -> Clouds -> Providers, 此时网页链接： http://localhost:3000/ems_cloud/show_list ，然后在齿轮图标那里选择 Add a New Cloud Provider，这里就是添加aliyun代码的部分了，此时网页链接：http://localhost:3000/ems_cloud/new 根据链接http://localhost:3000/ems_cloud/new去路由中寻找处理此请求的controllers 路由位置：https://github.com/ManageIQ/manageiq/blob/darga-4/config/routes.rb#L906 ，在里面没有找到new，但是控制代码里面有new方法。 controllers/ems_cloud_controller.rb对请求进行处理 controller文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/ems_cloud_controller.rb在这个文件里面没有new方法，但是在include 里面找到了new：https://github.com/ManageIQ/manageiq/blob/darga-4/app/controllers/ems_common.rb#L131在这个方法里面设置了有哪些providers，并把结果传给view。 views/ems_cloud/new.html.haml对网页进行渲染 view文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/ems_cloud/new.html.haml这里面在基本渲染后，又调用的局部渲染： = render :partial => \"shared/views/ems_common/angular/form\" 文件位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/shared/views/ems_common/angular/_form.html.haml这里面是选择providers的位置：https://github.com/ManageIQ/manageiq/blob/darga-4/app/views/shared/views/ems_common/angular/_form.html.haml#L27 view处理结束后把结果返回给网页，这次请求将结束。 rails是如何加载的 http://blog.csdn.net/cloudcraft/article/details/7654118https://ruby-china.org/topics/23588http://www.oschina.net/question/136896_166772?sort=time powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/004-manageIQ汉化.html":{"url":"doc/manageiq/004-manageIQ汉化.html","title":"manageIQ汉化","keywords":"","body":" dashboard 页面标题的汉化 代码版本https://github.com/ManageIQ/manageiq/tree/euwe-1 I18自动转化成网页当前语言的包rails I18n 资料： http://guides.ruby-china.org/i18n.htmlhttps://github.com/svenfuchs/rails-i18nhttps://rubygems.org/gems/rails-i18nGemfile 里面：gem \"rails-i18n\", \"~>5.x\".rb文件里引用：require 'rails_i18n' 汉化的文件 manageiq/locale/zh_CN/manageiq.pomanageiq/app/assets/javascripts/locale/zh_CN/app.js dashboard 页面标题的汉化 网址： http://localhost:3000/dashboard/show controller处理信息https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L88这里面对数据进行处理后，view调用默认的show页面对数据进行渲染。 app/views/dashboard/show.html.haml 网页渲染。 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/show.html.haml#L8 # 这一行显示数据接着处理，此时跳到另个文件里继续执行程序 = WidgetPresenter.new(self, controller, widget).render_partial app/presenters/widget_presenter.rb 对 render_partial 方法进行处理https://github.com/ManageIQ/manageiq/blob/euwe-1/app/presenters/widget_presenter.rb#L19 def render_partial @controller.render_to_string(:template => 'dashboard/_widget', :handler => [:haml], :layout => false, :locals => {:presenter => self}).html_safe end # :template => 'dashboard/_widget', :handler => [:haml], # 这里是调用app/views/dashboard/_widget.html.haml app/views/dashboard/_widget.html.haml # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget.html.haml#L8 = h(presenter.widget.title) # 这一行就是 dashboard里面的每个插件的标题，也就是需要汉化的标题 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget.html.haml#L35 = render :partial => 'widget_footer', :locals => {:widget => presenter.widget} # 这里是每个小插件下面的时间显示设置，指向文件位置： app/views/dashboard/_widget_footer.html.haml # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget_footer.html.haml#L10 = _('Never') # 这行会根据地区自动来转换翻译 # https://github.com/ManageIQ/manageiq/blob/euwe-1/locale/zh_CN/manageiq.po msgid \"Next\" msgstr \"下次更新\" # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget_footer.html.haml#L15 = format_timezone(next_run_on, session[:user_tz], \"widget_footer\") # 这里是把时间转换为中国区的， format_timezone 所在文件：lib/vmdb/global_methods.rb#L36 # https://github.com/ManageIQ/manageiq/blob/euwe-1/lib/vmdb/global_methods.rb#L36 def format_timezone(time, timezone = Time.zone.name, ftype = \"view\") new_time = I18n.l(new_time.to_date) + new_time.strftime(\" %H:%M:%S %Z\") # 这里就是时间格式转换的代码 # 这里进行了中国区的时间转换 展示板里面的插件数据库位置 数据库名： vmdb_development表名： miq_widgets字段： title \"Guest OS Information\" \"Hosts - Summary by Version\" \"Vendor and Guest OS Chart\" \"Virtual Infrastructure Platforms\" \"Top CPU Consumers (weekly)\" \"Top Memory Consumers (weekly)\" \"Top Storage Consumers\" \"EVM: Recently Discovered Hosts\" \"EVM: Recently Discovered VMs\" \"Tenant Quotas\" http://localhost:3000/dashboard/show 页面左上角 \"Default Dashboard\" 出处 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/_tabs.html.haml#L7 = h(tab[1]) # 这里列出了\"Default Dashboard\"字段 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/_content.html.haml#L122 = render :partial => 'layouts/tabs' # 这里是调用tab字段 # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/application.html.haml#L52 = render :partial => \"layouts/content\" # 这里是调用 content # views/layouts/_tabs.html.haml 中变量 @tabs 的定义处： # https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L96 def show @layout = \"dashboard\" @dashboard = true @display = \"dashboard\" @lastaction = \"show\" @tabs = [] # 这里把 \"Default Dashboard\" 汉化了,在这个方法后面用I18n来转化 汉化代码 1、 dashboard页面的标题汉化 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/dashboard/_widget.html.haml#L8 @@ -5,7 +5,13 @@ .card-pf .card-pf-heading %h2.card-pf-title.sortable-handle{:style => \"cursor:move\"} - = h(presenter.widget.title) + - if :\"zh-CN\" == I18n.locale + - begin + = I18n.t presenter.widget.title, raise: true + - rescue + = h(presenter.widget.title) + - else + = h(presenter.widget.title) .dropdown.dropdown-kebab-pf.pull-right https://github.com/ManageIQ/manageiq/blob/euwe-1/locale/zh_CN.yml#L7 + + \"Vendor and Guest OS Chart\": \"供应商和客户操作系统图\" + \"Guest OS Information\": \"客户操作系统信息\" + \"Hosts - Summary by Version\": \"主机 - 摘要 与 版本\" + \"Virtual Infrastructure Platforms\": \"虚拟基础设施平台\" + \"Top CPU Consumers (weekly)\": \"最高CPU使用者(每周)\" + \"Top Memory Consumers (weekly)\": \"最高内存使用者(每周)\" + \"Top Storage Consumers\": \"最高存储使用者\" + \"EVM: Recently Discovered Hosts\": \"引擎：最近发现的主机\" + \"EVM: Recently Discovered VMs\": \"引擎: 最近发现的虚拟机\" + \"Tenant Quotas\": \"租户配额\" + \"Default Dashboard\": \"默认展示板\" 2、dashboard页面 中左上角 \"Default Dashboard\" 的汉化https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L204 @@ -202,6 +202,16 @@ class DashboardController powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/005-manageIQ网页部分功能代码实现.html":{"url":"doc/manageiq/005-manageIQ网页部分功能代码实现.html","title":"manageIQ网页部分功能代码实现","keywords":"","body":" 代码版本 创建一个虚拟机实例(instance) 登录后网页效果显示的代码 代码版本 https://github.com/ManageIQ/manageiq/tree/euwe-1 创建一个虚拟机实例(instance) 1.网页链接： http://localhost:3000/vm_cloud/explorer2.当输入信息后，点击 “submit”后，controller部分处理代码位置： manageiq/app/controllers/application_controller/miq_request_methods.rb elsif params[:button] == \"submit\" # Update or create the request from the workflow with the new options prov_req_submit # line:208 else 登录后网页效果显示的代码 1.在每个网页显示效果是， Rails会指定一个默认的页面模板，这个模板位置：app/views/layouts/application.html.haml这个模板里定义了网页的风格与导航栏的定义。 在这个文件里：4~12行，18~48行是网页的 head部分(登录网页后右键查看元素)。13~14，50~53行， 是网页的body部分， powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/006-新建提供者.html":{"url":"doc/manageiq/006-新建提供者.html","title":"新建提供者","keywords":"","body":" 原版地址 ## 1. MIQ新增提供者方式 ## 2. 新增提供者目录 ## 原版地址 http://note.youdao.com/noteshare?id=9428c64abd08efc359f5b7eb9bda7e28 1. MIQ新增提供者方式 MIQ在D版新增的功能就是把所有的提供者所需要用到的类文件进行了按目录分割，这样的好处就是在以后增加一个新的提供者时，不需要对其他的类文件产生任何影响。不好的地方就是，相同的代码可能会存在多份，不过可以通过抽象共通的逻辑到model中来减少重复代码。 2. 新增提供者目录 以下操作按照新增一个阿里云提供者为例来说明如何添加新的提供者。 首先需要在model下的提供者目录下新增自己要添加的提供者目录 新建一个类infra_manager.rb（名称无所谓，也可以叫aliyun_manager.rb），类里信息： 在阿里云目录下新建一个infra_manager目录（该目录必须和上一个类的名字一致），该目录中存放的文件都是这个提供者所需要使用到的类，我们可以参考vmware的目录，具体的还是要根据实际情况来决定，目前因为我还没完全做完，仅做个提示。 配置展示提供者权限 仅仅增加了提供者目录还不足够让MIQ显示咱们的新的提供者，还必须设置展示权限才可以。权限设置文件为：miq\\vmdb\\config\\permissions.yml，在文件最后一行增加新的提供者，其中有个permissions.tmpl.yml文件也许也要添加，我添加的时候这两个文件都添加了，所以不敢保证只添加一个是否会成功，但是两个都添加肯定可以成功。 fog的配置以及连接 未开始 配置workers 未开始 界面配置 未开始 自动化引擎配置 未开始 界面显示效果 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/007-manageiq各种云平台provide资料.html":{"url":"doc/manageiq/007-manageiq各种云平台provide资料.html","title":"manageiq各种云平台provide资料","keywords":"","body":" return home 微软azure providers amazon 阿里云aliyun manageiq-providers-lenovo return home 微软azure providers https://github.com/fog/fog-azuremanageiq azure provider:https://github.com/ManageIQ/manageiq-providers-azureResource Manager 模式 - 用于在 Resource Manager 部署模型中处理 Azure 资源。若要设置此模式，请运行 azure config mode arm manageiq开发的armrest服务SDK powershell azure_CLI 中文安装文档 azure开发文档：https://docs.microsoft.com/zh-cn/azure/azure ruby开发：https://azure.microsoft.com/zh-cn/develop/ruby/https://github.com/Azure/azure-sdk-for-rubyhttps://azure.microsoft.com/zh-cn/downloads/Azure REST API Reference: https://docs.microsoft.com/zh-cn/rest/api/index对云服务的操作：URL访问资源rest： https://msdn.microsoft.com/library/en-us/Ee460812.aspxhttps://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-supported-services 服务管理 REST API 参考 Azure Active Directory介绍 中国区Azure应用程序开发说明(国内站点网址)：azure开发连接的国内网站客服提供 powershell CLI 中对虚拟的操作，获得镜像信息 个人编写的文档： azure-armrest中链接作用 azure获取TenantID, SubscriptionID, ClientID, ClientKey azure使用虚拟机生成私有镜像 amazon https://github.com/ManageIQ/manageiq-providers-amazon 阿里云aliyun https://github.com/fog/fog-aliyunhttps://rubygems.org/gems/fog-aliyunhttps://rubygems.org/gems/aliyun-apihttps://rubygems.org/gems/aliyun-sdkhttps://rubygems.org/gems/aliyun_ruby_apihttps://help.aliyun.com/document_detail/25485.html?spm=5176.doc25484.6.241.tethIg manageiq-providers-lenovo https://github.com/ManageIQ/manageiq-providers-lenovo powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/008-manageIQ服务部署.html":{"url":"doc/manageiq/008-manageIQ服务部署.html","title":"manageIQ服务部署","keywords":"","body":" manageiq 环境一体化虚拟机下载 # FileZilla的安装 # FileZilla的设置 ## 确认服务器能够上网 ## 服务器的代码更新 ## manageiq 环境一体化虚拟机下载 http://manageiq.org/download/在这里选好一个系统，如redhat，vmware虚拟机，这里下载好，可以直接在虚拟机中运行，环境已经搭配好。http://releases.manageiq.org/manageiq-ovirt-euwe-1.ova FileZilla的安装 服务器已经有了，此时需要把开发好的代码上传到服务器运行，使用filezilla软件可以连接服务器并修改文件。 centos系统下下载filezilla 1.在 Application Installer 软件中心搜索 filezilla，如果能搜索出来，那么可以点击安装。2.如果没有那么在终端运行命令： ## http://linux.it.net.cn/CentOS/course/2016/0401/20899.html $ sudo yum install –y filezilla FileZilla的设置 连接服务器打开软件后，输入host、username、password,port一般输入22，然后点快速连接。 软件语言设置edit -> settings -> language，然后在里面找和中文(Chinese(Simplified)(zh_CN) )、英文。 编辑.rb文件的编辑器设置编辑 -> 设置 -> 文件编辑 -> 文件格式关联，在里面添加： rb /usr/bin/gedit 确认服务器能够上网 因为需要安装ruby gem包，所需需要确认能够联网： $ ping wwww.baidu.com $ ping www.github.com $ ping bitbucket.org 如果不能上网： 配置DNS地址 http://jingyan.baidu.com/article/870c6fc32c028eb03fe4be30.html cd /etc/sysconfig/network-scripts cp ifcfg-eth0 ifcfg-eth0.backup vi ifcfg-eth0 # 修改里面DNS DNS1=221.228.255.1 $ vi /etc/resolv.conf # 在里面添加下面三行 nameserver 221.228.255.1 nameserver 114.114.114.114 nameserver 8.8.88 服务器的代码更新 使用FileZilla 输入用户名、密码、地址、端口(22)，链接，然后把代码上传上去，部分文件 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/009-manageIQ网页图标、图片、网页导航栏风格修改.html":{"url":"doc/manageiq/009-manageIQ网页图标、图片、网页导航栏风格修改.html","title":"manageIQ网页图标、图片、网页导航栏风格修改","keywords":"","body":" 修改后的生产环境需要从新编译js文件 1.登录首页图标的修改 2.登录页面的中间部分的背景色修改 3.登陆后页面上部(header)导航栏的背景色 4.登录后右上角 关于(about)页面的风格设置 登陆后，垂直导航栏的颜色设置 代码版本https://github.com/ManageIQ/manageiq/tree/euwe-1 修改后的生产环境需要从新编译js文件 ###### 下面命令不管用再用： bin/update $ bin/rails evm:compile_assets 1.登录首页图标的修改 1.查找相关信息 打开网站后，网页右键-->inspect(检查) --> select an element in the page to inspect it -->然后把鼠标放到图标那里，点击一下，就会看见定义信息， 右上角图标信息：用户名上面的图标： 右上角图标的修改 # manageiq官网镜像下载后虚拟机中代码位置 $ cd /var/www/miq/vmdb $ find ./ -name \"login-screen-logo*\" #查找图标信息 # 源代码中定义的图标 ./app/assets/images/login-screen-logo.png #源代码中修改此处就可以，图片替换 # 为了加快网页速度，生成的js共有资源的位置，网页中真实的访问图片位置， # 官网镜像中为了快速修改，可以直接修改此处 ./public/assets/login-screen-logo-cd43380036fc96964823fd8d6d7486fe9bcfcce1498daf0c41d8bc94385511da.png ./public/self_service/images/login-screen-logo.png 用户名上面的图片(manageIQ)修改 # manageiq官网镜像下载后虚拟机中代码位置 $ cd /var/www/miq/vmdb $ find ./ -name \"brand*\" #查找图标(manageIQ)位置 # 源代码中定义的图标 ./app/assets/images/brand.svg #源代码中修改此处就可以，图片替换 ./public/assets/brand-7005158295b20605eae00a080448d69a9c7b541ee3f99469b86e1bae955b0e89.svg.gz # 为了加快网页速度，生成的js共有资源的位置，网页中真实的访问图片位置，名字要一样。 ./public/assets/brand-7005158295b20605eae00a080448d69a9c7b541ee3f99469b86e1bae955b0e89.svg ./public/self_service/images/brand.svg ./public/self_service/img/brand-alt.svg ./public/self_service/img/brand.svg ./vendor/assets/bower_components/patternfly-sass/assets/images/patternfly/brand-alt.svg ./vendor/assets/bower_components/patternfly-sass/assets/images/patternfly/brand.svg 网页标题(title)更改 1.这个是文字不是图片，查找定义处： # 这里是首页登录的控制器处理部分，在这一喊显示了调用了哪部分视图 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/controllers/dashboard_controller.rb#L357 # 这里是网页渲染，这一行显示了title处理部分， -->title_from_layout 这个方法返回title是什么 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/views/layouts/login.html.haml#L6 # title_from_layout 方法定义处，这里用I18n来自动转换语言，在语言里写着标题 https://github.com/ManageIQ/manageiq/blob/euwe-1/app/helpers/application_helper.rb#L443 #最后，这里就是标题定义处，这个有几种语言(汉语，英语等)，别的代码版本不是这个路径，不过还是local这个目录里面， # 别的版本只要找这个local目录就好了，例如：/var/www/miq/vmdb/config/locales manageIQ/locale 2.修改标题https://github.com/ManageIQ/manageiq/blob/euwe-1/locale/zh_CN.yml zh-CN: product: name: ManageIQ # 这个是网页title名字 name_full: ManageIQ #这个是登录后右上角 问号按钮的字段 (关于页面)about copyright: \"Copyright (c) 2016 ManageIQ。由红帽赞助.\" #这个是登录后右上角 问号按钮的字段 (关于页面)about support_website: \"http://www.manageiq.org\" #这个是登录后右上角 问号按钮的字段 (关于页面)about support_website_text: \"ManageIQ.org\" #这个是登录后右上角 问号按钮的字段 (关于页面)about # 修改后 zh-CN: product: name: JasCloud name_full: JasCloud copyright: \"Copyright (c) 2017 JasCloud。由中盈安信赞助。\" support_website: \"www.jasgroup.cn\" support_website_text: \"www.jasgroup.cn\" en.yml, es.yml, fr.yml, ja.yml 也需要做相应修改。修改好后需要重启服务。 2.登录页面的中间部分的背景色修改 文件位置：app/assets/stylesheets/login.scss app/assets/stylesheets/main.scss # app/assets/stylesheets/login.scss &.login-pf { background-color: $login-bg-color !important; # 这里设置背景色的地方 } @media (min-width: $screen-sm) { &.login-pf { background: image-url($img-bg-login-2); # 这是右下角的图片设置 background-position: 100% 100%; background-repeat: no-repeat; background-size: 30%; } } # app/assets/stylesheets/main.scss $login-bg-color: #083c5a; # 大约是在28行附近 $img-bg-login: \"bg-login.png\"; # 左上角的图片 图片位置：app/assets/images/bg-login.png $img-bg-login-2: \"bg-login-2.png\";# 右下角的图片 3.登陆后页面上部(header)导航栏的背景色 文件位置：app/assets/stylesheets/header_background.scssapp/assets/stylesheets/main.scss # app/assets/stylesheets/header_background.scss .navbar-pf-vertical { background: image-url($img-bg-navbar); # 右边的图片 background-repeat: no-repeat; background-position: 100% 0; background-color: $navbar-pf-alt-bg-color; # 背景色设置 } # app/assets/stylesheets/main.scss # 上面的背景色设置： $navbar-pf-alt-bg-color: #0c69a5; //大约在第9行 sets backgound color of navigation bar # 上面的图片设置： $img-bg-navbar: \"navbar.png\"; //大约在第11行 sets a custom background image in the header 4.登录后右上角 关于(about)页面的风格设置 文件位置：app/assets/stylesheets/about_modal_background.scss #app/assets/stylesheets/about_modal_background.scss .about-modal-pf { background-color: $modal-about-pf-bg-color; # 背景色的设置 background-image: image-url($modal-about-pf-bg-img); # 图片的设置 } # app/assets/stylesheets/main.scss $modal-about-pf-bg-img: \"bg-modal-about-pf.png\"; // sets background image of 'About' modal $modal-about-pf-bg-color: #083c5a; // sets background color of 'About' modal 登陆后，垂直导航栏的颜色设置 这个导航栏的风格是第三方插件： # Gemfile 文件 group :ui_dependencies do # Added to Bundler.require in config/application.rb ········· gem \"patternfly-sass\", \"~>3.12.0\" # 这个是垂直导航栏的风格，大约95行附近 ········· end 垂直导航栏颜色设置源码：https://github.com/patternfly/patternfly-sass/blob/v3.12.0/assets/stylesheets/patternfly/_vertical-nav.scss manageIQ文件可设置颜色参数，变量即上面的变量： # app/assets/stylesheets/main.scss //手动添加的内容 $nav-pf-vertical-bg-color: #1770e6; //垂直导航栏第一列背景色 $nav-pf-vertical-item-border-color: #f5ed3c; //垂直导航栏第一列边栏的颜色 $nav-pf-vertical-color: #ffe015; //垂直导航栏第一列字体颜色 $nav-pf-vertical-active-bg-color: #261ac0; //垂直导航栏第一列鼠标选择按钮时候的颜色 $nav-pf-vertical-active-color: #d60116; //垂直导航栏第一列鼠标选择时,字体的颜色 $nav-pf-vertical-icon-color: #fcfcfc; //垂直导航栏第一列 图标颜色 $nav-pf-vertical-active-icon-color: #b22e23; //垂直导航栏第一列鼠标选择时,图标的颜色 $nav-pf-vertical-active-before-color: #82237b;//垂直导航栏第一列鼠标选择后,左边多出来的一条颜色 $nav-pf-vertical-secondary-color: #fff717; //垂直导航栏第二列导航标题字体颜色 //$nav-pf-vertical-secondary-bg-color: #7b22ff; //垂直导航栏第二列背景色,如果这个不设置则跟鼠标选择第一列的颜色是一样的。 $nav-pf-vertical-secondary-item-color: #d60116; //垂直导航栏第二列字体颜色, $nav-pf-vertical-secondary-active-bg-color: #696fff; //垂直导航栏第二列鼠标选择按钮时候的背景色 $nav-pf-vertical-secondary-active-color: #ffe015; //垂直导航栏第二列鼠标选择按钮时 字体的颜色 $nav-pf-vertical-secondary-indicator-color: #ff03e8; //垂直导航栏箭头颜色 $nav-pf-vertical-tertiary-bg-color: #696fff; //垂直导航栏第三列的背景色 $nav-pf-vertical-tertiary-color: #b82433; //垂直导航栏第三列标题字颜色 $nav-pf-vertical-tertiary-item-color: #db0921; //垂直导航栏第三列字体的颜色 $nav-pf-vertical-tertiary-active-bg-color: #fef9ff; //垂直导航栏第三列鼠标选择时的背景色 $nav-pf-vertical-tertiary-active-color: #000000; //垂直导航栏第三列鼠标选择时的 字体颜色 powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/010-开发manageiq遇见的问题、错误解决.html":{"url":"doc/manageiq/010-开发manageiq遇见的问题、错误解决.html","title":"开发manageiq遇见的问题、错误解决","keywords":"","body":" 运行bin/setup命令发生错误 修改官方虚拟机中的.js文件不起作用 manageiq Gemfile 文件加载的不止一个 bin/setup:26: warning: Insecure world writable dir /home/yu in PATH, mode 040777 bundle install error:无法打开 .git/FETCH_HEAD：???? gem install pg -v '0.18.4' error Error caught: [ActionView::Template::Error] couldn't find file 'jquery' with type 'application/javascript' Failed to instantiate module ManageIQ.toolbar due to:(头部工具栏消失) run /opt/manageiq/manageiq/tools/ldap_ping.rb from command line 运行bin/setup命令发生错误 当下载manageiq后运行： [manageiq]$ bin/setup == Seeding database == ActionCable version is 5.0.1 or newer, please see if we still need this patch: /home/yulilong/tmp/manageiq2016-12-30/config/initializers/action_cable_patch.rb! ** Using session_store: ActionDispatch::Session::MemCacheStore rails aborted! ActiveModel::MissingAttributeError: can't write unknown attribute `region_number` /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activerecord-5.0.1/lib/active_record/attribute.rb:182:in `with_value_from_database' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activerecord-5.0.1/lib/active_record/attribute.rb:63:in `forgetting_assignment' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.1/lib/active_support/core_ext/hash/transform_values.rb:16:in `block in transform_values' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.1/lib/active_support/core_ext/hash/transform_values.rb:15:in `each' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activesupport-5.0.1/lib/active_support/core_ext/hash/transform_values.rb:15:in `transform_values' /home/yulilong/.rvm/gems/ruby-2.3.0/gems/activerecord-5.0.1/lib/active_record/attribute_set/builder.rb:26:in `transform_values' 查看rails版本： $ rails -v Rails 5.0.0.1 在rails 版本是 5.0.0.1下，解决方法： 打开Gemfile文件，修改如下： -gem \"rails\", \"~>5.0.0\", \">= 5.0.0.1\" +gem \"rails\", \"~>5.0.0\", \">= 5.0.0.1\", \"保存后，删除Gemfile.lock文件，然后从新运行命令即可解决问题。 修改官方虚拟机中的.js文件不起作用 下载： http://releases.manageiq.org/manageiq-ovirt-euwe-1-rc2.ova运行这个虚拟机后，修.rb文件时有效的，但是修改.js文件时不起作用的，经查找，虚拟机中.js文件已经编译了， 网页访问的资源(/var/www/miq/vmdb/public/assets). .js文件编译后都放在这个文件中了。 如果修改了.js文件，那么在虚拟机中运行: # bin/update $ bin/rails evm:compile_assets manageiq Gemfile 文件加载的不止一个 在根目录的Gemfile文件里面： # Load other additional Gemfiles eval_gemfile(File.expand_path(\"gems/pending/Gemfile\", __dir__)) Dir.glob(\"bundler.d/*.rb\").each { |f| eval_gemfile(File.expand_path(f, __dir__)) } bin/setup:26: warning: Insecure world writable dir /home/yu in PATH, mode 040777 $ sudo chmod go-w /home/yulilong bundle install error:无法打开 .git/FETCH_HEAD：???? # https://github.com/Homebrew/legacy-homebrew/issues/43471 # centos 7.2的解决方案(亲测有效果) sudo chown -R $(whoami):root /usr/local && sudo chmod -R g+rwx /usr/local # Mac苹果系统的解决方式(没有试过) sudo chown -R $(whoami):admin /usr/local && sudo chmod -R g+rwx /usr/local gem install pg -v '0.18.4' error descriptionERROR: Error installing pg: ERROR: Failed to build gem native extension. ..... ..... ..... To see why this extension failed to compile, please check the mkmf.log which can be found here: solution:http://www.faqoverflow.com/serverfault/316703.html``` $ sudo yum install postgresql-devel If you still encounter issues with pg_config, you may need to add it to your PATH, e.g.: $ export PATH=$PATH:/usr/pgsql-x.x/bin where x.x is your version, such as /usr/pgsql-9.2./bin. ![WX20170308-152045.png](https://bitbucket.org/repo/oE6yEX/images/2522309900-WX20170308-152045.png) ## Error caught: [ActionView::Template::Error] couldn't find file 'jquery' with type 'application/javascript' ![WX20170310-135142.png](https://bitbucket.org/repo/oE6yEX/images/802757315-WX20170310-135142.png) 解决方法： 打开程序根目录bower.json,大约58到63行， \"resolutions\": { \"patternfly-bootstrap-treeview\": \"~2.1.1\", \"moment\": \">=2.10.5\", \"d3\": \"~3.5.0\", \"jquery\": \">1.8.\" # 改成\"jquery\": \">=1.7.1\"，如果还出错，就把这一行删除然后在运行 } 把\"jquery\": \">1.8.\" 改成\"jquery\": \">=1.7.1\" 然后运行下面命令： $ bower install 如果这个命令运行后没有什么输出，那么运行 bower update 后再次运行这个命令 如果还是没有反应就看看是不是代理失效了，这个命令需要代理翻墙才可以，确认代理后从新运行这个命令 或者使用下面命令 $ bin/update ## Failed to instantiate module ManageIQ.toolbar due to:(头部工具栏消失) ![WX20170317-172420.png](https://bitbucket.org/repo/oE6yEX/images/3411011686-WX20170317-172420.png) 解决方法： https://github.com/ManageIQ/manageiq/pull/13750 http://talk.manageiq.org/t/failed-to-instantiate-module-manageiq-toolbar-due-to/2185/3 打开程序根目录bower.json,大约58到63行， \"dependencies\": { \"angular\": \"~1.5.8\", \"angular-animate\": \"~1.5.8\", ········ \"manageiq-ui-components\": \"~0.0.9\", # 这里改成\"manageiq-ui-components\": \"0.0.11\", ······· } 把\"manageiq-ui-components\": \"~0.0.9\", 改成 \"manageiq-ui-components\": \"0.0.11\", 然后运行下面命令： $ bower update $ bower install 如果没有反应就看看是不是代理失效了，这个命令需要代理翻墙才可以，确认代理后从新运行这个命令 或者使用下面命令 $ bin/update ## run /opt/manageiq/manageiq/tools/ldap_ping.rb from command line $ bundle exec rails r tools/ldap_ping.rb ``` powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/011-添加新的Providers代码开发.html":{"url":"doc/manageiq/011-添加新的Providers代码开发.html","title":"添加新的Providers代码开发","keywords":"","body":" 添加一个新的providers代码目录 添加页面validate按钮可用设置 添加work # 添加 ManageIQ::Providers::Aliyun::CloudManager::RefreshWorker ## EVM CloudManager 启用监听 ManageIQ/manageiq/config/settings.yml manageiq/app/models/miqserver/workermanagement/monitor/class_names.rb providers中添加代码 ## aliyun providers 读取信息 ## 在显示套餐详细信息页面中添加aliyun providers 图标 (http://localhost:3000/flavor/show/15)### 添加自动监视 ### 代码编写 ### 套餐(Flavors) ### 可用区(Availability Zones) ### 添加ManageIQ::Providers::Aliyun::NetworkManager::RefreshWorker ## EVM NetworkManager 启用监听 ManageIQ/manageiq/config/settings.yml manageiq/app/models/miqserver/workermanagement/monitor/class_names.rb 添加 networkmanager 图标 ## NetworkManager代码 ## 添加安全组(security_groups) ### 添加实例(Instance) ### 添加实例的开机、关机、重启功能 ### 添加一个新的providers代码目录 添加页面validate按钮可用设置 manageiq/app/assets/javascripts/controllers/ems_common/ems_common_form_controller.js 在191行 附近如下代码处添加一行代码（$scope.emsCommonModel.emstype == \"aliyun\" ||） #!js $scope.isBasicInfoValid = function() { if(($scope.currentTab == \"default\" && $scope.emsCommonModel.emstype != \"azure\") && ($scope.emsCommonModel.emstype == \"ec2\" || $scope.emsCommonModel.emstype == \"aliyun\" || $scope.emsCommonModel.emstype == \"openstack\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"scvmm\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"openstack_infra\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"nuage_network\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"rhevm\" && $scope.emsCommonModel.default_hostname || $scope.emsCommonModel.emstype == \"vmwarews\" && $scope.emsCommonModel.default_hostname 添加work 添加 ManageIQ::Providers::Aliyun::CloudManager::RefreshWorker EVM CloudManager 启用监听 ManageIQ/manageiq/config/settings.yml https://github.com/ManageIQ/manageiq/blob/euwe-1-rc2/config/settings.yml#L1258在这个配置文件里面添加：:ems_metrics_collector_worker_aliyun: {} https://github.com/ManageIQ/manageiq/blob/euwe-1-rc2/config/settings.yml#L1295添加如下代码：:ems_refresh_worker_aliyun: {} manageiq/app/models/miq_server/worker_management/monitor/class_names.rb 添加代码：ManageIQ::Providers::Aliyun::CloudManager::MetricsCollectorWorkerManageIQ::Providers::Aliyun::CloudManager::RefreshWorker providers中添加代码 可以参考其他providers，需要添加如下几个文件：manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/metrics_collector_worker/runner.rb manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/metrics_collector_worker.rb manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresh_worker.rb manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresher.rb aliyun providers 读取信息 在显示套餐详细信息页面中添加aliyun providers 图标 (http://localhost:3000/flavor/show/15) 图标存放位置：manageiq/app/assets/images/100 图片名字：vendor-aliyun.png 添加自动监视 manageiq/lib/miq_automation_engine/service_models 在运行我worker时候，查看evm.log文件的时候发现如下错误， Error: [uninitialized constant MiqAeMethodService::MiqAeServiceManageIQ_Providers_Aliyun_CloudManager] [NameError]: uninitialized constant MiqAeMethodService::MiqAeServiceManageIQ_Providers_Aliyun_CloudManager Method:[rescue in deliver] 参考其他的provider的写法，把aliyun相关的类添加上，一个类一个文件：MiqAeServiceManageIQ_Providers_Aliyun_CloudManager在里面每个provider都有很多类，写到哪个类的时候可以手动添加上。 代码编写 manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresher.rb这个文件是provider worker工作的入口，这个文件里面先搜集信息，然后保存信息，相关写法可参考amazon、openstack providers的写法 def parse_legacy_inventory(ems) # 这个方法是搜集云服务的一些信息（套餐、可用区、安全组、镜像、实例等） def save_inventory(ems, _targets, hashes) # 这个方法保存搜集到的信息，2中保存方法 manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresh_parser.rb这个文件是搜集信息的具体代码定义处。 def ems_inv_to_hashes #这里就是每个信息的搜集处 套餐(Flavors) manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/refresh_parser.rb def get_flavors # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法manageiq-providers-aliyun/app/models/manageiq/providers/aliyun/cloud_manager/flavor.rb添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_CloudManager_Flavor 可用区(Availability Zones) app/models/manageiq/providers/aliyun/cloud_manager/refresh_parser.rb def get_availability_zones # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法app/models/manageiq/providers/aliyun/cloud_manager/availability_zone.rb添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_CloudManager_AvailabilityZone 安全组是在NetworkManager 模块里面的，所以先提阿加 NetworkManager 添加ManageIQ::Providers::Aliyun::NetworkManager::RefreshWorker EVM NetworkManager 启用监听 ManageIQ/manageiq/config/settings.yml 这里与上边的设置一样，在相关位置添加如下代码(大约是第1370行附近)： :ems_refresh_worker_aliyun_network: {} manageiq/app/models/miq_server/worker_management/monitor/class_names.rb 在2个数组中（MONITOR_CLASS_NAMES、MONITOR_CLASS_NAMES_IN_KILL_ORDER）添加如下代码： ManageIQ::Providers::Aliyun::NetworkManager::RefreshWorker 添加 networkmanager 图标 manageiq/app/assets/images/svg添加一个图片，名字： vendor-aliyun_network.svgmanageiq/app/assets/images/100添加一个图片，名字： vendor-aliyun_network.png NetworkManager代码 app/models/manageiq/providers/aliyun/network_manager.rbapp/models/manageiq/providers/aliyun/network_manager/refresher.rbapp/models/manageiq/providers/aliyun/network_manager/refresh_worker.rbapp/models/manageiq/providers/aliyun/network_manager/refresh_parser.rbapp/models/manageiq/providers/aliyun/network_manager/metrics_collector_worker.rbapp/models/manageiq/providers/aliyun/network_manager/refresh_worker/runner.rbapp/models/manageiq/providers/aliyun/network_manager/metrics_collector_worker/runner.rb 可以看到，Aliyun::NetworkManager 与 Aliyun::CloudManager 文件、代码结构差不多。具体实现也是一样的。 添加安全组(security_groups) app/models/manageiq/providers/aliyun/network_manager/refresh_parser.rb def get_availability_zones # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法app/models/manageiq/providers/aliyun/network_manager/security_group.rb添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_NetworkManager_SecurityGroup 添加实例(Instance) app/models/manageiq/providers/aliyun/network_manager/refresh_parser.rb get_instances # 具体实现参考amazon、openstack providers的写法 添加文件,可参考amazon、openstack providers的写法app/models/manageiq/providers/aliyun/cloud_manager/vm.rb 添加类：manageiq/lib/miq_automation_engine/service_modelsMiqAeServiceManageIQ_Providers_Aliyun_CloudManager_Vm 添加方法： app/models/manageiq/providers/aliyun/cloud_manager/refresher.rb def post_process_refresh_classes #如果没有这个方法，vm.rb将不能执行 [::Vm] end 这里也添加一下：db/fixtures/miq_searches.yml # line:43 -attributes: name: default_Platform / Aliyun description: Platform / Aliyun filter: !ruby/object:MiqExpression exp: \"=\": field: Vm-type value: ManageIQ::Providers::Aliyun::CloudManager::Vm search_type: default search_key: _hidden_ db: Vm - attributes: # line:1020 name: default_Platform / Aliyun description: Platform / Aliyun filter: !ruby/object:MiqExpression exp: \"=\": field: VmCloud-type value: ManageIQ::Providers::Aliyun::CloudManager::Vm search_type: default search_key: _hidden_ db: ManageIQ::Providers::CloudManager::Vm 数据库中，vms表 vendor字段的aliyun支持：app/models/vm_or_template.rb VENDOR_TYPES = { # 如果没有这个，数据库将不能存储实例，数据验证失败 \"google\" => \"Google\", \"aliyun\" => \"Aliyun\", \"unknown\" => \"Unknown\"} 添加实例的开机、关机、重启功能 当在网页点击开机后，rails 会给evm 服务发送消息，由EVM 服务来完成的， 添加电源操作Operations模块：app/models/manageiq/providers/aliyun/cloud_manager/vm/operations.rb module ManageIQ::Providers::Aliyun::CloudManager::Vm::Operations extend ActiveSupport::Concern include_concern 'Guest' include_concern 'Power' end 添加Guest模块，这里是重启服务器的实现部分app/models/manageiq/providers/aliyun/cloud_manager/vm/operations/guest.rb module ManageIQ::Providers::Aliyun::CloudManager::Vm::Operations::Guest extend ActiveSupport::Concern included do supports :reboot_guest do unsupported_reason_add(:reboot_guest, unsupported_reason(:control)) unless supports_control? unsupported_reason_add(:reboot_guest, _(\"The VM is not powered on\")) unless current_state == \"on\" end end def raw_reboot_guest with_provider_connection { |connection| parameters = {:InstanceId => ems_ref} connection.RebootInstance(parameters) # retrun {\"RequestId\"=>\"9585CF9B-9049-41A1-B42B-BE3867C26AAB\"} } # Temporarily update state for quick UI response until refresh comes along self.update_attributes!(:raw_power_state => \"reboot\") # show state as suspended end end 添加Power模块，这里是开机、关机实现部分app/models/manageiq/providers/aliyun/cloud_manager/vm/operations/power.rb``` module ManageIQ::Providers::Aliyun::CloudManager::Vm::Operations::Power extend ActiveSupport::Concern def raw_start with_provider_connection { |connection| parameters = {:InstanceId => ems_ref} connection.StartInstance(parameters) } Temporarily update state for quick UI response until refresh comes along self.update_attributes!(:raw_power_state => \"powering_up\") end def raw_stop with_provider_connection { |connection| parameters = {:InstanceId => ems_ref} connection.StopInstance(parameters) } Temporarily update state for quick UI response until refresh comes along self.update_attributes!(:raw_power_state => \"shutting_down\") end end * 最后在vm类中添加Operations的引用 app/models/manageiq/providers/aliyun/cloud_manager/vm.rb include_concern 'Operations' ``` powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/azure/001-azure获取TenantID、SubscriptionID、ClientID、ClientKey.html":{"url":"doc/manageiq/azure/001-azure获取TenantID、SubscriptionID、ClientID、ClientKey.html","title":"azure获取TenantID、SubscriptionID、ClientID、ClientKey","keywords":"","body":" return home overview ## powershell install 微软国内帐号获得Tenant ID, Subscription ID, Client ID, Client Key ## return home overview 在获得软件开发帐号之前，需要准备的工作： 有azure国内国外的服务器帐号。 有订阅ID，这个需要自己去申请订阅ID，只有试用的才免费，其他都是收费的。 powershell工具，根据系统的不同安装也不同，具体见下面的教程。 powershell install 使用教程：https://www.azure.cn/documentation/articles/powershell-install-configure/安装教程：https://github.com/PowerShell/PowerShellhttps://github.com/PowerShell/azure-powershell里面有各种系统的安装教程，下面以centos linux 为例说明。 # install $ sudo yum install https://github.com/PowerShell/PowerShell/releases/download/v6.0.0-alpha.14/powershell-6.0.0_alpha.14-1.el7.centos.x86_64.rpm # Uninstallation $ sudo yum remove powershell # run $ powershell # run PS /home/user_name> exit #exit powershell install powershell Azure Modulehttp://www.cnblogs.com/hengwei/p/5804139.html $ su root #这个要在root用户权限下安装才有效，普通用户安装失败 $ mkdir -p /usr/local/share/powershell/Modules #创建PowerShell Moudle的安装目录 $ powershell # 进入PowerShell环境 # 安装Azure包 PS user_name>Install-Package -Name AzureRM.NetCore.Preview -Source https://www.powershellgallery.com/api/v2 -ProviderName NuGet -ExcludeVersion -Destination /usr/local/share/powershell/Modules # Import Azure包 PS user_name> Import-Module AzureRM.NetCore.Preview 微软国内帐号获得Tenant ID, Subscription ID, Client ID, Client Key azure中国的获得``` [yu@localhost ~]$ powershell PowerShell Copyright (C) 2016 Microsoft Corporation. All rights reserved. PS /home/yu> Login-AzureRmAccount -EnvironmentName AzureChinaCloudVERBOSE: To sign in, use a web browser to open the page https://aka.ms/deviceloginchina and enter the code A2LExxxxx to authenticate. 这里打开这个连接，然后输入后面的代码，之后输入帐号，密码后就会出现下面的信息。 TenantID，SubscriptionID在下面 Environment : AzureChinaCloud Account : xxxxxxxxxxxx@jasgroup.partner.onmschina.cn TenantId : e6e48f7d-3248-4a18-8ff0-xxxxxxxxxxxx SubscriptionId : 4b1b759a-1958-412a-90ec-xxxxxxxxxxxx SubscriptionName : Windows Azure 企业 CurrentStorageAccount : Set-AzureRmContext -SubscriptionId 4b1b759a-1958-412a-90ec-xxxxxxxxxxxx $azureAdApplication = New-AzureRmADApplication -DisplayName \"webapp01\" -HomePage \"https://www.webapp01.xxxxxxxxxxxx.cn\" -IdentifierUris \"https://www.xxxxxxxxxxxx.org/webapp01\" -Password \"cloud@1qaz@xxx\" $azureAdApplication ClientKey: 就是上面设置的密码 cloud@1qaz@xxx ClientID : 就是下面的ApplicationId DisplayName : webapp01 ObjectId : 201a9648-6b80-40ce-8b7c-xxxxxxxxxxxx IdentifierUris : {https://www.xxxxxxxxxxxx.org/webapp01} HomePage : https://www.webapp01.xxxxxxxxxxxx.cn Type : Application ApplicationId : 409a871d-b24f-4bef-ac8f-xxxxxxxxxxxx AvailableToOtherTenants : False AppPermissions : ReplyUrls : {} New-AzureRmADServicePrincipal -ApplicationId $azureAdApplication.ApplicationId DisplayName Type ObjectId webapp01 ServicePrincipal ee14f618-e3b2-466b-9ff7-82xxxxxxxxxxx 给这个app设置相应的 订阅ID权限 New-AzureRmRoleAssignment -RoleDefinitionName Reader -ServicePrincipalName $azureAdApplication.ApplicationId RoleAssignmentId : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/ae74b507-19e3-4e0a-8e84-xxxxxxxxxxxx Scope : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : ee14f618-e3b2-466b-9ff7-xxxxxxxxxxxx ObjectType : ServicePrincipal Get-AzureRmRoleAssignment RoleAssignmentId : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/ae74b507-19e3-4e0a-8e84-xxxxxxxxxxxx Scope : /subscriptions/4b1b759a-1958-412a-90ec-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : ee14f618-e3b2-466b-9ff7-xxxxxxxxxxxx ObjectType : ServicePrincipal * azure国外获得 PS C:\\Users\\xxxx> Login-AzureRmAccount VERBOSE: To sign in, use a web browser to open the page https://aka.ms/devicelogin and enter the code GTMMSNYNX to authenticate. 这里打开这个连接，然后输入后面的代码，之后输入帐号，密码后就会出现下面的信息。 TenantID，SubscriptionID在下面 Environment : AzureCloud Account : kylin_fedora@hotmail.com TenantId : 73931c80-2096-4efa-a21c-xxxxxxxxxxxx SubscriptionId : 3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx SubscriptionName : 即用即付 CurrentStorageAccount : PS C:\\Users\\xxxx> Set-AzureRmContext -SubscriptionId 3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx PS C:\\Users\\xxxx> $azureAdApplication = New-AzureRmADApplication -DisplayName \"webapp01\" -HomePage \"https://www.webapp01.xxxxxxxxxxxx.cn\" -IdentifierUris \"https://www.xxxxxxxxxxxx.org/webapp01\" -Password \"cloud@1qaz@xxx\" PS C:\\Users\\xxxx> $azureAdApplication ClientKey: 就是上面设置的密码 cloud@1qaz@xxx ClientID : 就是下面的ApplicationId DisplayName : webapp01 ObjectId : f31dc940-54af-49be-9c17-xxxxxxxxxxxx IdentifierUris : {https://www.xxxxxxxxxxxx.org/webapp01} HomePage : https://www.webapp01.xxxxxxxxxxxx.cn Type : Application ApplicationId : 8ba1064d-d53c-4ad3-82e2-xxxxxxxxxxxx AvailableToOtherTenants : False AppPermissions : ReplyUrls : {} PS C:\\Users\\kylin> New-AzureRmADServicePrincipal -ApplicationId $azureAdApplication.ApplicationId DisplayName Type ObjectId webapp01 ServicePrincipal 1757c1ee-12bb-4e62-9ef4-xxxxxxxxxxxx 给这个app设置相应的 订阅ID权限 PS C:\\Users\\kylin> New-AzureRmRoleAssignment -RoleDefinitionName Reader -ServicePrincipalName $azureAdApplication.ApplicationId RoleAssignmentId : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/fc911348-23cc-4329-bbc4-xxxxxxxxxxxx Scope : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : 1757c1ee-12bb-4e62-9ef4-xxxxxxxxxxxx ObjectType : ServicePrincipal PS C:\\Users\\kylin> Get-AzureRmRoleAssignment RoleAssignmentId : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx/providers/Microsoft.Authorization/roleAssignments/fc911348-23cc-4329-bbc4-xxxxxxxxxxxx Scope : /subscriptions/3b22ed16-6255-4eb4-b808-xxxxxxxxxxxx DisplayName : webapp01 SignInName : RoleDefinitionName : Reader RoleDefinitionId : acdd72a7-3385-48ef-bd42-xxxxxxxxxxxx ObjectId : 1757c1ee-12bb-4e62-9ef4-xxxxxxxxxxxx ObjectType : ServicePrincipal ``` 赋予应用ID操作订阅ID权限的命令: Owner has full access to all resources including the right to delegate access to others.Contributor can create and manage all types of Azure resources but can’t grant access to others.Reader can view existing Azure resources. powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/azure/002-azure开发连接的国内网站.html":{"url":"doc/manageiq/azure/002-azure开发连接的国内网站.html","title":"azure开发连接的国内网站","keywords":"","body":" Name : AzureChinaCloud EnableAdfsAuthentication : False ActiveDirectoryServiceEndpointResourceId : https://management.core.chinacloudapi.cn/ AdTenant : GalleryUrl : https://gallery.chinacloudapi.cn/ ManagementPortalUrl : http://go.microsoft.com/fwlink/?LinkId=301902 ServiceManagementUrl : https://management.core.chinacloudapi.cn/ PublishSettingsFileUrl : http://go.microsoft.com/fwlink/?LinkID=301776 ResourceManagerUrl : https://management.chinacloudapi.cn/ SqlDatabaseDnsSuffix : .database.chinacloudapi.cn StorageEndpointSuffix : core.chinacloudapi.cn ActiveDirectoryAuthority : https://login.chinacloudapi.cn/ GraphUrl : https://graph.chinacloudapi.cn/ TrafficManagerDnsSuffix : trafficmanager.cn AzureKeyVaultDnsSuffix : vault.azure.cn AzureKeyVaultServiceEndpointResourceId : https://vault.azure.cn powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/azure/003-azure-armrest中链接作用.html":{"url":"doc/manageiq/azure/003-azure-armrest中链接作用.html","title":"azure-armrest中链接作用","keywords":"","body":" 获得订阅下面所有Storage accounts信息https://management.chinacloudapi.cn/subscriptions/4b1b759a-1958-412a-90ec-d9a4959ad8bc/providers/Microsoft.Storage/storageAccounts?api-version=2016-05-01返回信息： {\"value\":[{\"id\":\"/subscriptions/4b1b759a-1958-412a-90ec-d9a4959ad8bc/resourceGroups/test/providers/Microsoft.Storage/storageAccounts/testdiag563\",\"kind\":\"Storage\",\"location\":\"chinanorth\",\"name\":\"testdiag563\",\"properties\":{\"creationTime\":\"2017-01-05T02:23:12.5759270Z\",\"primaryEndpoints\":{\"blob\":\"https://testdiag563.blob.core.chinacloudapi.cn/\",\"file\":\"https://testdiag563.file.core.chinacloudapi.cn/\",\"queue\":\"https://testdiag563.queue.core.chinacloudapi.cn/\",\"table\":\"https://testdiag563.table.core.chinacloudapi.cn/\"},\"primaryLocation\":\"chinanorth\",\"provisioningState\":\"Succeeded\",\"statusOfPrimary\":\"available\"},\"sku\":{\"name\":\"Standard_LRS\",\"tier\":\"Standard\"}, 对应的网站信息： 获取storageAccounts/testdiag563下key信息https://management.chinacloudapi.cn/subscriptions/4b1b759a-1958-412a-90ec-d9a4959ad8bc/resourceGroups/test/providers/Microsoft.Storage/storageAccounts/testdiag563/listKeys?api-version=2016-05-01返回信息： NKxXLEqWH80FIReivSMGgNb8vwUHDl47UkeZ1Xm3LfPIazV+FhtRmTt56rTsy7EjhA9dVh0H+YrB5nZxBigMww== 这个应该查询存储账户下面的信息，知道后更新 {:url=>\"https://testvmdisks334.blob.core.chinacloudapi.cn/?comp=list\", :headers=>{\"Content-Type\"=>\"\", \"x-ms-date\"=>\"Tue, 24 Jan 2017 01:35:14 GMT\", \"x-ms-version\"=>\"2015-12-11\", :auth_string=>true, \"content-type\"=>\"\", \"auth_string\"=>true, \"Authorization\"=>\"SharedKey testvmdisks334:0KTn90jFVVekdTyW/C4nMlw7wCditXSc7j+VFlfxSBU=\"}, :proxy=>nil, :ssl_version=>\"TLSv1\", :ssl_verify=>nil, :method=>:get} {:url=>\"https://testvmdisks334.blob.core.chinacloudapi.cn/vhds?restype=container&comp=list\", :headers=>{\"Content-Type\"=>\"\", \"x-ms-date\"=>\"Tue, 24 Jan 2017 01:35:14 GMT\", \"x-ms-version\"=>\"2015-12-11\", :auth_string=>true, \"content-type\"=>\"\", \"auth_string\"=>true, \"Authorization\"=>\"SharedKey testvmdisks334:2CRLCongUiRYOIUI6+DRJSuPDDLUDE0DQ3MiCkBg8us=\"}, :proxy=>nil, :ssl_version=>\"TLSv1\", :ssl_verify=>nil, :method=>:get} 返回结果： #> 这个应该是 Blob 服务信息，以后更新： {:url=>\"https://testvmdisks334.blob.core.chinacloudapi.cn/vhds/centos7-base20170104130639.vhd\", :headers=>{\"Content-Type\"=>\"\", \"x-ms-date\"=>\"Tue, 24 Jan 2017 01:35:14 GMT\", \"x-ms-version\"=>\"2015-12-11\", :auth_string=>true, :verb=>\"HEAD\", \"content-type\"=>\"\", \"auth_string\"=>true, \"verb\"=>\"HEAD\", \"Authorization\"=>\"SharedKey testvmdisks334:Z6j2M4pt8v+S7AvzgRL98a6bQMAdHglPp49/A+gNn+E=\"}, :proxy=>nil, :ssl_version=>\"TLSv1\", :ssl_verify=>nil, :method=>:head} 返回结果： # powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/manageiq/azure/004-azure使用虚拟机生成私有镜像.html":{"url":"doc/manageiq/azure/004-azure使用虚拟机生成私有镜像.html","title":"azure使用虚拟机生成私有镜像","keywords":"","body":" overview 开始生成私有镜像 通过私有镜像来创建虚拟机 overview 这么做的目的 1.用于manageiq里面azure的获取镜像信息，manageiq里面 auzre provider 获取镜像是从 存储账户中获得镜像信息，不是获得共有的镜像。2.共有的镜像信息很多，在这里存储后可以快速找到自己想要的镜像信息。 需要提前准备的事情 1.在共有镜像中要到需要的镜像，使用此镜像创建一个最小的资源的（花钱最少），镜像生成后这个虚拟机就不能使用了，需要释放掉。2.powershell 软件已经安装好了，如果没有安装好，安装教程：https://www.azure.cn/documentation/articles/powershell-install-configure/3.目前的操作是基于微软中国区的操作，门户预览：https://portal.azure.cn ，本文当的操作是在2017-02-13之前操作的。 生成的私有镜像在存储账户中 开始生成私有镜像 1.创建虚拟机后关机https://portal.azure.cn， 打开这个网站后选择虚拟机(Virtual machines) -> 新加一个虚拟机(add) -> 选择需要的镜像后下一步(create)，配置好CPU，内存大小，等资源信息后，生成虚拟机，稍等一会，虚拟机生成成功后，进入这个虚拟机中，选择停止这个虚拟机。 2.通用化对一台ARM的windows虚拟机执行sysprep【linux waagent -deprovision】，成功配置后，从管理门户关机以便释放资源windows虚拟机初始化教程： https://www.azure.cn/documentation/articles/virtual-machines-windows-generalize-vhd/linux虚拟机初始化： 1.azure.cn打开这个虚拟机，然后点击连接会出来一个ssh连接 终端开大连接进去 $ sudo su - $ waagent -deprovision 3.powershell login azure $ powershell PS C:\\Users\\kyxxx> Login-AzureRmAccount -EnvironmentName AzureChinaCloud # 输入帐号密码后会显示下面信息 Environment : AzureChinaCloud Account : admin@xxxxxp.xxxxxx.onmschina.cn TenantId : exxxxxxd-xxx8-4xxx-xxx0-xxxxxxxxxx48 SubscriptionId : 4xxxxxxa-xxx8-4xxx-xxxc-xxxxxxxxxx48 SubscriptionName : Windows Azure 企业 CurrentStorageAccount : 4.对该虚拟机执行Generalized标记 # test-vm : 资源组(Resource group) # centos7ExtractIamge: 虚拟机名字(Computer name) PS C:\\Users\\kyxxx>Set-AzureRmVM -ResourceGroupName test-vm -Name centos7ExtractIamge -Generalized # 操作成功后会显示下面信息 OperationId : Status : StartTime : EndTime : Error : 执行完以上步骤，该虚拟机就无法启动了. 5.开始生成镜像 PS C:\\Users\\kyxxx> Save-AzureRmVMImage -ResourceGroupName test-vm -VMName centos7ExtractIamge -DestinationContainerName \"imagetest\" -VHDNamePrefix \"centos7.2\" # test-vm : 资源组(Resource group) # centos7ExtractIamge: 虚拟机名字(Computer name) # \"imagetest\" : 目标容器名字，这个在生成镜像的.json文件里面有显示 # \"centos7.2\" : VHD名字前缀 centos7.2-osDisk.feb1809f-ff7d-42cc-861b-baa6c090c77e.vhd # \"image\": { # \"uri\": #\"https://testvmdisks334.blob.core.chinacloudapi.cn/system/Microsoft.Compute/Images/imagetest/ # centos7.2-osDisk.feb1809f-ff7d-42cc-861b-baa6c090c77e.vhd\" # }, # 操作成功后会显示下面信息 OperationId : Status : Succeeded StartTime : 2017/2/8 星期三 16:36:33 EndTime : 2017/2/8 星期三 16:36:33 Error : 6.删除虚拟机，然后跑路 通过私有镜像来创建虚拟机 下面没有实际操作，有问题找微软客服。 执行完以上操作后，源虚拟机使用的存储账号中出现一下container，里面包含操作系统vhd文件及json文件【可用于后期部署，该json文件中没有对nic的定义。后期需要进行定义】 使用刚刚的json模板及镜像vhd文件进行创建，并且成功创建 后期对json文件中的以下信息进行修改，再通过该镜像成功创建第二台虚拟机 \"vhd\": { \"uri\": \"https://jackrmdisks943.blob.core.chinacloudapi.cn/vmcontainerdce4465c-1f58-4159-a405-d43b751b566d/osDisk.dce4465c-test.vhd\" }, powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/面试题/js.html":{"url":"doc/面试题/js.html","title":"JS","keywords":"","body":" 1. 浏览器输入url到页面最后呈现 有哪些过程？ 2. 浏览器渲染页面流程 3. ES6新特性 4. 手写函数防抖和函数节流 4.1 函数防抖 4.2 函数节流 5. 这段代码里的 this 是什么？ 6. 数组去重 7. 实现继承 [TOC] 1. 浏览器输入url到页面最后呈现 有哪些过程？ 用户输入URL地址 浏览器解析URL解析出主机名 浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存） 浏览器将端口号从URL中解析出来 浏览器建立一条与目标Web服务器的TCP连接（三次握手） 浏览器向服务器发送一条HTTP请求报文 服务器向浏览器返回一条HTTP响应报文 关闭连接 浏览器解析文档 如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕 2. 浏览器渲染页面流程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 https://segmentfault.com/a/1190000010298038 https://juejin.im/post/5a8e242c5188257a6b060000 3. ES6新特性 https://fangyinghang.com/es-6-tutorials/ 1、作用域：块级作用域、let、const： 块作用域： var a = 1; { var a = 3; } console.log(a) // 1 2、箭头函数 sum = (a, b) => a + b nums.forEach( v => { console.log(v) }) 词法 this 3、参数处理 默认参数值 function multiply(a, b = 1) { return a * b; } 剩余参数：允许我们将一个不定数量的参数表示为一个数组 function sum(...theArgs) { return theArgs.reduce((previous, current) => { return previous + current; }); } console.log(sum(1, 2, 3)); // expected output: 6 展开运算符：将数组表达式或者string在语法层面展开 function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // expected output: 6 4、模板字面量 多行字符串 console.log(`string text line 1 string text line 2`); 插入表达式 var a = 5; var b = 10; console.log('Fifteen is ' + (a + b) + ' and\\nnot ' + (2 * a + b) + '.'); // \"Fifteen is 15 and // not 20.\" 4. 手写函数防抖和函数节流 防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 4.1 函数防抖 防抖（用户连续点击，点击间隔小于0.5秒，那么用户停止点击后才执行）： function debounce(fn, delay){ let timerId = null return function(){ const context = this if(timerId){window.clearTimeout(timerId)} timerId = setTimeout(()=>{ fn.apply(context, arguments) timerId = null },delay) } } const debounced = debounce(()=>console.log('hi')) debounced() debounced() 4.2 函数节流 节流（函数执行一次后，有冷却时间）： function throttle(fn, delay){ let canUse = true return function(){ if(canUse){ fn.apply(this, arguments) canUse = false setTimeout(()=>{canUse = true}, delay) } } } const throttled = throttle(()=>console.log('hi')) throttled() throttled() 5. 这段代码里的 this 是什么？ fn() this => window/global， 函数里的this就是外面的this obj.fn() this => obj fn.call(xx) this => xx fn.apply(xx) this => xx fn.bind(xx) this => xx new Fn() this => 新的对象 fn = ()=> {} this => 外面的 this 关于this的具体讲解：https://zhuanlan.zhihu.com/p/23804247 6. 数组去重 遍历数组法： var arr = [2, 2, 3, 4, 5, 3, 5, 7]; for (var i = 0, newArr = [], len = arr.length; i 数组下标判断法： var arr = [2, 2, 3, 4, 5, 3, 5, 7]; for (var i = 1, newArr = [arr[0]], len = arr.length; i ES6简化版： var arr = [2, 2, 3, 4, 5, 3, 5, 7, 7, 7, 7, 8, 8]; var newArr = [...new Set(arr)]; console.log(newArr); var newArr = Array.from(new Set(arr)); console.log(newArr); 7. 实现继承 ES5实现： function Animal(color){ this.color = color } Animal.prototype.move = function(){} // 动物可以动 function Dog(color, name){ Animal.call(this, color) // 或者 Animal.apply(this, arguments) this.name = name } // 下面三行实现 Dog.prototype.__proto__ = Animal.prototype function temp(){} temp.prototye = Animal.prototype Dog.prototype = new temp() Dog.prototype.constuctor = Dog // 这行看不懂就算了，面试官也不问 Dog.prototype.say = function(){ console.log('汪')} var dog = new Dog('黄色','阿黄'); ES6实现： class Animal{ constructor(color){ this.color = color } move(){} } class Dog extends Animal{ constructor(color, name){ super(color) this.name = name } say(){} } powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/面试题/css.html":{"url":"doc/面试题/css.html","title":"CSS","keywords":"","body":" 1. IE盒模型和标准盒模型 1. IE盒模型和标准盒模型 可使用CSS属性来切换IE盒模型和标准盒模型： box-sizing:border-box || content-box || inherit 当使用content-box时：页面将采用标准模式来解析计算，content-box也是默认模式 当使用border-box时，页面将采用怪异模式解析计算，怪异模式也称为IE模式 当使用inherit时：页面将从父元素继承box-sizing的值 参考资料：https://www.jianshu.com/p/cc2bc404269b powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "},"doc/面试题/面试问过的问题.html":{"url":"doc/面试题/面试问过的问题.html","title":"问过的问题","keywords":"","body":" webpack打包工具如何只打包代码用到的包。 问了一些后端数据库知识。 什么情况下页面会重绘？ 如何设置页面缓存？ 前端跨页面通信，你知道哪些方法？面试官提到了Service Worker 什么是跨域，工作中如何实现跨域。 ES6新增的异步方法有哪些。 浏览器输入url到页面最后呈现 有哪些过程？ 浏览器发一个请求前会做什么？option方法 HTTP状态码有哪些？ powered by Gitbook文件最后修改时间： 2019-10-23 00:04:20 "}}